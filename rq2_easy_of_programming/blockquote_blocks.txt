Rust's native build system. In which case the idea is (contrary to what your parent comment suggests) that they're not trying to be the ultimate solution for building your most complex software, but only to offer sensible defaults for smaller projects.Linux, Firefox, LibreOffice, Blender, are too complicated
LinuxDistributions
Working Group @ Open Mainframe  Project (OpenMP has been enabled for
gcc and developed for LLVM, but forgotten to commit)
* IBM has released the IBM LinuxONE RockHopper 4 for Edge Computing and
Industry 4.0 (matching default server racks):
 https://newsroom.ibm.com/2023-04-04-IBM-Furthers-Flexibil... 

## Doug

* Google Summer of Code
* 32 Proposals Submitted; some were submitted that were not listed on
101.opensuse.org
lkocman: Do we have any number for last year? Like are we growing or is
it about the same?
* If interested in mentoring, email ddemaio
* Lists of proposal titles not listed on 101.o.o:
* Container-Based Backend for openQA: Enhancing Automated Testing of
Containers.
* AES Technology
* Editing directory services with Yast2
* Contribute more aboutRust
rustwhich is responsible for the rapid development oflinuxGPU drivers on Apple M1/M2 hardware.  
 
Firefox may have a minor market share but to keep it going so long as, not a "viable", but an almost 100% functional alternative to the Webkit/Blink duopoly is remarkable.  
 
Lastly, maybe Mitchell Baker
Linuxand other operating systems. Chrome had aLinuxversion, but not from day one remember. And I believe the combined forces of Firefox and Chrome has driven Apple to make Safari more standards compliant. Microsoft tried several times to go their own way, but ultimately failed. Today they provide aLinuxport of Edge, not only experimentally, but simply as one of several supported platforms. Would that have happened without Mozilla and Firefox? I'm not so sure. 
 
I use Firefox onLinuxand Android. Not because there are no alternatives, but because Firefox best supports me as a user. Support for add-ons are essential to me, some of which does not exist on other browsers. 
 
Sure the Mozilla project and Firefox project has not been without failures and heavily criticised ventures, but I fail to name other long lived FLOSS projects that have had a 25 year streak of purely successful attemts to keep up whith the times and explore new territory. Not to mention maintaining such complex software as a modern browser engine. 
 
A few years ago an entire new programming language,Rust
Linuxfirefox users ever mattered that much; for all our sense of self-importance, even in Firefox's heydey numerically we were a rounding error of Mozilla's userbase, the overwhelming majority of which was, and continues to be, running Windows.  Even amongst the "power user" crowd. 
 
In the end, Mozilla's enduring legacy will probably be as the original creators ofRust
RustAt the FOSDEM event, I gave feedback about the development of a security 
library that needs to deal with backward and forward compatibility, 
because of security features tied to specific kernel versions, handling 
different use cases in a safe and secure way. We explain patterns that 
we used to make it possible to fine tune the requested (optional) 
features while providing a safe default behavior. For simple use cases, 
the idea is to provide a best-effort security approach for potentially 
unsupported kernel features: use available features and ignore others. 
However, in more complex use cases, we may want to make some features 
depend on others. We may also want to handle errors differently based on 
unsupported features.
See 
 https://fosdem.org/2023/schedule/event/rust_backward_and_... 

Version 0.2.0 was released, which makes available a first milestone. 
There is still work going on to improve the backward and forward 
interface, but that would be for the next major version.

### Go

Günther Noack gave a nice talk at the Zurich Gophers Meetup about 
Landlock and how to use it with the Go library: 
 https://blog.gnoack.org/post/go-landlock-talk/ 

The Go library now supportsLinux
Linux? Mesa is MIT licensed as well which allows lots of corporate participation which means better drivers. It is hard to overstate the value forLinuxgamers of Proton which of course is a result of Valve adopting Wine to port Windows games as part of their Steamdeck andLinuxstrategy. Wine is LGPL which is only "weak" copyleft. 
 
Perhaps the most important software created by the FSF is GCC. I prefer Clang and am thankful that Apple for contributed so heavily to this BSD licensed compiler. Despite the availability of GCC, Clang / LLVM has attracted usage and contributions from Microsoft, IBM, Qualcomm, Intel, Meta, and others. I benefit tremendously from the fact that these companies use this software. Mozilla was able to use LLVM as the back-end when they createdRust
linuxkernel have been screwed over too often. By all means have flags to over-ride and assume one's, two's, no overflow, whatever. 
 
Yeah, my favourite language was implemented with fixed point BCD arithmetic initially, then it moved to 64-bit floats (while still looking like it did in the past). (And I think it has a bigint library so if you overflow it swaps over, but I've not found that out yet.) But at all points the expected behaviour was clearly defined. 
 
But let's put it nice and simply, if the language model does not define what happens, it should not hand responsibility for an operation over to a third party and then screw the user over by assuming the operation succeeded and preventing the user from checking on it. 
 
If a language has UB, it's not a proper language. It's just a pile of nasty sharp glass fragments. That's whyRust
linux-restricted-signatures-aws-5.19 5.19.0-1021.22~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-restricted-modules-aws-5.19 5.19.0-1021.22~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-azure-5.19 5.19.0-1022.23~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-meta-azure-5.19 5.19.0.1022.23~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-signed-azure-5.19 5.19.0-1022.23~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-restricted-signatures-azure-5.19 5.19.0-1022.23~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-restricted-modules-azure-5.19 5.19.0-1022.23~22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-azure-fde 5.15.0-1035.42.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-meta-azure-fde 5.15.0.1035.42.12 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-signed-azure-fde 5.15.0-1035.42.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 * systemd-hwe 249.11.3 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-signed-ibm 5.15.0-1026.29 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-meta-ibm 5.15.0.1026.22 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-ibm 5.15.0-1026.29 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 * libfprint 1:1.94.3+tod1-0ubuntu2~22.04.04 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 * rsync 3.2.7-0ubuntu0.22.04.2 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 * rsync 3.2.7-0ubuntu0.22.04.2 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-ibm 5.15.0-1026.29 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-signed-ibm 5.15.0-1026.29 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-meta-ibm 5.15.0.1026.22 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-meta-raspi 5.15.0.1025.22 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *linux-raspi 5.15.0-1025.27 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 * tiff 4.3.0-6ubuntu0.4 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 * tiff 4.3.0-6ubuntu0.4 -
 https://lists.ubuntu.com/archives/jammy-changes/2023-Marc... 
 *rust
RustforLinuxkernel community to introduceRustin general to developers coming from a C background. That is probably the reason therust-for-linuxmailing is such a treat. Many threads includes a slightly wider review on the difference between C andRust, and howRustscapabilities provides
> Are Android Binder and the NVMe driver reimplementations of earlier C drivers?  
 
FWICT: yes. 
 
FYI, there was a talk about the NVMerustdriver atLinuxPlumbers '22 - might contain some more info and possible answers to your other question: 
 
slides:  https://lpc.events/event/16/contributions/1180/attachment...  
 
video:  https://www.youtube.com/watch?v=BwywU1MqW38
User-modeLinux(on x86-64 systems) now supports code written inRust.
Heiseinterviews
Miguel Ojedaabout theRust-for-Linuxproject.
Linux(#3215)
   * ci: add go.mod to canary workflow (#3288)
   * feat(python): skip dev dependencies (#3282)
   * chore: update ubuntu version for Github action runnners (#3257)
   * fix(go): skip dep without Path for go-binaries (#3254)
   * feat(rust): add ID for cargo pgks (#3256)
   * feat: add support for swift cocoapods lock files
running packages to users.   
 
Unless you have very deep knowledge about C, shared libraries,Rustand Python on all target platforms (macOS, Windows, and a series ofLinuxdistros) it can't be done.  It's just more or less impossible to distribute software written in Python in this way.
linuxType "help", "copyright", "credits" or "license" for more information.
>>> import datetime as dt
>>> epoch = dt.datetime(1970, 1, 1, 0, 0, 0, tzinfo=dt.timezone.utc)
>>> print(epoch)
1970-01-01 00:00:00+00:00
>>> print(epoch + dt.timedelta(microseconds=(2**63 - 1) // 1000))
2262-04-11 23:47:16.854775+00:00
>>> print(epoch - dt.timedelta(microseconds=(2**63) // 1000))
1677-09-21 00:12:43.145225+00:00
>>> # For comparison:
>>> print(epoch + dt.timedelta(seconds=(2**31 - 1)))
2038-01-19 03:14:07+00:00
>>> print(epoch + dt.timedelta(seconds=(2**32 - 1)))
2106-02-07 06:28:15+00:00
>>> print(epoch + dt.timedelta(seconds=(2**63 - 1)))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: Python int too large to convert to C int
>>> print(dt.datetime.max)
9999-12-31 23:59:59.999999
 
 Sure, 2262 is a long time in the future. But it's not so absurdly far into the future that you won't eventually have compatibility problems (unlike the Python max datetime, which
Linuxdistro do it for them. They have been trying to untangle the resulting technical debt for the last couple of decades or so, but nobody seems to agree on how, or even whether, to standardize a solution. 
 
C extensions are a more interesting issue. Compiling and distributing C extensions is complicated, because you don't know what libraries (and versions of libraries) will be available on the target machine. That leaves you with four options: 
 
1. Pick a "reasonable" set of libraries and versions that are "probably" installed. This is basically what manylinux does, and it's why it's called "many" rather than "all." The drawback is that this is probably going to be a fairly small set of relatively old libraries, so it doesn't really solve the problem very thoroughly. 
2. Vendor and/or statically link everything, likeRust
Linuxusers often work with text files; tools likegrep,awk, 
andsedare standard utilities in their toolbox. However, these
tools fall 
short when trying to extract or edit data from files in a binary format, analyze
corrupt 
media files, or for parsing a binary data format.FOSDEM 2023in Brussels had a wholebinary tools
devroomdedicated to open-source programs that deal with binary data.
Rustin the   async_iter   submodule. However, a major downside of it is that in its current form it is scheduled to become a carbon-copy of the existing  std::iter  crate, with the only difference being that most functions and closures will be prefixed with the  async  keyword. That's a lot of duplication which needs to be maintained, just because because we wanted an async version of one interface. And it's likely at some point the stdlib will want to provide its own version of async  TcpStream , async  File , etc. - and that would result in an enormous amount of duplicate APIs which would largely be identical to their non-async counterparts. 

 And the problems don't just stop with  async  either. Have you ever wondered why you can't just use the  ?  operator from a closure? Or have you seen theRustforLinux
The list of enhancements to the kernel's embryonic support for theRustlanguage is relatively small this time, but that support is,according
     to Miguel Ojeda, "getting closer to a point where the firstRustmodules can be upstreamed".  These changes include the
     removal of a non-applicable part of the alloc crate, animplementationof
     theArctype
     (which provides a reference-counted pointer), theScopeGuardtype
     (which runs some cleanup code when it goes out of scope), and theForeignOwnabletype, which facilitates moving pointers betweenRustand C code.
That would require more coordination between the developers ofpipand those for other environments, 
such as conda and theLinuxdistributions, Mooresaid;
the longtime message has been thatpipis the wrong way to install
packages system-wide onLinux, for example.  He is not against the idea,
but worries that it is not going to be user-friendly:
Yubico developedlibfido2, a C library and
corresponding command-line tools to communicate with a FIDO device (not
only the ones made by Yubico) over USB or NFC. It supports the FIDO U2F and
FIDO2 protocols. The project is licensed under the BSD 2-clause license and
supportsLinux, macOS, Windows, OpenBSD, and FreeBSD. Some external
projects have built upon libfido2 to create bindings for.NET,Go,Perl, andRust. Yubico also
maintains a Python library,python-fido2, that is
tested onLinux, macOS, and Windows.
Rust, and many
other languages.  GDB can target (i.e., debug programs running on)
more than a dozen different processor architectures, and GDB itself
can run on most popular GNU/Linux, Unix and Microsoft Windows variants.
GDB is free (libre) software.

You can download GDB from the GNU FTP server in the directory:

         ftp://ftp.gnu.org/gnu/gdb 

The vital stats:

  Size   sha256sum                                                         Name
  23MiB  115ad5c18d69a6be2ab15882d365dda2a2211c14f480b3502c6eba576e2e95a0  gdb-13.1.tar.xz
  39MiB  4cc3d7143d6d54d289d227b1e7289dbc0fa4cbd46131ab87136e1ea831cf46d4  gdb-13.1.tar.gz

There is a web page for GDB at:

         https://www.gnu.org/software/gdb/ 

That page includes information about GDB mailing lists (an announcement
mailing list, developers discussion lists, etc.), details on how to
access GDB's source repository, locations for development snapshots,
preformatted documentation, and links to related information around
the net.  We will put errata notes and host-specific tips for this release
on-line as any problems come up.  All mailing lists archives are also
browsable via the web.

GDB 13.1 includes the following changes and enhancements:

* Support for the following new targets has been added in both
  GDB and GDBserver:

  ** GNU/Linux/LoongArch (gdbserver) loongarch*-*-linux
Rustand compiled to Wasm are provided, covering the use cases from tracing, networking to security. 
 
Wasm-bpf offers several advantages for eBPF: 
 
- Secure and reliable execution environment with Wasm's isolation in user space. 
- Easy distribution and management with the Wasm container ecosystem and toolchain, for example, Wasm OCI images or docker for Wasm. 
- Cross-language support for over 30 programming languages for eBPF user space programs 
- Agile development with the ability to dynamically load and unload eBPF plugins when running. 
- Lightweight and efficient, WebAssembly applications consume significantly less resources compared toLinux
The core idea behind BPF is that it allows programs to be loaded into the
kernel from user space at run time; using BPF for scheduling has the
potential to enable significantly different scheduling behavior than is
seen inLinuxsystems now.  The idea of "pluggable" schedulers is not new;
it came up inthis 2004 discussionof yet
another doomed patch series from Con Kolivas, for example.  At that time,
the idea of pluggable schedulers was strongly rejected; only by focusing
energy on a single scheduler, it was argued, could the development
community find a way to satisfy all workloads without filling the kernel
with a confusion of special-purpose schedulers.
The PyPA focus is on supporting the "standard" builds of Python
(python.org,Linuxdistro builds, Windows Store, self-built interpreters,
Homebrew, ...) Solutions that require the user to switch to a different
Python build don't fit that remit. I don't think that "declare all of those
Python builds as out of scope" has any more chance of being acceptable to
the SC [steering council] than "declare a big chunk of the user base" does.
TheFlatpakpackage format promises to
bring "the future of apps onLinux", but aLinuxdistribution like
Fedora already provides packages in its native format—and built
to its specifications.  Flatpaks that come from upstream projects may or
may not follow the packaging guidelines, philosophy, and practices so they
exist in their own world, separate from the packages that come directly
from Fedora.  Butthose worlds have
collidedto a certain extent over the 
past year to two.  Recently, a
packager announced their plans to stop packaging theBottles tool, used for running
Windows programs in Wine-based containers onLinux, in favor of
recommending that Fedora users install the upstream Flatpak.
Rustcan capture more of this than C, but they cannot capture everything that the programmer has in mind. 
 
So it isn't fair to ask "how can you make a function type safe" but it is perfectly reasonable to ask "how can you make a function MORE type safe".  One way is to use the "embedded anchor" pattern as described in the article, rather than using void pointers.  There are other approaches such as using macros and the "typeof()" operator.  Have a look in include/linux/minmax.h in theLinux
In particular,LinuxSVSM offers services to interact with the 
AMD Secure Processor (ASP), which is a key
component of AMD'sSecure Encrypted Virtualization
(SEV)technology. The "Zen 3" architecture introduced with
third-generation AMD EPYC processors uses the ASP to protect both the memory and
register states of secured guests; the servicesLinuxSVSM provides take
advantage of these hardware capabilities.LinuxSVSM provides secure services in accordance
with theSVSM specificationto help minimize the attack surface on guest machines.
Its releasewas announcedon thelinux-coco confidential-computing mailing list, where the community
is actively discussing development-related topics.LinuxSVSM is an effort
in the direction ofvirtualizedconfidential computing.
Understanding this requires an introduction to the most
recent SEV features.
rust-resctl-demo-2.1.2-8.fc37  
   Date : 
                 Sun, 29 Jan 2023 01:35:17 +0000  
   Message-ID : 
                 <20230129013517.BF742304C822@bastion01.iad2.fedoraproject.org>  
   Archive-link : 
                  Article   
  --------------------------------------------------------------------------------
Fedora Update Notification
FEDORA-2023-e3c8abd37e
2023-01-29 01:31:21.819456
--------------------------------------------------------------------------------

Name        :rust-resctl-demo
Product     : Fedora 37
Version     : 2.1.2
Release     : 8.fc37
URL         :  https://crates.io/crates/resctl-demo 
Summary     : Guided tour ofLinux
Linuxand Docker: a
repository of pot flavours and complete container images for usage with pot and
in many cases Nomad.

As you can see, we had a busy quarter again, this time including improvements
to the Nextcloud as well as Jitsi images.

Furthermore, we landed pot-based FreeBSD support for sccache-dist server (the
server component for distributed compilation ofrust
Much of the discussion that stemmed from that exchange veered away from the
governance question and further into the packaging details, so Cannon split
those responses into a new thread in thePackaging category of the
forum. The new thread ("Wanting a singular packaging tool/vision") started with John Hagen'scallfor a "unified tooling experience".   In his view, Python should
adopt a model 
similar 
to that ofRust's: "The kind of unified, cross platform experience theRustteam has managed withrustup/cargo/rustcthat bootstraps so well would 
be great."  Hefurther
described his visionlater in the thread.
Beyond that, there can be conflicting dependency needs between different
packages or applications.  If application A needs version 1 of a
dependency, but application B needs version 2, only one can be
satisfied because only a single version of a package can be active for a
particular Python instance.  It is not possible to specify that the import
statement in A picks up a different version than the one that B picks
up.Linuxdistributions solve those
conflicting-version problems in various ways, which sometimes results in
applications not being available because another, more important package
required something that conflicted.  TheLinux-distribution path is not a
panacea, especially for those who want bleeding-edge Python applications and
modules.   For those not following that path, this is where the Pythonvirtual
environment(venv) comes into play.
Linux. It's a GPLv2'd middlebox shaper for ISPs, with XDP for the bridge, eBPF to measure TCP RTTs - live and in flight at 10ms sampling resolution for that data! - and we're now pushing 20Gbits/sec for 10,000 customers at a time on a mere 16 Xeon cores, AND we're using cake to shape it all and kill the bufferbloat. The early deployments are going really well, and despite me whinging about getting better home routers here and everywhere for so many years, perhaps some adventurous ISPs (if you know of any), will want to give this middlebox a shot and make their network better for their users that way.  
 
There's also Tons ofRust
Linux. It does not require any special
  configuration, so it should be pretty easy to get started with it.

  If you need help: I monitor this list and the OCaml discord server,
  and I’ve set up an [OBazl discord] server. You can also file an issue.

  PRs are welcome, but since this is still in flux, please file an issue
  first to make sure your idea is still relevant and needed.


[OCamlCC] < https://github.com/obazl-repository/ocamlcc >

[OBazl discord] < https://discord.gg/wZCSq2nq6y >


Other OCaml News
════════════════

From the ocaml.org blog
───────────────────────

  Here are links from many OCaml blogs aggregated at [the ocaml.org
  blog].

  • [Engineer Spotlight: Zach Shipko]
  • [Engineer Spotlight: Jules Aguillon]
  • [LoveRust
Rustand now Ada are using to solve handling of dynamic memory issues) were, initially, invented by mathematicians and adopted by GC-based functional languages. Not to manage memory, but to manage external resources (in that case “they would be freed but we have no idea when, precisely” is bad answer).Rustdiscovery (as with  TMP  it was discovered, not designed into the language from beginning) was surprising and somewhat startling and it's not even mathematical fact, but a social one: if you give people an easy-to-use affine type system then they can solve almost all practical memory handling problems without GC, just with a small amount of  unsafe  code. 

 It's still not clear whether you can  rewrite piecemeal  any old code with similar results (which is whatLinux
teaching aren't really about the language being used.Rustgetting immense credibility from its use inLinuxis very real though. You'd be able to tell your students "it's used byLinuxnow" and folks in the workforce will be able to tell their managers the same.
rustwill move into the kernel. I've spent the last few months very slowly writing a blog server inrust, mostly for learning purposes - and it's good - it reminds me of Haskell at university: If the code compiles, it almost certainly runs. 
 
I do hope though that the kernel will move to the gccrustimplementation. This would avoid the kernel becoming a "monorepo" style repository requiring two toolchains with a version compatibility matrix. 
 
GCC is also important for the embedded space. When we moved from proprietary compilers to gcc in the embedded work at a former employer it was quite a revolution, suddenly we could customize the toolchain and upgrade compilers without vendor communication. rustc's licensing may see a return to the bad old days when we got a binary delivery of the compiler and we were beholden to the hardware vendor for fixes, this would be very unpleasant and would makeLinux
Pushing a module written inRustfor the mainline seems almost certain to spark a
significant discussion.  While many kernel developers are enthusiastic
about the potential ofRust, there are others who are, at best,
unconvinced.  This latter group has gone quiet in recent times, presumably
waiting to see how things play out.  After all, as Linus Torvalds has said,
the currentRustcode is an experiment; if that experiment does not go
well, the code can be taken out again.
Rustgains a real foothold, C will be relegated to "minor maintenance" very quickly. 
 
I have had exposure to a lot more operating systems than many people here. I am (just) older than Unix. And unfortunately "the good is the enemy of the perfect" is only too true. 
 
Look at *why* Unix (and thenlinux
Linuxkernel development and does whatever, either a community of devs decides to fork, or they don't and it becomes Google's shop. Under no circumstances Google decides it's time to think of the poor little users. If you expect that, you'll live floating from disappointment to disappointment. 
So, yes, that's an answer I would accept, because just as I value my time and expect you to respect it I owe other people respect for theirs. 
 
 > My point is:Linuxdistributions are made possible because traditionally because stable APIs made it possible for everyone to assemble their system of choice on their platform of choice. Be it Debian with a FreeBSD kernel or an open source fork of Solaris on x86_64. Everyone has been able to use what they prefer in the configuration they wanted with the individual components such as GNOME, Emacs, GCC, libpng etc being highly portable thanks to using stable APIs.  
 
More than anything else, distributions are made possible by people doing the work, not by the spectators booing from the grades. 
 
 > Now all of a sudden, theRust
Predicting thatRustsupport would land in theLinuxkernel was not a sure
bet; that is a major change for an old software project.  But your editor
wasn't able to see that, while this was happening, others would already be
writing 
useful kernel modules inRustthat many users are going to end up wanting.
The Apple-silicon GPU driver probably tops the list of interesting kernel
features that are only available inRustform, but the in-kernel 9P
filesystem support may end up being popular as well.
Linux.   

 Like everything, it's a trade-off.   Yes, there is overhead associated with magic numbers.  But it's not a lot of overhead  (and it's certainly cheaper than KMSAN!) and the ethos of "trying to eliminate an entire set of bugs" which is something is well accepted for making the kernel more secure, is someting that could be applied for magic numbers as well. 

 I still use magic numbers in e2fprogs, where the magic number is generated using the com_err library (another Multicism; where the top 24-bits identify the subsystem, and the low 8-bits is the error code for that subsystem).   This means it's super easy to do things like this:
 

 In lib/ext2fs/ext2fs.h:

 
#define EXT2_CHECK_MAGIC(struct, code) \
	  if ((struct)->magic != (code)) return (code)
 

 In lib/ext2fs/ext2_err.et.in:

 
	error_table ext2

ec	EXT2_ET_BASE,
	"EXT2FS Library version @E2FSPROGS_VERSION@"

ec	EXT2_ET_MAGIC_EXT2FS_FILSYS,
	"Wrong magic number for ext2_filsys structure"

ec	EXT2_ET_MAGIC_BADBLOCKS_LIST,
	"Wrong magic number for badblocks_list structure"
 

 The compile_et program generates ext2_err.h and ext2_err.c, for which ext2_err.h will have definitions like this:

 
#define EXT2_ET_BASE                             (2133571328L)
#define EXT2_ET_MAGIC
Linuxdistributions provide that. 

 Yes. At the cost of making it unable to use anything up-to-date. Bad for end-users (coz games and most productivity software), bad for developers (coz up-to-date versions of everything are never there). 

 It's not even clear whether that's a win for security (certainly no one inRust
rust. Then I saw a presentation at thelinuxplumbers conference about how they want to ease maintenence by using the rustc compiler crates for things like the borrow checker (once they can actually compile those). 
 
How independent are two compilers when they share implementation of core parts like the borrow
Rustfrontend in GCC that can re-use those plugins: 
 
 > As the source of the GCC plugin infrastructure in theLinuxkernel and nearly all of the GCC plugins adapted for inclusion in the upstreamLinuxkernel, we too immediately spotted the importance of this problem and set out to ensure
I can't help thinking it's got something to do withRustcode popping up in theLinuxkernel. Isn't GCC still the primary C compiler for the kernel? Would be nice if it could be the primaryRustcompiler as well.
Linuxkernel, Apache and friends, and for that matter many implementations of nicer languages than C, most of the code we're running on a daily basis remains written in C, and it will be a while yet before new languages likeRustget enough traction (and architecture support) to be serious
linuxkernel developers have slowly shifted from hardware mindset to software mindset when fuzzing guys found more and more crazy ways to break what they have thought was well-designed and tested piece of code. 

 Now they are even trying to useRustas a mitigation tool. It would be interesting
Linuxkernel then most TOCTOUs which caused security problems, happened inside of kernel, not outside of it. 

 > Other than how I did it years ago in Fortran, files were configured NR&1W, everybody could open the file read-only, but to change it, you had to open it r/w, and then run the entire transaction from scratch. 

 Today we have  Rwlocks  for that and you can [try to] upgrade reader lock to writer lock. But yes,Rust
Linuxdeal with these… it's not easy to say the least). 

 And when  hardware itself  behaves unpredictably (usually in sane way, but occasionally in way that layman wouldn't expect at all) the only reasonable approach would be what C, C++ andRustare doing: describe rules which developer
Rust) but, in turn, it  places additional restrictions , too. 

 > So you can assume, by default, that allRustcode is safe. 

 Yes. But some developers don't buy that argument and program in unsafeRustlike you claim it's Ok to program in C. Some of them are even quite capable and knowledgeable. That's how we end up  in that situation : if nothing else works they are just expelled from the ecosystem. 

 C couldn't afford that solution. 

 > The problem with all these fancy C optimisations is that they take advantage of code that the programmer didn't even realise was unsafe. 

 Sure, but  the only way  to solve that problem is to  change the abstract machine specification ! And attempts to do that  have failed spectacularly . 

 Maybe at one point is was a surprise to the developers that signed overflow is undefined in C and C++, but in last 10 years so many articles and lectures talked so much about these that I have no idea where you have to live not to know that. And if you know and still want to use that mode (likeLinux
Linuxdesktop or laptop in the last decade. 
Even though most of these systems have (had) "spinningrust" HDDs, which are known for their high latency. 
But I only use raw ALSA, not stuff like PulseAudio. 
 
Something has to be seriously broken in Fedora then. 
Or your system is running
Linuxis doing is not, really, feasible because there are just too many programs which are not even supposed to work with random C compiler (and their developers don't plan to fix them).  
 
 >Rustwas born in a different era thus it can use crater run. But even
Rustwas born in a different era thus it can use  crater run . But even then they haven't adopted Linus rule, it's not really feasible. They contact developers and help them to fix bugs in their code, instead  Here  you can see compatibility notes for crates broken byRust1.64.0 release. 

 > I have  written about this at greater length . 
 
 I saw that before. Like all  O_PONIES  proposals they end up in a trash can (like similar proposals forLinux
allowed to just use random free software found in random place unless they would find someone who would shoulder the liability insurance burden. 

 Most likely these foundations (Linux, Python,Rust, etc) would shoulder that burden, but of course they would only do that if you would agree to follow certain rules.
Linuxkernel, clang, chrome, gcc or evenRust. 

 These make sense today because different commercial players share the development cost. But if you impose liabilities on them without the means to share that burden then savings from shared development would stop being beneficial enough for them to continue. 

 I don't think
Rustyet" are probably less extensive than you think. For example, a new network QoS, filesystem, or LSM, basically anything new and optional would be fair game. That may not fit your definition of "core", but to many people it does, so it's worth noting thatRustisn't just for drivers. 
 
On the other hand, any rewrite of existing C code will need a very strong justification, and will probably remain "just an alternate implementation" for a long time. 
 
What willRustactually be used for in mainline remains a wait-and-see affair. It's great to see enthusiastic reports like this one, but it'll also be interesting to read some neutral and maybe negative feedback. 
 
It'll be a long time before there's a push forRustin actual core irreplaceableLinux
Linuxkernel, among other programs uses pretty much all such flags that are available; these cover many undefined behaviours that have caused problems in the past, but in the next release of GCC (or other C compilers) the compiler may exploit some other undefined behaviour not covered by the previous flags; if you are lucky, there's a new flag for defining that particular undefined behaviour away.  TheLinuxkernel also seems to be revving up to switch to a different language (Rust
Linuxcode inRustso long as the set of architectures considered first class forLinuxisn't a subset of the architectures which at least work in practice (lets say at least Tier 3 support) forRust. 
 This is one of the big motivations for both gccrustfront
LinuxEnterprise Server 12-SP2-BCL
                    SUSELinuxEnterprise Server 12-SP3-BCL
                    SUSELinuxEnterprise Server 12-SP4-LTSS
                    SUSELinuxEnterprise Server 12-SP5
                    SUSELinuxEnterprise Server for SAP 12-SP4
                    SUSELinuxEnterprise Server for SAP Applications 12-SP5
                    SUSELinuxEnterprise Software Development Kit 12-SP5
                    SUSE OpenStack Cloud 9
                    SUSE OpenStack Cloud Crowbar 9
______________________________________________________________________________

   An update that solves 10 vulnerabilities, contains 10
   features and has 5 fixes is now available.

Description:

   This update for binutils fixes the following issues: The following
   security bugs were fixed:

   - CVE-2019-1010204: Fixed out-of-bounds read in elfcpp/elfcpp_file.h
     (bsc#1142579).
   - CVE-2021-3530: Fixed stack-based buffer overflow in demangle_path() inrust
Linuxcode inRustso long as the set of architectures considered first class forLinuxisn't a subset of the architectures which at least work in practice (lets say at least Tier 3 support) forRust. This is because in effect such core code would mean nowLinux
Yeah, I am skeptical aboutLinuxdevelopers migrating in flock toRustfor core code, but for drivers it's a slam dunk.
wrote  in early October thatRustis "not likely to infuseLinuxwith a much-needed boost in its contributor base, becauseLinuxhas no such need" (among other negative comments). 
 
If other developers too find thatRustis so much easier for driver development, its use could explode very rapidly.
LinuxEnterprise Module for Packagehub Subpackages 15-SP3
                    SUSELinuxEnterprise Module for Packagehub Subpackages 15-SP4
                    SUSELinuxEnterprise Server 15-SP1-BCL
                    SUSELinuxEnterprise Server 15-SP1-LTSS
                    SUSELinuxEnterprise Server 15-SP2-BCL
                    SUSELinuxEnterprise Server 15-SP2-LTSS
                    SUSELinuxEnterprise Server 15-SP3
                    SUSELinuxEnterprise Server 15-SP4
                    SUSELinuxEnterprise Server for SAP 15-SP1
                    SUSELinuxEnterprise Server for SAP 15-SP2
                    SUSELinuxEnterprise Server for SAP Applications 15-SP3
                    SUSELinuxEnterprise Server for SAP Applications 15-SP4
                    SUSE Manager Proxy 4.1
                    SUSE Manager Proxy 4.2
                    SUSE Manager Proxy 4.3
                    SUSE Manager Retail Branch Server 4.1
                    SUSE Manager Retail Branch Server 4.2
                    SUSE Manager Retail Branch Server 4.3
                    SUSE Manager Server 4.1
                    SUSE Manager Server 4.2
                    SUSE Manager Server 4.3
                    openSUSE Leap 15.3
                    openSUSE Leap 15.4
______________________________________________________________________________

   An update that solves 10 vulnerabilities, contains 10
   features and has three fixes is now available.

Description:

   This update for binutils fixes the following issues:

   The following security bugs were fixed:

   - CVE-2019-1010204: Fixed out-of-bounds read in elfcpp/elfcpp_file.h
     (bsc#1142579).
   - CVE-2021-3530: Fixed stack-based buffer overflow in demangle_path() inrust
Rustdoesn't have Either in it's  stdlib . There are  either crate  with  really featureful Either , and it's  widely used , but from my understandingLinuxkernel doesn't like to depend on external crates.
Construction, and I can tell you that this is mostly wrong. There is no obvious relation betweenRustand the Calculus of Construction (which is about dependent types, no linear types), and the subarctic blog you cite is wrong. This also has no relevance to theLinuxkernel or string types whatsoever.
Rustinfrastructure that has been posted in the past, including complete drivers; it's just not being pushed upstream yet.  I've been fairly deliberately looking closely at the code as it heads toward the mainline just because it breaks the problem down into manageable pieces.  The wholeRust-for-Linux
string, one can't do some useful patterns like having a single allocated "buffer" used in a loop without allocating/freeing.  The equivalent ofRust's String is really things like https://developer-old.gnome.org/glib/stable/glib-Strings.html 
(I'd assume there's some variant of this in thelinuxkernel?  But not seeing it offhand)
As can be seen, these patches are slowly building the in-kernelRustcode
up so that real functionality can be implemented inRust, but this process
has some ground to cover yet.  It's not clear whether moreRustcode will
be proposed for 6.2, or whether this is the full set.  The pace of change
may seem slow to developers who would like to start doing real work inRust, but it does have the advantage of moving in steps that can be
understood — and reviewed — by the kernel community.  TheRust-for-Linuxwork has been underway for a few years already; getting up to full
functionality may well take a while longer yet.
rust-libgit2-sys 0.7.11-1ubuntu0.1 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 *rust-git2 0.8.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 *rust-bat 0.12.1-1ubuntu0.2 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 *rust-bat 0.12.1-1ubuntu0.2 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 *rust-git2 0.8.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 *rust-libgit2-sys 0.7.11-1ubuntu0.1 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 * openjdk-8 8u352-ga-1~20.04 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 * openjdk-lts 11.0.17+8-1ubuntu2~20.04 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 * openjdk-17 17.0.5+8-2ubuntu1~20.04 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 * openjdk-8 8u352-ga-1~20.04 -
 https://lists.ubuntu.com/archives/focal-changes/2022-Nove... 
 *linux
LinuxRCU) have different requirements,
    and are currently pushing propositions to evolve C/C++ that are
    going in directions that are not necessarily suited to OCaml’s needs
    on this issue.

  The risk is that OCaml programs end up in a no-man’s-land in terms of
  C standards due to the `volatile' fix working well enough (so far; as
  far as we know; etc.), and this even in the event where a purely
  standards-compliant solution was later adopted by OCaml (but where
  users would lack motivation to adapt their code).

  This issue has not received as much discussion as I had hoped; there
  was no feedback on the solutions. Unfortunately, this problem not
  being addressed for 5.0 means that OCaml developers might be
  envisioning breaking FFI changes later on, including changes that
  could cause API breakages in the multicore OCaml-Rust
culture of multiple distributions. 
 
And again, it's simply stupid to duplicate the work of vetting dependencies across multipleLinuxdistributions. There are valid reasons for having diversity ofLinuxdistributions but "have N different people each independently determine whetherRustlibrary X is non-harmful" isn't one of them.
Rustdevelopment process: when a new version ofRustis released with such new features (which do hopefully make code more readable), is theRustStandard Library simultaneously updated to use these new features? 

 No. It's similar toLinuxKernel process: first some foundational code lands, then things which
PackagingRustfor Fedora: another
  chapter in the ongoing saga over the impedance mismatch between theLinuxdistribution model and modern programming languages.
Linuxseriously spend a lot of their time just figuring out the best way to avoid having OS changes make invasive changes in on the software they use.  
 
When most of it can be replaced with something as simple as: 
 
    curl -o /usr/local/bin/libreoffice-7.4.2   https://libreoffice.org/download/libreoffice-7.4.2.bin  
    chmod +x /usr/local/bin/libreoffice-7.4.2 
 
 
...If we used static binaries. We can have a package manager that only needs to know how to check signatures and were to download the latest version of software.  It doesn't even need to know how to uninstall the old version since 'rm' is more then sufficient. Being able to juggle multiple versions and roll back changes become free.  etc etc.  Slackware's old tar.gz packaging format is peak software packaging technology so far.  
 
 
So while I am sure that there can be a huge amount of improvement in managing compile-time dependencies forRust
Linux(and I do NOT speak for my employer and this is not the information about our customers, just what I’ve heard) now have number of large clients who are quite nervous that they have tons of Docker (et al.) containers full of unmaintained stuff they have not complete control over. And yes, of course, whatever I said aboutRust
Rustwhich statically link everything are effectively a codification of the "I can't wait for your perfect solution anymore.  I'll  fix it." reaction that is containerizing everything using Docker.

 It's "We can't wait for Hurd. Let's put GNU userland on top of this thing calledLinux
Linuxkernel is more reliable than creations of these guys who praise Java for the easy mockability of everything. 

 Which means mockability doesn't translate into higher reliability. 

 If people do understand why they need to mock everything religiously (and that still doesn't help entirely) then it would be easy for them to see why they don't need that inRust
Linuxdistributions (and yes, I know why, too).Linuxdistros can not do anything if upstream is not supporting their creation and if upstream does support something… why would I need someone to make both their and mine life miserable? 

 > And it doesn’t matter if it isRust
Rustdevelopers feel so disinclined to help with supportingLinuxdistros. For the majority of them these are funny guys who produce some intermediate software which helps them to server real users (Android/iOS/macOS/Windows ones) yet try to demand way too much when they are not really all that important.  
 
If they
Linuxdistributions mentioned supports downloading files before the source tarball is generated. Using Debian as an example, the standard tool for building packages is sbuild. A source tarball is created after executing `debian/rules clean` on the build server with access to the Internet, and then it creates a chroot from that tarball for compiling it in an offline environment. The clean rule is invoked a second time within the chrooted build environment, and you can check for this with the `ischroot` command. 

 Pop!_OS has been creating Debian packages fromRust
Rustcommunity is very good about semver. (Not perfect, but very good.) I have a complex project with probably 200 transitive dependencies, and I hadn't touched it since last winter. When I went to update the dependencies, all but one of the supposedly semver-compatible dependencies upgraded without a hitch. (The exception changed how it formatted dates, breaking a specific third party service.) There were also about 6 dependencies with new major versions, corresponding to supposedly breaking changes. Maybe one of these actually required a few lines of changes to compile. 
 
One nice thing about theRustecosystem are tools like "cargo deny", which enforces license policy and checks for CVEs and unmaintained dependencies. I can add rules like "no copyleft licenses for this project" or "no indirect dependencies on OpenSSL", and be notified if these rules are broken. This helps maintain a larger list of dependencies with a bit less stress. 
 
Anyway, as an open source software author, I gave up on worrying about distro packaging years ago. ForLinux
Rust1.0 code from 2015 using modern compilers, just by running "cargo build". When I  can't  compile it, 90% of the trouble is typically caused by a C dependency, OpenSSL. OpenSSL breaks source and binary compatibility relatively often, and it's had plenty of urgent security updates. So when I rebuild old code, I often need to update the networking libraries to something modern.

 It's actually difficult to maintain 100% source compatibility over most of a decade. If you download sufficiently old C and C++ sources, they often require a bunch of tweaking to build.

 But overall,Rusthas done a fantastic job of maintaining source compatibility over time. Thanks to the "editions" system, it's possible to mix libraries usingRust2015 with libraries usingRust2021.

 My general strategy for deployingRustbinaries onLinux
Linux. 

 Sure, you can deal with it. You can ask your friends to help installLinuxon your TI Nspire CX II CAS… but, frankly, that phrase even sounds silly. 

 If you are hermit and actively try to avoid everything not available onLinuxit may work… till you would try to find a job and would get instructions in mail which would include link to Windows-only special “safe” browser… Windows-only, of course. 

 This all comes down to the fact that  for decades  it was possible to develop and deliver app for Windows and macOS, but before flatpack and snap it wasn't possible to do forLinux. 

 Today… it's possible, sure, but… development process for these apps is entirely separated from development of apps and libraries for thelinuxdistros, why would you need to bother about that one at all? 

 It would be as silly as if Android guys would have demanded thatRust
Rustis probably better in some ways, but code is not going to beat someone compiling it on your arch on your distro and hopefully doing a smoke test and you downloading that for ease of use. 

 Looking on calendar. Is it 2022 or 2002? That issue is solved in the entirely different way today.Linux
Linuxdistros) have quite thoroughly lost to uncurated one (AppStores for Android, iOS or even Windows): all the “good things” are not in curatedLinuxdistros, they are elsewhere.  
 
Uncurated ones? Once upon a time, all programs were installed on Windows or MacOS by going to their website and downloading them or buying a physical copy. Now iPhones and some versions of Windows only install from the vetted app store, and Android can get pretty pushy about it. Yes, there's a lot less control over what goes into those AppStores than what goes into aLinuxdistro, but there's a lot more control by Microsoft and co. than there was previously. So not obvious at all. 
 
Also note that the appstores carry binary apps that carry all of the non-system libraries with them. Flatpak is one thing, but a pile of source code that downloads a bunch of other source code and may or may not compile is quite another. Downloaded C code, in my experience, loves to fail in the middle of compilation with some obscure error from the compiler that the random user has no idea how to fix.Rust
Archlinuxhas a simple sensible approach torustpackaging. 
 
 https://wiki.archlinux.org/title/Rust_package_guidelines
Linux-only app there are dozen of Windows-only or iOS-only apps. 

 >  - and the world is running almost entirely onLinuxservers,Linux-based cloud ... 

 Which run docker images and Kubernetes pods. 

 Google may solve the distributions problem by just offering specialized version of Android suitable for use on servers with full support for these. 

 It's not, really interested, because when you containerise everything distros are not a big problem — but they are not a big help, either. 

 > There are a few projects which seem to have tied themselves to one particularLinuxdistro (or worse, a particular version) - the one that strikes me is gnuradio and that causes them problems. 

 Very similar problems to what the projects which don't support Windows and macOS (in that order) experience. 

 >Rust
Linuxdistros - Debian has only been here for 29 years. 
 
All the good things are not necessarily in IOS/Windows - and the world is running almost entirely onLinuxservers,Linux-based cloud ... 
 
There are a few projects which seem to have tied themselves to one particularLinuxdistro (or worse, a particular version) - the one 
that strikes me is gnuradio and that causes them problems.Rust
Linuxclient is much less important they are much less popular. 

 > Distros have a very hard work trying to match users' expectations with some developers' whims and extravagant "maintenance" process, particularly when users want those developers' projects. 

 Why is it a problem for users ofLinuxdistros, but not a problem for everyone else? Android, iOS, macOS, Windows… all OSes break apps for time to time, but in these OSes breakage is  rare exception . InLinuxworld it's the norm (except when flatpack or snap is used). Why is that? Why should developers ofRust
Rusthelp you there. 

 Heck, the first community which went the cargo way,  CTAN  predatesLinuxdistros!  CPAN  quickly followed and Perl community never felt the need to do whatLinuxdistro guys demand, either. 

 If anything it'sLinuxdistros who try to bend the whole world to their
Linuxdistributions wouldn't replace Windows any time soon: it's hard to image binary package  whose support ended seven years ago  to be that popular inLinuxworld… but in a world outside of IT 5 or 10 years is not a large time at all. 

 And that, it turn, explains whyRust
Linuxis so popular is that there are people making this effort of aggregating all such software to make it work seamlessly. This at least deserves a bit of effort from developers of whatever language to make their packaging systems less eccentric and more respectful of what distros really need to bring the software to end users. 
 
Here in my opinion theRust
Rustare doing it for things they expect to last much longer than 4-6 years.  I don't think your concern has merit.  
 
It doesn't make sense to lumpRustin with higher level (non-systems) functional languages - "application languages" (usually GC'd) indeed have some churn.Rustis going into the core of operating systems (all of Windows,Linux
Kofler, instead,decriedthe ease
with whichRustallows the addition of dependencies, calling the result
"dependency hell".  Rather than Fedora adapting toRust, he said,Rustis going to have to adapt to
become more relevant toLinuxdistributions.  Gompawas
not optimisticabout that happening, though, saying that his efforts in
that direction had met significant resistance in the past.
Rust, we're talking about C and most specifically about theLinuxkernel. Whether the people implementing a driver for a bluetooth device are "actual humans" is I guess up for question, but they're focused very tightly on low level technical details where the fact that the Han writing
Rust1.63.0

      □ SDL 2.24.0

      □ Xorg server 21.1.4 (overhaul)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Projects

Projects that span multiple categories, from the kernel and userspace to the
Ports Collection or external projects.

OpenStack on FreeBSD

Links:
OpenStack URL:  https://www.openstack.org/ 
OpenStack on FreeBSD URL:  https://github.com/openstack-on-freebsd 

Contact: Chih-Hsin Chang <starbops@hey.com>
Contact: Li-Wen Hsu <lwhsu@FreeBSD.org>

OpenStack is an open-source cloud operating system for different types of
resources like virtual and bare-metal machines. Users can spawn FreeBSD
instances on the open cloud platform, but it is not currently possible to run
OpenStack control plane on FreeBSD hosts. The goal of this project is to port
key OpenStack components so that FreeBSD can function as an OpenStack host.

Academic and industrial research groups have been evaluating CHERI-enabled
Morello boards since mid-2022. A resource orchestration platform like OpenStack
can improve the speed and cost of provisioning, managing, and recycling those
boards.

Starting in January 2022, Chih-Hsin Chang has been working to port several
OpenStack components to run on FreeBSD, including:

  • Keystone (identity service)

  • Glance (image service)

  • Placement (resource tracking and inventory service)

  • Neutron (networking service)

  • Nova (compute service)

Some of the items are still under heavy development
Rustbecause they will probably evolve much more rapidly.
 

 

 
My understanding is that *L4 is very minimal (threading, intercommunication process, interrupt handling....); this means that all the other things have to be implemented ; and these will not be "bug free". 
The weight (in term of LOC) of a microkernel is very low comparing to the rest.

For example, in thelinux
Rustbinary users should upgrade to the latest version:

  # emerge --sync
  # emerge --ask --oneshot --verbose ">=dev-lang/rust-bin-1.64.0"

In addition, users using Portage 3.0.38 or later should ensure that
packages withRustbinaries have no vulnerable code statically linked
into their binaries by rebuilding the @rust-rebuild set:

  # emerge --ask --oneshot --verbose @rust-rebuild

References
==========

[ 1 ] CVE-2021-28875
       https://nvd.nist.gov/vuln/detail/CVE-2021-28875 
[ 2 ] CVE-2021-28876
       https://nvd.nist.gov/vuln/detail/CVE-2021-28876 
[ 3 ] CVE-2021-28877
       https://nvd.nist.gov/vuln/detail/CVE-2021-28877 
[ 4 ] CVE-2021-28878
       https://nvd.nist.gov/vuln/detail/CVE-2021-28878 
[ 5 ] CVE-2021-28879
       https://nvd.nist.gov/vuln/detail/CVE-2021-28879 
[ 6 ] CVE-2021-29922
       https://nvd.nist.gov/vuln/detail/CVE-2021-29922 
[ 7 ] CVE-2021-31162
       https://nvd.nist.gov/vuln/detail/CVE-2021-31162 
[ 8 ] CVE-2021-36317
       https://nvd.nist.gov/vuln/detail/CVE-2021-36317 
[ 9 ] CVE-2021-36318
       https://nvd.nist.gov/vuln/detail/CVE-2021-36318 
[ 10 ] CVE-2021-42574
       https://nvd.nist.gov/vuln/detail/CVE-2021-42574 
[ 11 ] CVE-2021-42694
       https://nvd.nist.gov/vuln/detail/CVE-2021-42694 
[ 12 ] CVE-2022-21658
       https://nvd.nist.gov/vuln/detail/CVE-2022-21658 
[ 13 ] CVE-2022-36113
       https://nvd.nist.gov/vuln/detail/CVE-2022-36113 
[ 14 ] CVE-2022-36114
       https://nvd.nist.gov/vuln/detail/CVE-2022-36114 

Availability
============

This GLSA and any updates to it are available for viewing at
the Gentoo Security Website:

  https://security.gentoo.org/glsa/202210-09 

Concerns?
=========

Security is a primary focus of GentooLinux
Rustnot because of C deficiency but because kernel developers actively don't want to have it. And if they don't want want to have it then it wouldn't exist. 

 How canRustlanguage properties may affect that? 

 > I expect something like that from this imaginary framework. Driver code is the same for different kernels, framework knows all of kernels, actual binary representation changes wildly accordingly for kernel whims. 

 And what would happen when that magic would, finally, be stretched too far and fail?  That  is what Linus fights against:  
 Because I  know  that I will eventually make changes that break modules. And I want people to expect them, and I never EVER want to see an email in my mailbox that says "Damn you, Linus, I used this binary module for over two years, and it worked perfectly across 150 kernel releases, andLinux
Rustcalls such magic a "langitem" as in "language item". If you made your own my::Drop trait with a drop(&mut self) function anybody can implement that on their types if they want, and anybody can call that drop() method on values of those types, yet it won't de-allocate anything, won't happen automatically, it just has a misleading name, like the artwork "An Oak Tree". But the langitem deliberately cannot be called by people explicitly (that's a compile error), and it will get called automatically by the language when items of that type are about to be destroyed. 
 
So logically this code happens because the kernel is destroying this value, ifLinux
Rustis merged into the kernel  now  is specifically because something like that is just not possible.  Kernel is very explicit and vocal about that : all kernel APIs are unstable and there are no stability guarantees. 

 > If I need to put few bits into GPIO and create few entries for /sys, why should I dive deep into kernel build details? 

 If your needs are so modest then why do you even need kernel driver in the first place?Linux
Rustsupport will be disabled silently. 
This behaves the same as when using a config file that has compiler-dependent support enabled which is not supported by your compiler (e.g. UBSAN_TRAP, see `git grep "\$(" -- "*Kconf*"' for more). 
 
I guess that's fair enough for an experimental feature that is not yet supported on all architectures? 
 
Note that personally, I never run "make oldconfig", but always use my "linux
RustforLinuxcould advise builders to use the stableRustcompiler, but just tell it to pretend it isn't a stableRustcompiler (one environment variable change), so as to take advantage of any QA benefits as presumably your distribution's stableRust1.62 compiler was actually tested
RustforLinuxneeds some unstable features.RustforLinuxtracks what is needed, since it is their long term goal that this will become unnecessary:  https://github.com/Rust-for-Linux/linux/issues/2  
 
Note that - while this is not a supported configuration - the stableRustcompiler is technically quite capable of compiling code using
Building theRustsupport requires specific versions of theRustcompiler
and bindgen utility — specifically,Rust1.62.0 and bindgen 0.56.0.  If the
target system has newer versions, the configuration process will emit
warnings but will proceed anyway.  More awkwardly for anybody who is trying
to do the 
build with theRusttoolchain provided by their distributor, the build
process also needs theRuststandard library source so that it can build
its own version of thecoreandalloccrates.  Until
distributors start shipping "Rustfor the kernel" packages, getting that code
into a place where the build process will find it will be a bit awkward.
Somewhat related news: The developer of rustc_codegen_gcc recently announced that it can now buildRustforLinux:  https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report...
The first step toward those goals was to create a parser for the language, then to start
implementingRust's data structures.  Then came traits and generics; those
features are complex, he said, but they are also at the core of how the language
works.  Control flow, and especially thematchexpression 
came next; after that was macro expansion.
Const generics are in progress now, he said, while work on intrinsics and
built-ins is just beginning.  No work has been done on borrow checking; it
is not needed to generate validRustcode, so it can come later.  Work on
running theRusttest suite is also being done.
Experimental support for theRustprogramming language has beenpulledinto
     the mainline.  Following thedecisions
     madeat the recently concluded
     kernel maintainers summit, this is a
     minimal version of the patch set, without 
     the drivers that have been implemented inRustso far.This documentation
     commitcontains more information, andsome small sample
     modulesare available as well.
Doing great things is part of the kernel community's job description,
though.  The 6.1 development cycle is about to start as of this writing;
there are currently just over 10,000 non-merge commits waiting inlinux-next.  That suggests that 6.1 may not be the busiest development
cycle ever, but that kernel, which will be a long-term-support release,
will still contain a lot of interesting work, including the expected
merging of theRust-for-Linuxandmulti-generational LRUpatch sets.
That release can be expected in 
mid-December; LWN will, of course, stay on top of what's happening
throughout that development cycle.
efforts therustpeople are going to forlinux, and also given Linus' very pragmatic not purist attitude, stuff thatlinuxwants is not likely to suffer too much bikeshedding. Even if it does (quite likely) end up as "this only exists in unsafe code".) 
 
Cheers, 
Wol
rustnot building (build
hangs in OBS, so armv6 build ofrusthas been disabled). See
 https://github.com/rust-lang/rust/issues/60605 . Fabian is testing a
possible fix.

Leap:
    * No update

ALP:
    * SUSE:ALP: SR to build new image recipes for aarch64 is pending:
 https://build.opensuse.org/request/show/1006100  (hopefully merged this
week)


## Sarah - s390

Open Source Day was successfully. We had an assigned Mentor with
experience with Kernel contributions. All SRs for packages during this
Hackathon were accepted.
KDE re-enabled for s390x and multiple Python packages

I had an additional video interview at the Open Mainframe Summit about
the reasons for ourLinux
For better or worse, C is thelingua francain the world of kernel
engineering. The core logic of theLinuxkernel is written entirely in
C (with a bit of assembly), as are its drivers and modules. While C is
rightfully celebrated for
its powerful yet simple semantics, it is an older language that lacks
many of the features present in modern languages such asRust. TheBPFsubsystem, on the other hand,
provides a programming environment that allows engineers to write
programs that can run safely in kernel space. At the2022LinuxPlumbers 
Conferencein Dublin, Ireland, Alexei Starovoitov presented an overview
of how BPF has evolved over the years to provide a new model for kernel
programming.
Linuxto be written inRustsince inRusttypes with zero size are a completely unremarkable idea we use all the time :D 
 
But yes, I think Clang relenting makes the most sense. Zero Size Types are good. Standard C and C++ can't have them without ripping
Linuxwith root access? 
 
Sure, I can run aLinuxVM for a lot of my tasks, but then I'd need gobs more RAM and overall oomph to overcome the "security suite" that made that SSD-equiped laptop respond worse than one with spinningrust?  And no, I can't use "cloud
The next steps forRustin the kernel:
     the ability to write kernel modules in theRustlanguage may be coming
     sooner that some people expect.
How? By the timeRustwill be used for anything other than toy drivers,Rust-GCC should be done, soLinuxwithRustwill compile anywhere thatLinuxwithoutRustcan.
Linuxis written for. 
 
Sometimes the abstract machine's differences from a real machine just have performance consequences, for example most doubly linked list operations look really clever in the abstract machine and have reasonable performance, but this has lousy performance on an actual computer you can buy today because of caches. 
 
But often there are simply practical differences, the abstract model lacks entirely something the real machine has. A higher level C++ application needn't care but theLinuxkernel does. For some thingLinuxrelies on inline assembler, the same thing works inRust
Rustlanguage itself both in an older Placement-by-Return RFC and this blog post update from 2 days ago: 
 
https://y86-dev.github.io/blog/return-value-optimization/placement-by-return.html 
 
For what it's worth as aRustuser, theseRustforLinuxissues seem to be becoming a very helpful forcing function to improveRust
The traditional mechanism for launching a program in a new process on Unix
systems—forking and execing—has been with us for decades, but it is not
really the most efficient of operations.  Various alternatives have been
tried along the way but have not supplanted the traditional approach.  A new
mechanism created by Josh Triplett adds process creation
to theio_uring asynchronous I/O APIand
shows great promise; he came to the2022LinuxPlumbers Conference(LPC) to introduce io_uring_spawn.
rust-ripgrep 13.0.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-rustfilt 0.2.1-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sequoia-keyring-linter 0.5.0-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sequoia-sop 0.26.1-2ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sequoia-sq 0.25.0-3ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sniffglue 0.14.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-ucd-generate 0.2.3-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-bat 0.19.0-1ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-bindgen 0.59.1-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-dfrs 0.0.7-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-debcargo 2.5.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-fd-find 8.3.1-1ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-hyperfine 1.12.0-3ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-markdown 0.3.0-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-lalrpop 0.17.2-8ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-pleaser 0.5.1-4ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-rustfilt 0.2.1-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sequoia-keyring-linter 0.5.0-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-ripgrep 13.0.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sequoia-sop 0.26.1-2ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sniffglue 0.14.0-2ubuntu0.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-sequoia-sq 0.25.0-3ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *rust-ucd-generate 0.2.3-1ubuntu0.22.04.1 -
 https://lists.ubuntu.com/archives/jammy-changes/2022-Sept... 
 *linux
The next steps forRustin the kernel:
     the ability to write kernel modules in theRustlanguage may be coming
     sooner that some people expect.
Greg Kroah-Hartman asked how subsystem-specificRustbindings will go
upstream; will they go through theRusttree or via the relevant subsystem
maintainers?  Ojeda answered that coreRustsupport will go through theRusttree, but the rest should go through maintainers.  Alexei Starovoitov
worried that subsystem maintainers would not be able to refuseRustpatches
even if they do not want to seeRustused in their subsystems; James
Bottomley added thatRustcan be a hard language for longtime C developers
to understand, and that it would not be good to force it on maintainers.
Torvalds answered that it should be up to the maintainers; there is no need
for global rules at this point.
Linuxtypes. My proposal is to (a) convert C code from using s64 to i64 so that people who are familiar withRustwill have a smoother transition. (b) use explicitly sized types instead of 'int', 'long', etc. I find it a good way to remind
rustdoes. Sometimes people want to have more performance by doing crazy optimizations themselves. This is what unsaferustis.   
 
The problem is that there is no in-between. There's no reason that there cannot be a mode "semisafe" halfway between safe and unsafe where these things have unspecified, platform-dependent, unknowable, possibly nondeterministic behaviour, but they still are always guaranteed to, at the very least, have behaviour of some sort. Compiler developers claim that this would result in huge numbers of lost optimisation opportunities, but I'm not sure I entirely believe them. As far as I know, theLinux
Rusthas had a number of RFCs and other discussions about this, of varying levels of quality, over many years: 
 
 https://github.com/rust-lang/rfcs/pull/809  
 
 https://web.archive.org/web/20201109030838/https://github...  
 
 https://internals.rust-lang.org/t/pre-rfc-move-references...  
 
 https://github.com/rust-lang/rfcs/pull/2884  
 
 https://github.com/rust-lang/rust/issues/27779#issuecomme...  
 
But I haven't seen a design that's truly satisfying. 
 
One problem is that the most obvious design would be to take the idea of "out pointers" from C and add them toRustin a compiler-enforced way, but this is impossible.  Why not?  BecauseRustcode is allowed to unwind on panic, in which case you'd return to an outer stack frame without actually initializing the pointer.Rustdoes support a no-unwinding mode, which is used byRustforLinux
Rustin general. I'm just explaining why people would balk at the idea of needing to use procedural macros for something so basic - needing to extend the language to deal with this means people will expect that it will need to be extended for lots more things in the future, yknow? Then you aren't really usingRust, you're usingRust++, so why useRustin the first place? 
 
 > Also in C. Look at what the kernel does with C macros. That's a completely separate language.  
 
What the kernel does with C macros is certainly not a "completely separate language" - in fact, what the kernel does with macros is done in such a way as to make their use mostly invisible. The vast majority of the time you do not need to know, when you write foo(x), whether foo is a macro or a function. That is why theLinux
Nobody should need more memory than a 64-bit pointer can address — or so
developers tend to think.  The range covered by a pointer of that size
seems to be nearly infinite.  During the Kernel Summit track at the2022LinuxPlumbers Conference, Matthew
Wilcox took the stage to make the point that 64 bits may turn out to
be too few — and sooner than we think.  It is not too early to start
planning for 128-bitLinuxsystems, which he termed "ZettaLinux", and we
don't want to find ourselves wishing we'd started sooner.
RustforLinux, as far as I am aware, requires a freestanding (no-std) environment.   
 
But not for building. 
The part of the article and my question was about building. 
 
 >Would you need to write code that uses these procedural macros in every structure that includes a list head
RustforLinux, as far as I am aware, requires a freestanding (no-std) environment. Looking at the pin-init crate, it requires 'syn' as a runtime dependency (not just a compile-time ("dev") dependency)[0]. 
 
[0]:  https://github.com/nbdd0121/pin-init/blob/trunk/pin-init-...  
 
 > What's wrong with
Rustdesigners, but I doubtLinuxdriver writers would agree. Remember: we are talking about guys who often raise a fuss when compiler adds couple of spurious commands. 

 On the other hand these are the same guys who already know how to make C compiler generate code they want andRust
Rustdoesn't have the luxury of being able to tell people just not to do things.  
 
Rather,Rusthas the luxury of telling people they *can't* do things. Which is critical to and in some cases necessary forRustbeing able to provide its safety guarantees. Complex, memory-aware data structures (e.g. cyclical, self-referential, etc) have *always* been a sore point forRust. MostRustdevelopers come from the world of scripting languages or similar environments (e.g. Java) where hash tables are the primary, even sometimes exclusive primitive (beyond arrays) for building higher-order data structures, so they don't feel any loss. For this group, more complex data structures always come by way of magic libraries with generic interfaces that you glue together; building thin, bespoke data structures for your specific functional problems as a matter of course is a foreign concept. 
 
Many solutionsLinux
Rust's correct way to potentially unsafely initialize stuff these days is to use core::mem::MaybeUninit<T> 
 
MaybeUninit is a union (and thus can't be accessed by safe code directly) of uninitialized nothingness, with your type T. The compiler can see this may be uninitialized, and therefore no stunts which assume it's a T are allowed, and yet it might be a T and so we can (unsafely) write to elements of T. 
 
While we're initializing it, the MaybeUninit<T> type is clearly not a T as far as other code is concerned, there's no risk anybody mistakenly thinks this is a T and tries to use it as one. Once we're done we can unsafely assume_init() to get a T, and if we're right this is fine, if we lied everything might catch fire but that's a programming error. If T is some structure that only some people want to perform gradual initialization on, MaybeUninit also has a write() method where we can safely just give it a T, and say look, I don't want
lots of bare metal code have already been developed inRust.  
 
Well, I was referring toLinuxKernel, I usedrustfor embedded microcontrollers, but forLinuxKernel it looks(from outside) that is too much to fight. 
 
Anyways, it's good to see safety landing on the kernel.
Rust.RustinLinuxis merely fighting with the existing C interfaces and C concepts. These have never been developed withRustin mind and they cannot be changed just to supportRust. 
 
I also don't think that these problems make it unsuitable. It just means that we have
Rust, such as the original motivating example of Firefox, librsvg, curl, and this work in theLinuxkernel, than I have in Ada. 

 The biggest problem of Ada IMO is that it was always supposed to be about safety, but it never addressed the most common source of bugs: pointer
Rustexpert).  
 
Fair enough! I'm not an Ada expert either, so I can't necessarily speak to how the approaches compare. 
 
I can say that I've seen a lot more work in the free software world to incrementally port portions of software toRust, such as the original motivating example of Firefox, librsvg, curl, and this work in theLinux
Rustreference, there's an extensive test suite, there's the entirety of crates.io which is used as an additional test suite, and there's a draft Ferrocene Language Specification  https://spec.ferrocene.dev/  which is intended to provide a set of requirements that can be verified against for safety-critical applications. 
 
 >Rustdoes need to adopt a similar approach where there is no more *the* leading implementation and a few others trying to catch up like clang does with gcc or gnugo does with Go  
 
I'm not sure I follow; as you're saying here, the situation forRustis no different than the situation with C in theLinux
CompilingRustwith GCC: an update:
  a progress report on two GCC-based alternatives forRustcompilation.
Rust, and the kernel is far more complicated than that. The one serious attempt to do so failed after months of work because it required writing thousands upon thousands of lines of memory management boilerplate.
 
In fact, the developer of wayland-rs rebutted this  two years ago , and both wayland-rs and smithay (an alternative to wlroots -- not wayland -- inrust) are actively maintained today. Not in wide use (gnome/libweston dominates, kde and wlroots are a distant second/third, not much space for others). But it's there. Perhaps you are thinking of weston-rs. 
 Many of your other comments -- such as they are, omitting the "yeah right", "anyone notice that..." etc -- have been amply rebutted by others above. 
 As far as the kernel is concerned, if there was a huge issue withLinux
Rust: as long as it remains the self-defined input of rustc, it's not exactly a language and it can seriously fail over time. Serious implementations are absolutely required for it to survive. For sureLinuxuses GCC C. But C is used everywhere and runs the whole
Rustand C? Obviously the fault of C.  
 
The fundamental unique feature ofRustis that it enables you to build safe abstractions around unsafe code (we'll get to what "safe" means in a bit). Whether you are interfacing with C, or defining your own primitives inRust, doing that can be tricky, but once it's done, you have fairly strong guarantees on what can happen in the safe code that uses those abstractions. 
 
So, this isn't "blaming bugs on C", but just an acknowledgement thatRustis not a silver bullet (and has never been intended as such), and that the fundamental work of building safe abstractions over unsafe code still requires care. Since there are a large number of abstractions that already exist in theLinux
Rustprevents' (if you don't use `unsafe`, which theRustforlinuxcode does all over the place)? When people involved inRust's development realised just before the release of the language that the language was fundamentally unsound, allowing memory leaks, they quietly redefined 'safety' to exclude leak
Rusthad been achieved; has there been, for example, any fuzz testing of the server? Almeida answered that theRust-based parsing interface makes a lot of mistakes impossible. No fuzz testing has been done — the server has only been working for a couple of weeks — but he will do it. He concluded that he will be interested to see how his server fares in such testing relative to the QEMU implementation.   
 
In other words "no we haven't actually tested it but I'm sure the language prevents bugs, they're totally impossible". Yeah right. This is typical of theRustcommunity: huge promises, no evidence to back them up, all topped off with an "if it compiles it is correct" attitude that totally disregards that there are many more issues other than those theRustpeople have decided count as 'safety'.  
 
Anyone noticed that 'unsafe' as a general concept has suddenly been redefined to mean 'whateverRustprevents' (if you don't use `unsafe`, which theRustforlinux
Rust's tier support list says armv4t-none-eabi has tier 3. That platform is described as ARMv4 with Thumb and exists particularly to make the Nintendo Gameboy Advance work. 
 
Tier 3 meansRust's CI checks this compiles, but they don't check it works, and it is only supplied with the core library. 
 
Obviously the kernel is comfortable in that world, you can't just TcpStream::connect() from inside the kernel either, although it won't fit on a GBA as I understand it, presumably if you've got a big enough ARMv4 system to runLinux
Rust's networking related data structures are literally identical to the C structures, and so I can just pointLinuxC code doing low-level networking at theRuststructures and it'll work" and one day that stopped working. That was never guaranteed to work, nobody
Rustonly cares about s390x ("modern" 64-bit IBM) whereas I believe theLinuxkernel technically builds on (32-bit) s390  despite there presumably not being many (any?) actual 20th century System/390 machines running it in practical use ? 
 
If it ever came down to "Should we support
RustSIMD intrinsics have been implemented.   
 
So it appears them are compiling the SIMD themselves, and bypassing LLVM and GCC's SIMD support, both of which were pretty good except for that no languages could really use them (I gave a talk about this at the 2019 LLVM conference, and wrote a patch series for Zig that only about half of it ever got merged, but I would still recommend Zig over C for this, as C's extensions have some problems that cannot be fixed except by starting over from C11.) 
 
 > many developers are concerned by the fact that there is only one compiler available;   
 
I don't think 10 independent C++ compilers would be enough to convince Linus to allow C++ inLinux
Rustadoption in the Kernel and another two years until the stale distros actually pick up those kernels, I think most of these will be long gone from theLinuxtree by the time this is relevant. Or have LLVM backends. Cadence and Synopsys certainly don't lack the resources
There is in fact a port ofrustto m68k, but only onlinux.
which is mostly kept alive for recreational purposes, is already supported upstream. All of these are going to be primitive enough that I don't think the lack ofrustsupport will be relevant for a long long while. Unless it becomes impossible to compileLinuxwithoutrustat all.
Cohen talked about building theRustforLinuxproject(the
integration ofRustwith 
theLinuxkernel) specifically.  That project is currently targetingRust1.62, which is rather more recent than the 1.49 that gccrs is aiming at;
there is thus a fair amount of ground yet to cover even once gccrs hits
its target.  There are not many differences in the language itself, he
said, but there are more in the libraries.  Even with the official
compiler,RustforLinuxhas to set theRUST_BOOTSTRAPvariable to
gain access to unstable features; gccrs is trying to implement the ones
that are needed for the kernel.Generic
associated typesare also needed.
Eventually, the goal is for gccrs to be able to compileRustforLinux.
rustone will be significantly less efficient on medium sized headers (user-agent, cookie, referer etc)  
 
This might be more compelling with experimental results but I'd be astonished if it made a discernible difference actually. Without such results I don't see any reason I shouldn't argue the exact opposite, that your solution is needlessly complicated and dangerous. 
 
BurntSushi did this work because of ripgrep which is processing rather more data than a HTTP User-agent header. I can well believe it's worth doing all that for running grep over an entire monorepo or a few weeks log files or whatever but I have my doubts for Mozilla/5.0 (X11;Linux
Rustpeople, and might not even be immediately obvious to newRustprogrammers, but, in a sense allRust's functions are/ can be written as free functions. 
 
Here's some idiomaticRustusing a method call: 
 
    let mut news = "LinuxWeekly News".to_owned(); 
    news.replace
Linux-
 https://www.infoworld.com/article/3669900/microsoft-net-6... 
 * Canonical and Microsoft Add .NET 6 Support to UbuntuLinux-
 https://redmondmag.com/articles/2022/08/17/net-6-support-... 
 * .NET 6 is now available in Ubuntu 22.04 and Easy Ubuntu Containers,
under a new partnership between Microsoft and Canonical -
 https://oicanadian.com/net-6-is-now-available-in-ubuntu-2... 

== Canonical News ==

 * Canonical enables Ubuntu on StarFive’s VisionFive RISC-V boards -
 https://ubuntu.com//blog/canonical-enables-ubuntu-on-star... 
    * Official Ubuntu RISC-V Images Released For StarFive's VisionFive
Board -  https://www.phoronix.com/news/Ubuntu-22.04.1-VisionFive-R... 
    * Ubuntu Is Now Officially Supported on StarFive's VisionFive
RISC-V Single-Board Computers -
 https://9to5linux.com/ubuntu-is-now-officially-supported-... 
    * Now you can run Ubuntu on a VisionFive single-board PC with a
RISC-V processor -
 https://liliputing.com/now-you-can-run-ubuntu-on-a-vision... 
 * Charmed Kubeflow 1.6 Beta is out: try it today! -
 https://ubuntu.com//blog/kubeflow-beta-release-mlops 
 * Top 5 IoT challenges and how to solve them -
 https://ubuntu.com//blog/top-5-iot-challenges 

== In the Press ==

=== What’s new with Ubuntu 22.04.1? ===

Jack Wallen reminds us Ubuntu 22.04.1 LTS has been released, which
includes the capability of Ubuntu 20.04 LTS to upgrade to Ubuntu 22.04
LTS. We are told upgrades don't require commands, Ubuntu 22.04 LTS
uses GNOME 42, the latest toolchains (Python,Rust
Linuxdistributions are "GNU/Linux" and use glibc.  
 
If you look beyond "interactive" users and at the number of instances ofLinuxkernels running, I suspectLinux"distributions" are still niche. Still waiting for the "Year of theLinuxDesktop" and breakages like this one don't exactly help. 
 
 >Rust
Rust, of course, uses glibc. 

 Go avoids it, but not because it thinks it's particularly bad, but because it avoids  all  dynamic libraries by default, as mentioned above it does the same on macOS. 

 Android, sure,  that  thing tries to purge all GPL/LGPL-related parts from userspace (although not very successfully so far), again, not a technical issue. 

 I just find it funny that you say  software running onLinux
Linux`perf'
  ([thread]), and supporting Yuxiang Wen ('hackwaly')'s work on
  [ocamlearlybird] ([thread]), an OCaml bytecode debugger for vscode.

  We also funded the early development work of [mutaml], a
  mutation-testing prototype by Jan Midtgaard.


[thread]
< https://discuss.ocaml.org/t/ann-perf-demangling-of-ocaml-... >

[ocamlearlybird] < https://github.com/hackwaly/ocamlearlybird >

[thread]
< https://discuss.ocaml.org/t/ann-ocamlearlybird-1-0-0-beta... >

[mutaml] < https://github.com/jmid/mutaml >


Communication
┄┄┄┄┄┄┄┄┄┄┄┄┄

  We decided to fund the time that Alan Schmitt ('brab') spends on the
  [Caml Weekly News] – Alan also started cross-posting them on [reddit]
  on this occasion.

  We funded John Whitington to work on OCaml documentation, on the core
  manual (see in particular [this PR]) or newcomer-oriented content on
  ocaml.org ([Get Up and Running with OCaml] and [A First Hour With
  OCaml]). We also purchased rights to John Whitington's book [OCaml
  from the Very Beginning] to put it [online] ([thread]). This is a good
  introduction to OCaml for people with little to no programming
  experience, and we hope that it will be easier to onboard people if
  they can get a free version online – of course they are encouraged to
  buy a paper copy if they like it and can afford
Living with theRusttrademark: a
  couple of projects discuss whether they are allowed to use the name
  "Rust".
Linux's namespaces are the key feature that allow the creation of
containers.Linuxsupports namespaces for multiple different aspects of
the system, including user namespaces for separate views of user and group
IDs, PID namespaces for distinct sets of process IDs, network namespaces
for distinct sets of network interfaces, and several others.  When a
container is started, a runtime creates the appropriate control groups,
namespaces, and filesystem mounts for the container; then it launches a
process inside the environment it has created.
Linuxside, if universities would have demanded 
for Unixes to remove soft link TOCTTOU races at file system level before 1992. 
 
Something like this might happen in next 10 years: 
 
Security scanners 
- open(), chmod() chcon() stat() etc. TOCTTOU hazard libc functions will be marked as insecure at source code level. 
- All applications that use those functions, will need to be altered (just like Samba multi year project to fix one CVE), 
  to avoid unsafe calls, otherwise those projects will become obsolete. 
- All commands, that have in source code such calls (like "setfacl -R" command which was mentioned in the Samba video ) 
  are marked as vulnerable because of the possibility of existing TOCTTOU races. 
- Security aware application container deployments must use latest OS, because older OS versions don't get the (massive multi year) fixes. 
- Container (non-root-path) mounts that use data disks that follow soft links by default will be marked as insecure. 
 
Other attack mitigations 
- Of course, SELinux might come into containers too as mandatory, when OS is present at file system level. 
- Single binary containers take more ground (Examples:Rust
Referenced kptrs also provide strong safety and correctness guarantees
to developers. 
It is a ubiquitous paradigm in managed-object frameworks that a reference
should only be owned by a single context, and the semantics of kptr
reference handling bear a striking resemblance tostd::boxed::BoxinRust,
andstd::unique_ptrin C++ in that regard. InRust, a Box is a pointer to a heap allocation
that can only have a single reference at any given time, and which is
automatically freed when that reference goes out of scope. When theRustprogram is compiled, theRustcompiler will verify that only a single
reference can ever exist to the Box by applyingRust'sownership
model.
If theRustprogram compiles, you have a guarantee that the memory pointed
to by a Box is always valid and only has a single reference. In C++,
some verification takes place at compile time by, for example, prohibiting
anstd::unique_ptrfrom being copied, but problems can still arise at
run time. For example, a user could invokestd::unique_ptr::release()twice, and would receive anullptron the second invocation.
fewer problems (but there are a bunch of things that have to be resolved before this happens).  
 
Well, 14 years later Linus Torvalds hinted the use ofRustin theLinuxkernel by 2023, so it seems the bunch of things are going to be resolved soon ;-) 
 
 https://thenewstack.io/rust-in-the-linux-kernel-by-2023-l...
Bird began his journey withLinuxin 1993 and switched over to embeddedLinuxin 1998 at Lineo.  He moved to Sony in 2003, where he was hired
to help found the Consumer ElectronicsLinuxForum (CELF), which started
the "EmbeddedLinuxTechnical Conference" in 2005.  That is the direct
predecessor to ELC.  CELF moved under theLinuxFoundation umbrella in 2010
as the Core EmbeddedLinuxProject.
Version
1.62.0of theRustlanguage has been released.  Changes include a newcargo addcommand, default enum variants, an improvedLinuxmutex implementation, a number of stabilized APIs, and more.
In something of an Open Source Summit tradition, Linus Torvalds and Dirk
Hohndel sit down for a discussion on various topics related to open source
and, of course, theLinuxkernel.Open
Source Summit North America(OSSNA) 2022 in Austin, Texas was no
exception, as they reprised their keynote on the first day of the
conference. The headline-grabbing part of the chat was Torvalds's 
declaration thatRustforLinuxmight get merged as soon as the next merge 
window, which opens in just a few weeks, but there was plenty more of interest there.
Miguel Ojeda has postedan
update on theRust-for-Linuxproject.
Linux's "stable userspace ABI" and the mess of the userland ABI story above the absolute basics (glibc, X11, and a handful of others). 
 
Such reimpls have happened before (cf. libjpeg-turbo). I think the difference is that the ecosystem has a lot more room to move than the guarantees of the stdlib because of the "if it works today, it'll work tomorrow" mindset. And yes, your crate will continue to work because the old crates are still accessible but you might not have updates. 
 
TheRust
I think there's a growing problem inLinuxwhich is exemplified by
	thisRustdebate but which goes way beyond it: We're becoming too
	fearful of making big decisions to sustain innovation in some
	areas.  This really is a creeping cancer of inertia that has
	destroyed many projects before us and if we're not careful, we'll
	go the same way.
Linuxkernel have “no stable internal API” policy and whyRustkeeps it's standard library as small as possible. 

 As for “list of currently recommended crates”… this idea is discussed so often, that yes, I hope eventually something like that would be made. Maybe with the use of hyped
Rust, with some Windows and webassembly compatibility code. 

 Why do you think it should be part of stdlib or a generic terminal library? This crate (with crazy hacks like attempt to see if filename includes words “msys” and “pty”) is definitely not what I would want in the “standard library” yet it's perfectly justified if the only thing you want to do is to show color output on the console. 

 It's actually not that hard to support ANSI colors on most popular OSes (you just need to call  SetConsoleMode  on Windows and ignore the result: msys/cygwin would handle these in their own way and Windows console would work), but actual detection of whether you are dealing with TTY or not is complicated and unreliable. 

 Yes, our world is crazy. Deal with it. If crate is 210 lines long but have history of 17 versions and few dozens of commits I would assume it's complex enough to live in it's own crate. 

 > Stuff like this not just being part of the standard library is what has stopped me from usingRustso far. 

 Feel free to pretend thatLinux
Rust. Because existing generic distributions don't actually deliver a lot of whatRustdevelopers need,: 
 
• the ability to install several versions on the same system for disjunct projects (or installing anything other than The One Version Blessed By The Current Distro Release) 
• being available on systems for which no generic distribution mechanism exists (e.g. Windows, macOS) 
• having a lot of people that actually have domain-specific knowledge vet the packages, providing much more benefit 
 
The last point is something that I find is completely ludicrous in theLinux
Linuxkernel. Recently I discovered this was true even in Solaris, despite Solaris have a complicated kernel syscall facility for unbounded-length input and output syscall arguments. If you step away from trying to making everything configurable and unbounded, then it becomes much easier to limit complexity. Usually you can set an upper bound that is good enough and move on; and for many of the exceptions, you can switch to semantics that let you trade time for space (i.e. trade serial processing for discrete buffers). Or to put it another way, for the rare cases where setting fixed-bound arguments is too cumbersome, use netlink instead of ioctl. Problem solved. One doesn't need to become the other, or replaced with something fancier; just make the choice more clear. 
 
If you want to make it easier to prevent people from accidentally doing the wrong thing, and to identify places where that might be likely, you can add type annotations to structures and other types used by kernel ioctl interfaces, complemented with a GCC module pass that identifies code that directly access members. IOW, you can implement something akin toRust
being a quicksand of nasty surprises every time the compiler is upgraded. 
 
Otherwise we will soon end up (and quite possibly a lot quicker than people think possible) where the core of theLinuxkernel is written inRust, and the only C left will be legacy drivers. 
 
Cheers, 
Wol
Addingsupport for an in-kernel TLS
handshakewas the topic of a combined storage and filesystem session at the2022LinuxStorage,
Filesystem, Memory-management and BPF Summit(LSFMM).  Chuck Lever and
Hannes Reinecke led the discussion on ways to add that support; they are
interested in order to provide TLS for network storage and filesystems.
But there are likely other features, such asQUICsupport, that could use an in-kernel 
TLS implementation.
Ourintroduction toLinuxaudio and MIDI
plugin APIsended with a mention of
theClever Audio Plugin(CLAP) but did not get into the details.  CLAP is an MIT-licensed API for
developing audio and MIDI plugins that, its developers feel, has the
potential to improve the audio-software situation onLinux.  The time has
now come to get to those details and look at the state of CLAP and where it
is headed.
Rustdevelopers could do for a C++ maintainer in particular is knock off pain points where there isn't yet a nice way to do what they're used to inRust. 
 
For example,Rustdoesn't yet have explicit Trait specialisation. You can write "For any type T which is Copy and Default, here's an implementation of my Trait Foo" inRust, and we do, but you can't write "Also, for Foo<bool> here's a much faster specialised way to implement it".Rustwill complain that now there are two ways to implement Foo<bool> since bool is Copy and Default. Ideally we could tellRust, "Yes, but the bool specialisation is more specific, so that's fine", but today this requires an unstable feature because it's not necessarily Sound to do this. 
 
[I suspect this specifically is too hard forLinux
Linux. 

 I understand the temptation to create a specialized language for an OS development, this may even be right thing to do for the academic project, but as fate of  Oberon ,  Singularity  and many other OSes shows this means you OS would be a purely academic/hobbyist world experience. Simply because you wouldn't have a robust compiler for everything-and-anything (which GCC/LLVM provide and whichRust
> In a future release we're planning to increase the baseline requirements for theLinuxkernel to version 3.2, and for glibc to version 2.17. We'd love your feedback inrust#95026.  
 
Thought you all probably wanted to know that, too.
The development of theRustlanguage
Goldstein wondered when theRustrewrite would be coming.  Overstreet said
that there is already some user-spaceRustcode in the repository; as soon
asRustsupport lands in the kernel, he would like to make use of it.
There are "so many little quality-of-life improvements inRust", such as
proper iterators rather than "crazy for-loop macros".  Bacik said that
many were waiting for that support in the kernel; Overstreet suggested that those who are
waiting be a bit noisier to make it clear that there is demand for it.
With that, time expired on the session, but it seems we may see bcachefs andRustracing to see which can land in the kernel first.
there, and the root cause must be in either that unsafe code or the nearby safe code that is breaking its invariants.
 

This might be helpful when debugging a kernel written inRust, but given the amount of C inLinuxin the medium term, I doubt it will help much.
TheRustBlogwarns
developersof a malicious crate namedrustdecimal, which was
evidently targeted at GitLab users who mistyperust_decimal.
LinuxAppStream (v. 8) - aarch64, noarch, ppc64le, s390x, x86_64

3. Description:RustToolset provides theRustprogramming language compiler rustc, the
cargo build tool and dependency manager, and required libraries.

The following packages have been upgraded to a later upstream version:rust(1.58.0). (BZ#2002883)

Security Fix(es):

*rust
From: Lubos KocmanTo: "factory@lists.opensuse.org"Subject: openSUSE Release Engineering meeting 04.05.2022
Message-ID: <3eaeefd8f569cb7d3dc03b3bc733d39321777325.camel@suse.com>
Date: Thu, 05 May 2022 13:55:50 +0000
CC: "results@suse.de"List-ID: Discussions about the development of the openSUSE distributions  
Archived-At:All meeting minutes can be found here
Does Hare share the same code bloat problems as C++(STL and Exceptions) andRust(large stdlib and no support of shared library)? 
 
More batteries-included language without such problems is nice to have for embeddedLinuxdevelopment.
linux)); // Windows is untested, but allow tinkering 
 
support would be wonderful. But that's missing and is currently only metadata. 
 
 > But I can't say that, because compiler writers have decided that UB means "the compiler twists your code into a pretzel."  
 
The twos complement example gets used all the time, but I heard another tale of why signed overflow is undefined: type promotion. If I iterate over a `short` and overflow is important, promoting to an int to access faster instructions or whatever and just letting it overflow to `USHORT_MAX+1` is no longer a valid optimization. C type promotion is weird and the differences between signed and unsigned promotions are likely reasons why one has defined extrema behaviors, but I don't know that much about that side of it. I admit that my grokking of the relevant rules is fuzzy at best and compiler warning-guided at worst.Rust
LinuxTo be a bit more concrete here: If I create a file like "\xffdummy.txt", and try to read the filename with glob::glob or os::diropen, or pass it as a command-line argument, then Hare dies with: 
 
 > Abort: Assertion failed: /usr/src/hare/stdlib/strings/cstrings.ha:33:1  
 
because of an "assert(utf8::valid(s));" 
 
If I create a file like "\xf8dummy.txt", then utf8::valid (wrongly) thinks it is valid, so I can read the filename into a str. strings::iter says the first rune (aka Unicode codepoint) is U+935B6D. strings::riter says: 
 
 > Abort: /usr/src/hare/stdlib/strings/iter.ha:68:22: Invalid UTF-8 string (this should not happen)  
 
At least it's not a memory-safety error in this case, though it wouldn't be surprising if some other function did non-bounds-checked accesses under the assumption that strings are UTF-8 (as promised by the specification). 
 
Even when it just aborts, that seems unfortunate for a systems programming language - maybe you clone a Git repository with some non-UTF-8 filenames, and your 'ls' and 'rm' were written in Hare
Linuxand arbitrary 16-bit sequences on Windows)... except it looks like Hare's path handling is already inadequate forLinux, because all the fs:: functions use 'str' which is specified as a UTF-8-encoded Unicode string (and violating that is undefined behaviour, according to strings::fromutf8_unsafe), so it can't handle all validLinuxfilenames, and the inability to handle all Windows filenames is the least of its problems. (Rust
I read it as the opposite. TraditionallyLinuxdistributions had the idea of packaging up every piece of useful FOSS software. But this clearly doesn't scale, and results in a lot of duplicate work. TheRustecosystem is but the latest example.
Rust, all the information is  there . Like, that serde example I used above — how many other crates depend on that? Well,  looks like 18,027  of 82,126 current crates. We could use that and provide something better for sysadmins and developers both. We're just... not really?

 And this goes for Python and Perl too, and whatever else. Java with Maven, of course. If you try to work with anything of size in those languages and try to force it through rpm for re-use of all the deps, that doesn't add a lot of value — and it misses out on value that's in the language-domain packaging. And burns people out.

 How can we, at theLinux
Now, every new language —Rust, for example — comes with its own
	tools to manage these, and they don’t work nicely together with our
	old way. The sheer scale is overwhelming — forRustalone, as I
	checked just now there are 81,541 such libraries. We can’t keep up
	with repackaging all of that into our own format, let alone that
	plus all of the other languages. We need to approach this
	differently in order to still provide a good solution to software
	developers.
rust: add support for big endian 64-bit PowerPC
      -rust: Add snapshot checksums for powerpc64le

   - RISC-V:

      - libunwind: Enable for rv64
      - systemtap: Enable for riscv64
      -linux-yocto-dev: add qemuriscv32
      - packagegroup-core-tools-profile: Enable systemtap for riscv64
      - qemuriscv: Use virtio-tablet-pci for mouse

   - x86:

      - kernel-yocto: conditionally enable
Linuxand the BSDs) is
  stable in trunk, and ARM CFI integration has been merged as a
  follow-up to facilitate debugging and profiling.  Notably, this also
  includes [memory model tests for ARMv8 and Power ports]. The Windows
  mingw64 port is also working again in trunk.

  An [effects tutorial] has also been contributed to the OCaml manual;
  feedback continues to be welcome even after it's merged in.  As you
  experiment with effects, please do continue to post to this forum with
  questions or comments about your learnings.

  The Sandmark benchmark project has added bytecode analysis to address
  any performance regressions. We have also been working on obtaining
  measurements for the compilation data points. The current-bench
  pipeline production deployments has significant UI changes, and now
  has alert notifications for the benchmark runs.

  As always, the Multicore OCaml open and completed tasks are listed
  first, which are then followed by the ecosystem tooling projects. The
  Sandmark, sandmark-nightly, and current-bench project updates are
  finally presented for your reference.

  /Editor’s note: please find the full changelog following the archive
  link above./


[Multicore OCaml] < https://github.com/ocaml-multicore/ocaml-multicore >

[previous updates] < https://discuss.ocaml.org/tag/multicore-monthly >

[memory model tests
rusting, steam powered technology devices demanding that the technology universe remains frozen in time and be supported forever, as is ( another example is Adam trying to deprecate the legacy xorg driver ) as opposed to be thinking a bit further away from their own noses, ahead into the future, to the state that the industry is in now and evolving into.   
 
This paragraph is very interesting because I've long been interpreting the situation exactly the other way. What if those unnecessary changes were only pushed hard by a few vendors who need to force their customers to regularly buy new hardware, and by software developers who see it as a guarantee to get a lifetime job ? I mean, I'm fine with changes that bring improvements, but there are many changes we're forced to swallow that significantly degrade our user experience. Sometimes you're even forced to abandon hardware by lack of support from new software, and for what justification, beyond "look how great the new version is" ? 
 
I used to have machines that took 3 seconds to start to boot from power-on in the past. At work
From: Theo de RaadtTo: announce@openbsd.org
Subject: OpenBSD 7.1 released, April 21, 2022
Message-ID: <44849.1650546853@cvs.openbsd.org>
Date: Thu, 21 Apr 2022 07:14:13 -0600
List-ID:  
Archived-At:------------------------------------------------------------------------
- OpenBSD 7.1 RELEASED -------------------------------------------------

April 21, 2022.

We are pleased to announce the official release of OpenBSD 7.1
Linuxis the underlying technology running this new world. 
 
I'm not too overly concerned with cloud vendors or other buisnesses that do not have their cybersecurity supply chain in check since the free market will take care of those that wont ( they break the root of trust and will just be stuck with financially starved clients ).  
 
For example if I was a government entity or a car manufacturer like Toyota,Volvo or Tesla I would not be doing any business with companies that dont have their cybersecurity supply chain in check and one of the things I would be checking for would be if the relevant vendor supported uefi and which hw manufacture it ran, in it's infrastructure on ( all the way down to component level ) etc. so I could validate and ensure that *my* cybersecurity supply chain was in check and *my* root of trust was secure.  
 
I would exclude IBM/RH/Amazone from every government/business contracts since it's quite apparent based on the feedback here and on fedora-devel that they are not ready for this. 
 
Their cybersecurity supply chain is not in order thus cannot be trusted and wont be for years ( from
Linuxdistribution. The team has been hard at work through this cycle, together
with the community and our partners, to introduce new features and fix bugs.

Ubuntu Desktop 22.04 LTS gains significant usability, battery and performance
improvements with GNOME 42. It features GNOME power profiles and streamlined
workspace transitions alongside significant optimisations which can double
the desktop frame rate on Intel and Raspberry Pi graphics drivers.

Ubuntu 22.04 LTS is the first LTS release where the entire recent Raspberry
Pi device portfolio is supported, from the new Raspberry Pi Zero 2W to the
Raspberry Pi 4. Ubuntu 22.04 LTS addsRust
case ofRustin the kernel is similar to the problems of vendored code necessary to keep some ecosystems running  
 
Vendored code already exists in theLinuxkernel.  TheRustmechanisms for tracking vendoring is strictly better than the ones we have for vendored C based projects in the kernel.
Rustdrivers presented for comparison here: 
 
 https://lwn.net/Articles/863459/  
 
... illustrate that ? 
 
Of course almost a year has passed since that was written, soRustandRustforLinuxhas made further improvements, but presumably you don't mean that these things somehow became mandatory in the last 12 months
Linuxhas a minimum version requirement for gcc (or clang) that gets raised pretty often. I believe it's at 5.1 right now:  https://lore.kernel.org/lkml/20210910234047.1019925-2-nde...  
 
So in practice, the _current_Linuxpolicy is worse thanRust. Instead of a well-defined edition, the kernel depends on an informal
Here's the (documentation for the)RustforLinuxalloc crate: https://rust-for-linux.github.io/docs/alloc/index.html 
 
As you will notice, inRustforLinuxthe alloc crate's APIs lack functions such as new() which are infallible, and instead only provide the fallible try_new() function, whereas in conventionalRustyou can choose.
Linuxkernel. Of course they'd still need to be code-reviewed and maybe adapted slightly for the specific environment they're being used in, and there's social questions about who will maintain the code and what their priorities are, but the same applies to new code that's written exclusively forLinux. Starting from an existing well-designed well-tested library should achieve the same quality with less work than starting from scratch.Rust
Rustcompiler/language going to start retain full backwards compatibility between the so called editions? 
 
I don't see future ofRustin kernel before this happens. In order to reach mainlineLinux,Rustneeds to have major changes to the more "conservative" side on how the language
LinuxPlatform) that will succeed the Codestream 15.
Agreed on OSBoard to wait to for official ALP announcement.

Focusing on Leap Micro to SLE Micro migration in spare time

## openSUSE Tumbleweed

WSL/Tumbleweeed - openQA somehow stopped working 9 months ago
 https://openqa.opensuse.org/group_overview/68  do we know why? This has
been asked by Jose (Cloud/WSL QA)

openSUSE:Factory build fail stats: 197 failed, 17 unresolvable (last
week: 81/26)
   https://tinyurl.com/ysy4nnnz 

* gcc12 is providing the libgcc library since snapshot 0405; default
compiler switch will follow later
* autoconf 2.71 is in Tumbleweed, a bunch of new failures appeared
* Mozilla Firefox 99
* KDE Frameworks 5.93
* Samba 4.16 - some bug reports came in about service starting, but
shares not accessible (boo#1198309)
* Full RelRO is enabled in Tumbleweed (-z now); any new build will
enable this and coverage increase over the next weeks. Once we have
gcc12 as default, we will trigger a full rebuild of the distro

## Richard (Kubic/TW MicroOS) 

Podman 4.0.x is in Factory
Pods in Podman 4.0.x are currently broken, due to catatonit 0.1.7 not
being in Factory. It's on the way, meanwhile rolling back is a valid
workaround
openQA tests for Pods in Podman is written, reviewed
Rustproject’s cavalier attitude to language and compiler stability, the absurd compiler bootstrapping and limited platform support makes it throughly unsuitable for theLinuxkernel., and that’s also why I won’t touch it despite the many benefits. Not to mention their belief that “curl something}bash” is acceptable
RustforLinuxintegratesRustinto the kernel build system, rather than using Cargo.  I think the attraction of using lots of third-party crates would quickly fade if developers had to write Makefiles for any dependency they wanted to add (very fewRustlibraries build without a build.rs file
The decision to useRustwill be done by actualLinuxdevelopers. 
 
And nobody is forcing you to use the mainlineLinux. If you so dislikeRust, then you are totally free to forkLinuxand maintain your ownRust-less fork.
Rust's no_std only gets rid of stuff from std itself (much of what you think of asRust's standard library was only re-exported from std and actually lives in core or alloc). 
 
So e.g. suppose you've got a slice (maybe an array, but however you got it, some contiguous memory) of Things and you'd like to sort them. In C without the standard library you're out of luck, code it yourself, but inRustlacking std only means you don't have a nice stable allocating merge sort, you do still get a perfectly usable (albeit not always trivially what you needed) in-place unstable sort. 
 
https://rust-for-linux.github.io/docs/core/primitive.slice.html#method.sort_unstable 
 
When C was invented such things would be too heavy, but todayRust's compiler and linker are certainly smart enough that if you never actually perform sort_unstable the code to implement it is omitted from your binary so the "price" ofRust's more comprehensive library is only that the documentation is a little larger and for that price you avoid the unsettlingly common (even inLinux
Rust's standard library (not all of which, admittedly, the kernel gets, see other comments about the stack of core -> alloc -> std of which the kernel will receive core and a somewhat custom alloc) has much more than I was used to from the C standard library and in many cases also utility libraries like Glib. 
 
Programs where in C I'd have reached for some third party utility libraries at least, often inRustthe standard library is more than enough. Yet it's still a very hospitable place to do the sort of low-level programmingLinux
Rustapplications, we do that at work. 
 
I don't see the point inRustforLinuxforbidding the use of crates.io crates. Yes, you'd probably want to enforce that only no_std crates are pulled in (I don't know if that's currently
Rust" knows nothing about kernel threads or how context switching is done in the kernel, for example. Kernel code must be extremely careful in how it allocates memory, must not use floating-point arithmetic, cannot store large data structures on the stack, and cannot use unbounded recursion,  
 
TheRustresponse to this would probably be "can't we just... solve that?" 
 
Various embeddedRustfolks have been doing work on things like static stack usage analysis. Tight stack requirements are not unique to theLinux
The latest round ofRustpatches wasposted by
Miguel Ojedaon March 17.  This time around,Rustsupport has
moved forward toversion
1.59.0of theRustlanguage, which has stabilized a 
couple of important (for the kernel) features.  The patches add a new module
abstracting access to hardware random-number generators.  ACStringtype has been added for C strings.  The spinlock
implementation has been improved.  All told, the patch series, which can be
found in thelinux-next repository, adds over 35,000 lines of code and
documentation; it is a considerable body of work.
LinuxEnterprise Server 15-SP4
                    SUSELinuxEnterprise Server for SAP 15-SP2
                    SUSELinuxEnterprise Server for SAP Applications 15-SP3
                    SUSELinuxEnterprise Server for SAP Applications 15-SP4
                    SUSE Manager Proxy 4.1
                    SUSE Manager Proxy 4.2
                    SUSE Manager Retail Branch Server 4.1
                    SUSE Manager Server 4.1
                    SUSE Manager Server 4.2
______________________________________________________________________________

   An update that fixes 8 vulnerabilities is now available.

Description:

   This update for MozillaFirefox fixes the following issues:

   Firefox Extended Support Release 91.8.0 ESR (bsc#1197903):

   MFSA 2022-14 (bsc#1197903)

   * CVE-2022-1097: Fixed memory safety violations that could occur when
     PKCS#11 tokens are removed while in use
   * CVE-2022-28281: Fixed an out of bounds write due to unexpected WebAuthN
     Extensions
   * CVE-2022-1196: Fixed a use-after-free after VR Process destruction
   * CVE-2022-28282: Fixed a use-after-free in DocumentL10n::TranslateDocument
   * CVE-2022-28285: Fixed incorrect AliasSet used in JIT Codegen
   * CVE-2022-28286: Fixed that iframe contents could be rendered outside the
     border
   * CVE-2022-24713: Fixed a denial of service via complex regular expressions
   * CVE-2022-28289: Memory safety bugs fixed in Firefox 99 and Firefox ESR
     91.8

   The following non-security bugs were fixed:

   - Adjustrust
Linuxguarantee this here). However if you have the comfort of writing software in a less fraught environment which doesn't experience time travel, there are two nice small safety improvements in the library here I think are worth a moment. 
 
5.abs_diff(-10) == 15 means you can ask "These two (maybe signed) integers I have, how big is the difference between them?" and get an (unsigned) answer without spending ten minutes trying to figure out if your solution does anything unexpected in corner cases each time or worrying whether you're doing something needlessly slow. 
 
Wrapping<T> getting OpAssign<T> implementations means e.g. Wrapping<i8> (a signed 8-bit integer which exhibits wrapping behaviour on overflow) has operators like += and *= working on i8 operands. So now: 
 
let acc: Wrapping<i8> = 0; 
let a: i8 = blackbox_100(); 
acc += a; 
let b: i8 = blackbox_100(); 
acc += b; 
 
... is a nice, syntax light way to express the fact you want the hardware two's complement behaviour for your accumulator acc, and you won't be surprised that acc is now -56 because that's how wrapping arithmetic
LinuxPlatform) based community offering (ETA late 2023)
where we expect to steer most of the development.
I'll write an annoucement about it to the factory this week.

software-o-o - super happy about the outcome. Big thanks to Henne,
hellcp

openh264 - Meeting with cisco tomorrow 5:30 - 6:00pm CEST
 https://github.com/cisco/openh264/issues/3480  
 https://cisco.webex.com/cisco/j.php?MTID=mddb2ec9947c8b8c... 

We'll have to reduce build failures on Backports. 


## openSUSE Tumbleweed

openSUSE:Factory build fail stats: 81 failed, 26 unresolvable (last
week: 120/14)
   https://tinyurl.com/ysy4nnnz 

* Kernel 5.17.1 is shipped, a few kmp packages fail to build
* KDE Plasma 5.24.4
* gcc12 is going to be the libgcc library provider starting with
snapshot 0405; default compiler switch will follow
* A staging with -z now (Full RelRO) is building and looking promising.
This is going to be enabled in one of the near-future snapshots

## Richard (Kubic/TW MicroOS) 

Podman 4.0.x struggling to get into Factory - WIP
MicroOS Desktop (GNOME 42) had issues with flatpaks needing filesystem
access - FIXED
Working on various interesting MicroOS research tracks:
    - kiwi-less/container first VM image building Status: POC
    - nerdctl support in toolbox Status: Broken prototype
    - buildkit and its limit as a container builder
LinuxPlatform) based community offering (ETA late 2023)
where we expect to steer most of the development.

software-o-o a lot of constructive feedback. Special thanks to lcp and
Henne. I'd say issues prio #1 and #2 are fixed (stuck at ruby 2.5 and
Leap 15.3+ unavailability). Next would be single click install (see my
email from today).

PUBLIC SLE* Bugzilla product exposure at new bug dialog at
bugzilla.opensuse.org done! SUSE TAMs will inform partners about the
change.

openh264 - No further update. I did receive an email from CISCO that
lopped in more contacts but no further feedback.
 https://github.com/cisco/openh264/issues/3480  So we're blocked there.

The Leap RC deadline corresponds with the SLE Public RC deadline (20th
of April). As far as Leap goes we're still in Beta, but SLE is already
at RC1 and will take only P1, P2 bugfixes. Late features and minor
issues have to go to :Update.

## openSUSE Tumbleweed

openSUSE:Factory build fail stats: 120 failed, 14 unresolvable (last
week: 87/18)
   https://tinyurl.com/ysy4nnnz 

* GNOME 42.0 Was released as part of snapshot 0323 - checkin the same
day it was released upstream. Echo so far is positive
*Linuxkernel
Linuxkernel 5.17 is staged
* systemd 250 passed Staging, but in the context of full prod test
caused some issues: bug#1197309 (systemd update not published in any
snapshot)
* GCC 12 pre-integration tests progressing (Staging:Gcc7); Scheduled
for actual merge in April/May

## Richard (Kubic/TW MicroOS) 

Kubernetes 1.23.4 and 1.22.7 have been released
podman 4.0.2 has been released
Some users have reported issues with coredns pods crashing, Bug reports
have been appreiciated but the log information has not yet provided
much insight into what's going on with coredns specifically. Any more
detailed logs regarding coredns CrashLoopBackoff problems in Kubic k8s
would help. Investigation ongoing.
Working on various interesting MicroOS research tracks:
    - kiwi-less/container first VM image building Status: POC
    - nerdctl support in toolbox Status: Broken prototype
    - buildkit and its limit as a container builder
    - TW-to-MicroOS conversion
    - curl-minimal and making it default (like Fedora) Status: 
Investigating
    - Re-arranging Factory so products like MicroOS can build with
different PrjConf than Tumbleweed
    - MicroOS Desktop using TIU instead of transactional-update (ie.
remove all individual rpm package management) (research not sure if
it's worth updating docs yet)
Please ping rbrown@suse.com if you are interested/have opinions
Rustonce that's an option.  
 
It is completely useless. 
 
 > C doesn't even have iterators, you can't express "are all the doodads in this bag of doodads sparkly?" except by explicitly enumerating them  
 
Iterators don't help. 
 
Let me explain what kinds of detailed comments are useful (picked at random from a codebase): 
 
- «Calling this external API simultaneously using the same API key causes it to lock up, so there is a mutex» 
- «Detaching a disk from a VM beforeLinux
LinuxEnterprise Desktop 15-SP3
                    SUSELinuxEnterprise High Performance Computing 15-SP3
                    SUSELinuxEnterprise Module for Development Tools 15-SP3
                    SUSELinuxEnterprise Server 15-SP3
                    SUSELinuxEnterprise Server for SAP Applications 15-SP3
                    SUSE Manager Proxy 4.2
                    SUSE Manager Server 4.2
______________________________________________________________________________

   An update that fixes one vulnerability is now available.

Description:

   This update forrust
Linuxmanual pages as the reference and public discussions of the features for
clarifying corner cases. On Linux/glibc, there was no stable glibc interface to
the rseq facility. One proposed integration was committed then reverted from
glibc. It might be prudent to wait some more for the rseq(2) interface to
stabilize in glibc before providing it in our libc or to rely on tight
integration between kernel and userspace in our base system, and use ABI tricks
like symbol versioning to evolve the interface. There is no goal to be 100%
compatible withLinuxanyway.

Sponsor: The FreeBSD Foundation

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Base System OpenSSH Update

Links:
OpenSSH URL:  https://www.openssh.com/ 
Announcement to freebsd-security@ URL:  https://lists.freebsd.org/pipermail/ 
freebsd-security/2021-September/010473.html

Contact: Ed Maste <emaste@freebsd.org>

OpenSSH, a suite of remote login and file transfer tools, was updated from
version 8.7p1 to 8.8p1 in the FreeBSD base system.

NOTE: OpenSSH 8.8p1 disables the ssh-rsa signature scheme by default. For more
information please see the Important note for future FreeBSD base system
OpenSSH update mailing list post.

OpenSSH supports FIDO/U2F devices, and support is now enabled in the base
system.

Next steps include integrating U2F key devd
Rustmight well be ideal for writing modules in the L4 world. I'm not sure how it makes sense inLinux, although if the primary kernel developers say it does then there's an excellent chance it does even if I can't see it. 
 
There
Rustis conservative, for example recently there was work to let you do more natural things with Wrapping types, so e.g. today you write 
 
  let a = Wrapping<i8>(127); 
  let b = Wrapping<i8>(1); 
  let c = a + b; 
  /* now c is Wrapping<i8>(-128) */ 
 
The authors originally thought it would be nice if this worked: 
 
  let a = Wrapping<i8>(127); 
  let b: i8 = 1; 
  let c = a + b; 
  /* authors thought it's reasonable c is Wrapping<i8>(-128) but is that definitely what was expected?*/ 
 
After feedback to their patches they agreed this could be surprising and instead only implemented *Assign Traits, thus: 
 
  let mut a = Wrapping<i8>(127); 
  let b: i8 = 1; 
  a += b; 
  /* The type of a hasn't changed, so it is now Wrapping<i8>(-128) and that makes sense */ 
 
InRustforLinux
LinuxKernel developers to do that or to set simple standards for code they will accept in mainline. All we are talking about is using RAII and data encapsulation to enable safer more reliable coding. As a comment above says, the aspects ofRustthat are being promoted to the Kernel
rustfails to build for a while now.
 https://bugzilla.opensuse.org/show_bug.cgi?id=1196328 

Leap 15.3:
  * Issue with installation media (net installation) for devices w/o
Real-Time-Clock. Workaround: Trigger rebuild of installation media.
 https://bugzilla.opensuse.org/show_bug.cgi?id=1194660 
lkocman: to update the bug with installmedia refresh.
lkocman: respin done waiting for final s390x task to finish and then
let's republish it
 https://build.opensuse.org/project/show/openSUSE:Leap:15.... 

Leap 15.4:
   * aarch64: 
        * Go compiler from SLE still lacks ld.gold which is still
required. This make some packages to fail to build (e.g.
openSUSE:Backports:SLE-15-SP4/rclone). Bug opened since Leap 15.3:
 https://bugzilla.opensuse.org/show_bug.cgi?id=1183043 
   * armv7: 
        * armv7 images are now tested in openQA with an armv7 kernel
overlay with a fix for the bug with btrfs and lzo compression:
 https://bugzilla.opensuse.org/show_bug.cgi?id=1193852  


## Sarah - s390x
Tumbleweed:
* Reboot does not work:   
 https://bugzilla.opensuse.org/show_bug.cgi?id=1193889 
(forwarded to IBM for allLinux
rust-1.53.0-22.1rust-debuginfo-1.53.0-22.1

   - SUSE Manager Server 4.1 (noarch):rust-src-1.53.0-22.1

   - SUSE Manager Server 4.1 (x86_64):

      rls-1.53.0-22.1
      rls-debuginfo-1.53.0-22.1rust-analysis-1.53.0-22.1

   - SUSE Manager Retail Branch Server 4.1 (noarch):rust-src-1.53.0-22.1

   - SUSE Manager Retail Branch Server 4.1 (x86_64):

      cargo-1.53.0-22.1
      cargo-debuginfo-1.53.0-22.1
      rls-1.53.0-22.1
      rls-debuginfo-1.53.0-22.1rust-1.53.0-22.1rust-analysis-1.53.0-22.1rust-debuginfo-1.53.0-22.1

   - SUSE Manager Proxy 4.1 (noarch):rust-src-1.53.0-22.1

   - SUSE Manager Proxy 4.1 (x86_64):

      cargo-1.53.0-22.1
      cargo-debuginfo-1.53.0-22.1
      rls-1.53.0-22.1
      rls-debuginfo-1.53.0-22.1rust-1.53.0-22.1rust-analysis-1.53.0-22.1rust-debuginfo-1.53.0-22.1

   - SUSELinux
Linuxwere
  Eio can take advantage of io_uring. For example, this graph shows how
  various HTTP servers cope with increasing load:


<https://user-images.githubusercontent.com/554131/151006021-2eb8f55e-40b3-409c-bbce-3cd582ac1231.png>

  `httpaf_eio' is currently at the top (though note that theRustserver,rust_hyper, is not using io_uring, so this is not a completely
Linuxsource code (~30M LOC) is way bigger than the Python source code (1M  LOC), the API exposed by theLinuxkernel (syscall, ioctl, devices, etc.) looks smaller than the API of the Python language and its large standard library.  
 
Is it harder to prevent accidental API breakage in Python than inLinux? 
Probably yes. 
 
But that's not the point. 
You are breaking the API on purpose! (= deprecation and eventual removal). 
That's the point. 
 
TheLinuxrule is pretty simple: Don't break applications. 
 
And I don't think that would be impossible for Python. 
Other complex languages do manage to achieve that goal. Look atRust
rust-ripgrep-13.0.0-4.fc34  
   Date : 
                 Fri, 04 Feb 2022 01:23:35 +0000  
   Message-ID : 
                 <20220204012335.4F619308589A@bastion01.iad2.fedoraproject.org>  
   Archive-link : 
                  Article   
  --------------------------------------------------------------------------------
Fedora Update Notification
FEDORA-2022-7ec8bda833
2022-02-04 01:20:59.298289
--------------------------------------------------------------------------------

Name        :rust-ripgrep
Product     : Fedora 34
Version     : 13.0.0
Release     : 4.fc34
URL         :  https://crates.io/crates/ripgrep 
Summary     : Line oriented search tool
Description :
Line-oriented search tool that recursively searches the current directory for a
regex pattern while respecting gitignore rules. ripgrep has first class support
on Windows, macOS andLinux
rust-ripgrep-13.0.0-4.fc35  
   Date : 
                 Sat, 29 Jan 2022 06:41:37 +0000  
   Message-ID : 
                 <20220129064137.7DADA3139394@bastion01.iad2.fedoraproject.org>  
   Archive-link : 
                  Article   
  --------------------------------------------------------------------------------
Fedora Update Notification
FEDORA-2022-c4071e3dc7
2022-01-29 06:37:20.624357
--------------------------------------------------------------------------------

Name        :rust-ripgrep
Product     : Fedora 35
Version     : 13.0.0
Release     : 4.fc35
URL         :  https://crates.io/crates/ripgrep 
Summary     : Line oriented search tool
Description :
Line-oriented search tool that recursively searches the current directory for a
regex pattern while respecting gitignore rules. ripgrep has first class support
on Windows, macOS andLinux
Linuxdistros are struggling to keep pace, especially where you have to buildRusttoolchains or whatever in addition. The two browsers have enough code to be a mini OS in themselves and, sadly, upstream aren't always interested in building on architectures other than Intel/AMD/Android. Not a great
LinuxEnterprise Server for SAP 15 (ppc64le x86_64):

      cargo-1.53.0-3.40.1
      cargo-debuginfo-1.53.0-3.40.1rust-1.53.0-3.40.1rust-debuginfo-1.53.0-3.40.1rust-gdb-1.53.0-3.40.1

   - SUSELinuxEnterprise Server for SAP 15 (noarch):rust-src-1.53.0-3.40.1

   - SUSELinuxEnterprise Server for SAP 15 (x86_64):

      rls-1.53.0-3.40.1rust
Rustfix doesn't work on older macOS is because openat() wasn't present.  openat() wasn't present inLinuxin the mid-1990s either, and was added to different systems at different times. 
 
Also, the TOCTOU bugs are in applications, not the OS or the C library
Ruststandard libraries has been resolved says otherwise. No one can guarantee perfectly bug-free code, of course, but it *is* possible to handle symlinks correctly. This CVE was never really a symlink issue in the first place. The minor symlink issue was easily dealt with in the original code by not following symlinks to directories. That part worked fine in a single-user, unshared environment. However, you can't just say "if (is_symlink(path)) { unlink(path); } else { recurse(path); }" in a shared filesystem without accounting for the fact that the entry at "path" can change. This is basic concurrency, made worse by the fact that you're sharing state with less privileged code. The same kind of bug could easily occur in other areas having nothing to do with symlinks, such as access checks. Developers have all the tools needed to avoid this issue (openat, fstat, unlinkat, fdopendir), at least onLinux
RustforLinuxgets a library it can ship inLinux. 
 
It's future proofed in that the assumption is some dayRustwill have a way to disable or sidestep this, and at that pointRustforLinuxcan just ship the normal core library (in this respect
The article phrased this poorly.  TheRust*language* is independent of the default standard library.  Plenty of use cases (includingRust-for-Linux) use "no-std" which fully supports writing code with fallible allocations.  Plenty more at e.g.  https://doc.rust-lang.org/stable/embedded-book/intro/no-s...
Ruststability, or maybe not, inRustthere's a concept of "unstable" features. These features exist, and they work in whatever build ofRustyou have, but tomorrow there might be a newRustversion and they're altered, or renamed, or gone. In contrast all the stable features ofRustare promised to still work into the indefinite future, none have been removed since 1.0 in 2015. You have to specifically opt in to having unstable features, and to each specific unstable feature you want. TodayRustforLinux
Rustlibrary†. That latter is worth a moment's thought:Rustsays you can format floating point numbers.Linux, of course, would very much rather you didn't use floating point numbers at all. So,Rust-for-Linuxwants to tell the core library that we aren't going
Most of theRustcode itself currently appears in two crates.  The first,
calledalloc,
deals with memory allocation.  TheRustlanguage 
wasn't built with the idea that code might need to continue when a memory
allocation fails; instead, the normal result is an immediate crash.  Since
crashing in kernel code is considered to be impolite, a modified allocator
that can handle failures is required.  As aRustdeveloper would expect, it
returns aResultobject that contains either a pointer to the allocated
memory or an error indication, depending on what happened.  Evidently the
work to support fallible allocations is meant to go into the upstreamRustlibrary, so the kernel's version of this crate may eventually be able to go
away.
relevant, but it is. 
 
Thanks also for being positive aboutRustin the kernel. 
 
I actually hopeLinuxdoes have some high-profile losses to other OSes. That would help defuse the narrative that whateverLinuxkernel devs do (or don't do) is justified becauseLinuxkeeps winning.
Support for kernel modules written inRustwill be merged in 2022,
but not before we have to endure at least one more long discussion on
whether adding a new 
language makes sense.  Some developers will resist the burden of learning a
new language, while others will repeat strange theories about how addingRustis a sign of some sort of corporate takeover of the project.  But the
kernel project needs to be looking at safer technologies, andRustseems
well positioned to address that need.
rust-1.1.2: Python extensions written inrustpython-tomli-1.2.2: A lil' TOML parser
      rtmidi-5.0.0: API for realtime MIDI handling

New versions: (193)
  ansible-bundler         :           1.7.1 ->          1.10.2
  ansible-core            :          2.12.0 ->          2.12.1
  attica                  :          5.88.0 ->          5.89.0
  baloo                   :          5.88.0 ->          5.89.0
  bluez-qt                :          5.88.0 ->          5.89.0
  boost                   :          1.76.0 ->          1.78.0
  breeze-icons            :          5.88.0 ->          5.89.0
  cinnamon                :           5.2.4 ->           5.2.5
  cssutils                :           1.0.1 ->           2.3.0
  digikam                 :           7.3.0 ->           7.4.0
  drumstick               :           1.1.1 ->           2.5.0
  dunst                   :           1.7.2 ->           1.7.3
  extra-cmake-modules     :          5.88.0 ->          5.89.0
  frameworkintegration    :          5.88.0 ->          5.89.0
  gcalcli                 :           3.3.2 ->           4.3.0
  ghostscript             :          9.54.0 ->          9.55.0
  go                      :          1.17.4 ->          1.17.5
  gradle                  :           7.3.1 ->           7.3.2
  imlib2                  :           1.7.4 ->           1.7.5
  inxi                    :        3.3.09-1 ->        3.3.10-1
  kactivities             :          5.88.0 ->          5.89.0
  kactivities-stats       :          5.88.0 ->          5.89.0
  kapidox                 :          5.88.0 ->          5.89.0
  karchive                :          5.88.0 ->          5.89.0
  kauth                   :          5.88.0 ->          5.89.0
  kbookmarks              :          5.88.0 ->          5.89.0
  kcalendarcore           :          5.88.0 ->          5.89.0
  kcmutils                :          5.88.0 ->          5.89.0
  kcodecs                 :          5.88.0 ->          5.89.0
  kcompletion             :          5.88.0 ->          5.89.0
  kconfig                 :          5.88.0 ->          5.89.0
  kconfigwidgets          :          5.88.0 ->          5.89.0
  kcontacts               :          5.88.0 ->          5.89.0
  kcoreaddons             :          5.88.0 ->          5.89.0
  kcrash                  :          5.88.0 ->          5.89.0
  kdav                    :          5.88.0 ->          5.89.0
  kdbusaddons             :          5.88.0 ->          5.89.0
  kdeclarative            :          5.88.0 ->          5.89.0
  kded                    :          5.88.0 ->          5.89.0
  kdelibs4support         :          5.88.0 ->          5.89.0
  kdesignerplugin         :          5.88.0 ->          5.89.0
  kdesu
Rust) 
  chromium 36M lines (14M C++, 5M headers, 4M Javascript)linux32M lines (21M C, 7M headers) 
 
Browsers are effectively an entire userspace unto themselves, so it's not surprising builds are the same size as a minimal desktop image. 
 
Otherwise, what mathstuf said. Link times on large C++ applications
rust-toolset:rhel8 security update
Advisory ID:       RHSA-2021:4590-01
Product:           Red Hat EnterpriseLinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:4590 
Issue date:        2021-11-10
CVE Names:         CVE-2021-42574 
=====================================================================

1. Summary:

An update for therust-toolset:rhel8 module is now available for Red Hat
EnterpriseLinux8.

Red Hat Product
LinuxAppStream (v. 8) - aarch64, noarch, ppc64le, s390x, x86_64

3. Description:RustToolset provides theRustprogramming language compiler rustc, the
cargo build tool and dependency manager, and required libraries. 

The following packages have been upgraded to a later upstream version:rust(1.54.0). (BZ#1945805)

Security Fix(es):

*rust
While they did find some indication that similar techniques had been used
in various ways, they found no smoking guns.  For example, theSlither
static-analysis toolfor smart contracts checks for bidirectional
overrides, noting that they can be used to swap variables passed as
arguments.  Another use was for obfuscating JavaScript code.  In parallel
to the GitHub scan,Rustproject contributors did a scan ofcrates.iocode, which is the public package
repository forRust, and found no evidence of exploitation of these flaws.
LinuxDistribution Working Group together with Fedora at the
Open Mainframe Project:
- Slack channel and mailing list for all distributions created:
     https://lists.openmainframeproject.org/g/wg-linux-distros 
    https://join-slack.openmainframeproject.org/ : the new channel is
#linux-distros-wg

* openSUSE Tumbleweed tests are failing because a LLVM issue (race
condition) in the build of PostgreSQL11 andRust
Rust. Our main goal for the 0.0.1 release has been to have no
critical missing security features. There are probably still a lot of bugs, though, so you
shouldn’t use this in production yet.

Tor Browser 10.5.10
 https://blog.torproject.org/new-release-tor-browser-10510 
(Oct. 25) This version launches the Privacy is a Human Right fundraiser. 

Release 0.3.5.17, 0.4.5.11, 0.4.6.8 and 0.4.7.2-alpha
 https://forum.torproject.net/t/release-0-3-5-17-0-4-5-11-... 
(Oct. 25)  This Tor stable release completely removes v2 onion services. Onion operators must
upgrade to v3. Alpha release: testing Congestion Control proposal and MiddleOnly Relay Flag.

Tor Browser 11.0a9 (Windows/macOS/Linux)
 https://blog.torproject.org/new-release-tor-browser-110a9 
(Oct. 16) This version updates Firefox to version 91.2.0esr on Windows, macOS, andLinux
Linuxdistributions, has been released on October 26, 2021.

Here is the list of new features in this release:

*Linuxkernel 5.14, glibc 2.34 and ~280 other recipe upgrades
* Switched override character to ':' (replacing '_') for more robust
parsing and improved performance - see migration guide for help on migrating
*Rust
Paul McKenney hasdeclaredthat hisblog series
onRustand theLinuxkernelis now complete, and he has some
recommendations regarding the use of some of the kernel's more esoteric
techniques fromRust:
Linuxor Windows?).

  Finally, such design splits well the project into multiples part where
  the core is only about the DSL and derivation of `conan' (such as
  `conan-unix' or `conan-lwt') are more about accesses & file
  representation into specific contexts.

  As other MirageOS projects, we implemented a fuzzer which checks that
  the recognition never breaks the control flow via an exception from an
  unimplemented feature and we tried to implement tests as much as we
  can.


[good] < http://m.middleeastkitchen.com/salads/tunisiancarrotpotat... >

[`Format'] < https://ocaml.org/meetings/ocaml/2013/slides/vaugon.pdf >


Status of the project
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  The project is usable as its first release. However, we did not
  implemented the whole `libmagic' because:
  1) it's not really essential for our purpose
  2) it's buggy from the type-system point-of-view

  That mostly means that, given the `libmagic''s database, we are not
  sure to handle all cases. And it's probable that an error still occurs
  for some patterns. But this is where you come. We definitely need a
  large usage of `conan' to improve it _via_ an interaction loop between
  you and us.

  So we advise
LinuxDistribution Working Group together with Fedora at the
Open Mainframe Project:
 https://github.com/openmainframeproject/tac/issues/277 
Goals: Better support for s390x specific bugs by IBM, collaboration,
help for specific distribution ports

* openSUSE Tumbleweed tests are failing because a LLVM issue (race
condition) in the build of PostgreSQL11 andRust: 
 https://bugzilla.opensuse.org
Rustprovides unlock() which takes your data foo and drops it for you ] 
 
ObviouslyRusttype magic can't cure pure logic errors. If the problem was that the code locks and modifies some totally unrelated tty, that might still be a graveLinuxbug, but this type of bug where
Linux* CVE-2021-29985: Use-after-free media channels
   * CVE-2021-29982: Single bit data leak due to incorrect JIT optimization
     and type confusion
   * CVE-2021-29989: Memory safety bugs fixed in Firefox 91 and Firefox ESR
     78.13
   * CVE-2021-29990: Memory safety bugs fixed in Firefox 91

   This update was imported from the SUSE:SLE-15:Update update project.


Patch Instructions:

   To install this openSUSE Security Update use the SUSE recommended installation methods
   like YaST online_update or "zypper patch".

   Alternatively you can run the command listed for your product:

   - openSUSE Leap 15.2:

      zypper in -t patch openSUSE-2021-1367=1



Package List:

   - openSUSE Leap 15.2 (x86_64):

      MozillaFirefox-91.2.0-lp152.2.67.1
      MozillaFirefox-branding-upstream-91.2.0-lp152.2.67.1
      MozillaFirefox-debuginfo-91.2.0-lp152.2.67.1
      MozillaFirefox-debugsource-91.2.0-lp152.2.67.1
      MozillaFirefox-devel-91.2.0-lp152.2.67.1
      MozillaFirefox-translations-common-91.2.0-lp152.2.67.1
      MozillaFirefox-translations-other-91.2.0-lp152.2.67.1rust
LinuxEnterprise Server 11-SP4-LTSS
                    SUSELinuxEnterprise Debuginfo 11-SP4
______________________________________________________________________________

   An update that fixes 20 vulnerabilities, contains one
   feature is now available.

Description:

   This update for MozillaFirefox,rust-cbindgen fixes the following issues:

   MozillaFirefox was updated to Extended Support Release 91.2.0 ESR

   * Fixed: Various stability, functionality, and security
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3841 
Issue date:        2021-10-13
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
                   CVE-2021-38502 
=====================================================================

1. Summary:

An update for thunderbird is now available for Red Hat EnterpriseLinux7.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxClient (v. 7) - x86_64
Red Hat EnterpriseLinuxServer Optional (v. 7) - ppc64le, x86_64
Red Hat EnterpriseLinuxWorkstation (v. 7) - x86_64

3. Description:

Mozilla Thunderbird is a standalone mail and newsgroup client.

This update upgrades Thunderbird to version 91.2.0.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

* Mozilla: Downgrade attack on SMTP STARTTLS connections (CVE-2021-38502)

*rust
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3840 
Issue date:        2021-10-13
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
                   CVE-2021-38502 
=====================================================================

1. Summary:

An update for thunderbird is now available for Red Hat EnterpriseLinux8.1
Extended Update Support.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxAppStream EUS (v. 8.1) - ppc64le, x86_64

3. Description:

Mozilla Thunderbird is a standalone mail and newsgroup client.

This update upgrades Thunderbird to version 91.2.0.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

* Mozilla: Downgrade attack on SMTP STARTTLS connections (CVE-2021-38502)

*rust
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3839 
Issue date:        2021-10-13
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
                   CVE-2021-38502 
=====================================================================

1. Summary:

An update for thunderbird is now available for Red Hat EnterpriseLinux8.2
Extended Update Support.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxAppStream EUS (v. 8.2) - aarch64, ppc64le, x86_64

3. Description:

Mozilla Thunderbird is a standalone mail and newsgroup client.

This update upgrades Thunderbird to version 91.2.0.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

* Mozilla: Downgrade attack on SMTP STARTTLS connections (CVE-2021-38502)

*rust
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3838 
Issue date:        2021-10-13
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
                   CVE-2021-38502 
=====================================================================

1. Summary:

An update for thunderbird is now available for Red Hat EnterpriseLinux8.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxAppStream (v. 8) - aarch64, ppc64le, s390x, x86_64

3. Description:

Mozilla Thunderbird is a standalone mail and newsgroup client.

This update upgrades Thunderbird to version 91.2.0.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

* Mozilla: Downgrade attack on SMTP STARTTLS connections (CVE-2021-38502)

*rust
Linux* CVE-2021-29985: Use-after-free media channels
   * CVE-2021-29982: Single bit data leak due to incorrect JIT optimization
     and type confusion
   * CVE-2021-29989: Memory safety bugs fixed in Firefox 91 and Firefox ESR
     78.13
   * CVE-2021-29990: Memory safety bugs fixed in Firefox 91


Patch Instructions:

   To install this openSUSE Security Update use the SUSE recommended installation methods
   like YaST online_update or "zypper patch".

   Alternatively you can run the command listed for your product:

   - openSUSE Leap 15.3:

      zypper in -t patch openSUSE-SLE-15.3-2021-3331=1



Package List:

   - openSUSE Leap 15.3 (aarch64 ppc64le s390x x86_64):rust
Linux7.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxClient (v. 7) - x86_64
Red Hat EnterpriseLinuxClient Optional (v. 7) - x86_64
Red Hat EnterpriseLinuxServer (v. 7) - ppc64, ppc64le, s390x, x86_64
Red Hat EnterpriseLinuxServer Optional (v. 7) - x86_64
Red Hat EnterpriseLinuxWorkstation (v. 7) - x86_64
Red Hat EnterpriseLinuxWorkstation Optional (v. 7) - x86_64

3. Description:

Mozilla Firefox is an open-source web browser, designed for standards
compliance, performance, and portability.

This update upgrades Firefox to version 91.2.0 ESR.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

*rust
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3757 
Issue date:        2021-10-11
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
=====================================================================

1. Summary:

An update for firefox is now available for Red Hat EnterpriseLinux8.1
Extended Update Support.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxAppStream EUS (v. 8.1) - aarch64, ppc64le, s390x, x86_64

3. Description:

Mozilla Firefox is an open-source web browser, designed for standards
compliance, performance, and portability.

This update upgrades Firefox to version 91.2.0 ESR.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

*rust
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3756 
Issue date:        2021-10-11
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
=====================================================================

1. Summary:

An update for firefox is now available for Red Hat EnterpriseLinux8.2
Extended Update Support.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxAppStream EUS (v. 8.2) - aarch64, ppc64le, s390x, x86_64

3. Description:

Mozilla Firefox is an open-source web browser, designed for standards
compliance, performance, and portability.

This update upgrades Firefox to version 91.2.0 ESR.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

*rust
LinuxAdvisory URL:       https://access.redhat.com/errata/RHSA-2021:3755 
Issue date:        2021-10-11
CVE Names:         CVE-2021-32810 CVE-2021-38496 CVE-2021-38497 
                   CVE-2021-38498 CVE-2021-38500 CVE-2021-38501 
=====================================================================

1. Summary:

An update for firefox is now available for Red Hat EnterpriseLinux8.

Red Hat Product Security has rated this update as having a security impact
of Important. A Common Vulnerability Scoring System (CVSS) base score,
which gives a detailed severity rating, is available for each vulnerability
from the CVE link(s) in the References section.

2. Relevant releases/architectures:

Red Hat EnterpriseLinuxAppStream (v. 8) - aarch64, ppc64le, s390x, x86_64

3. Description:

Mozilla Firefox is an open-source web browser, designed for standards
compliance, performance, and portability.

This update upgrades Firefox to version 91.2.0 ESR.

Security Fix(es):

* Mozilla: Use-after-free in MessageTask (CVE-2021-38496)

* Mozilla: Memory safety bugs fixed in Firefox 93, Firefox ESR 78.15, and
Firefox ESR 91.2 (CVE-2021-38500)

* Mozilla: Memory safety bugs fixed in Firefox 93 and Firefox ESR 91.2
(CVE-2021-38501)

*rust
Rustand GCC, two different ways:
  two projects taking different approaches to support theRustlanguage
  with the GCC compiler.
Linux, but it's worth reflecting on the fact that "diversity" is often portrayed as a strength of C++ and that diversity consists only of three implementations with fairly incestuous relationships. For example the entire MSVC standard library source is published just like its equivalents from GNU and LLVM, and you will see primary authors of two standard libraries attending talks by authors of the other one on this or that interesting trick they exploited or corner case they wrestled with - after all they're by definition the most interested parties. 
 
If we get two similarly "competing" compilers forRust
Linux-kernel READ_ONCE() and WRITE_ONCE() are required to do more than just a volatile access, and in some cases this "more" is controlled by aLinux-kernel Kconfig option.  Yes, you could duplicate this logic inRustcode, but it might be simpler to just rely
Rustactually ships, today, what you'd actually want, a pair of generic intrinsics for volatile reads and writes. Provide a suitably aligned pointer and you can read, or write, any implemented data type.Rustpromises this read (or write) doesn't tear and won't get re-ordered, duplicated, optimised out etc. since performing the read (or write) has side effects invisible to the compiler (except that ZSTs can be elided because, fancy as MMIO is, reading or writing *nothing* does not have side effects). On most systems, of course, the intrinsic evaluates to a single machine code instruction. 
 
This is roughly what Paul and co. have asked for in P1382R1 for C++ which makes sense because, as I said, it's what you'd actually want. 
 
But what jumps out at me is that althoughRustprovides this intrinsic, which is exactly what you'd want here, Paul apparently proposes that whatRustought to do instead is wrap theLinux
Developers working in languages like C or C++ have access to
two competing compilers — GCC and LLVM — either of which can usually get
the job done.Rustdevelopers, though, are currently limited to the
LLVM-based rustc compiler.  While rustc works well, there
are legitimate reasons for developers to wish for an alternative.  As it
turns out, there are two different ways to compileRustusing GCC under
development, though neither is ready at the moment.  Developers of both
approaches came to the2021LinuxPlumbers Conferenceto present the status of their work.
[...]
These blog posts will therefore present approaches ranging upwards from trivial workarounds. But be warned that some of the high-quality approaches require profound reworking of compiler backends that have thus far failed to spark joy in the hearts of compiler writers. In addition,Rustenjoys considerable use outside of theLinuxkernel, for example, as something into which to rewrite inefficient Python scripts. (A megawatt here, a megawatt there, and pretty soon you are talking about real power consumption!) Therefore, there are probably sharp limits beyond which the coreRustdevelopers are unwilling to go.
Improvements to GCC's -fanalyzer
  option: GCC's static analyzer is getting better — a report from theLinuxPlumbers conference.
Rust?  IfRustmakes an OS project attractive to many highly competent developers, one of these projects should be on the way to overtakeLinux, no?  Admittedly there is also the draw of contributing to the most widely-used kernel, but still, the BSDs survive despite not having the most
Linuxdevelopment that "kernel maintainers shall not be required to learn anything new"?  
 
In any busy project, maintainers tend to operate at 100+% of their capacity. Whenever they need to learn something new, that effort is taken away from their "usual" activities (which are possibly the activities that they get paid for). Obviously they keep learning new things incrementally, but new material that's intrusive and has a steep learning curve (= late RoI) must be a different sell. 
 
 > I guess the problem is that those changes have been incremental but "learnRust
respect the TSO (total store ordering) model that x86 uses. 
 
* I might be wrong on this, but the first architecture for whichLinuxsupported SMP was either SPARC or Alpha, almost certainly not x86 
 
Right now, theRustmemory model _is_ the C/C++ model since it just reuses the same backend code.
UsingRustfor kernel development:
     what will be needed to get theRustforLinuxpatches merged?
Airlie said that there are examples ofRustcode at the edges of the kernel,
such as drivers.  Has any work gone into puttingRustinto the core, with C
code at the edges?  Ojeda answered that theRustdevelopers are not trying
to rewrite things in the core kernel; instead, they are making a set of
abstractions so that drivers can be written in saferust.  A C driver using
aRustcore would lose a lot of the advantages of usingRust, he said;
once you go toRust, you want to stay there.
Rustdriver. 
 
In my opinion the best targets are cases where multiple distinct hardware implementations exist without any good reason. Think entry-level PCI network cards in the late 1990s. There's no reason for so many different vendors to make a 100Mbps PCI Ethernet card that has essentially the same features as the competitors but requires its own driver, but that's what happened, and you can imagine that there's nothing interesting (potentially requiring unsafe and deep kernel knowledge or new subsystem code) in the NE2k driver compared to the 3Com one so that the work to make the 19th and 20th of these drivers is not actually the application of arcane wisdom kernel programmers might pride themselves in, but mostly rote work copying from manufacturer data sheets and a little bit of "suck it and see" when the data sheet is needlessly ambiguous.Rustis going to make that practical for patient non-experts whose sole advantage over the existingLinux
programming language  
 
It is not a C replacement.  In practice, it has been more of a Python replacement (or maybe PHP, Ruby or Java replacement).   To replace C, it was originally C++ and more recentlyRust.  This is why Google is pushing forRustin Chrome, Android (Linuxkernel) etc.
TheRustforLinuxproject: an
  introduction to the effort to bringRustinto theLinuxkernel.
There is a (default off) lint to warn you that this might be a bad idea  
 
Indeed -- inRustforLinuxwe are already using `unsafe_op_in_unsafe_fn` (as an error, in fact, rather than a warning) and I hope it becomes the default in a futureRustedition.
Thefirst dayof theKangrejos(RustforLinux) conference
introduced the project and what it was trying to accomplish;day 2covered a number of coreRustconcepts and their relevance to the kernel.  On the third and final day of
the conference, Wedson Almeida Filho delved deeper into howRustcan be
made to work in theLinuxkernel, covered some of the lessons that have been
learned so far, and discussed next steps with a number of kernel
developers.
Linuxdistributions. Yes, newer software requires newerRust, but stable distributions typically keep the same base version ofRustand the same base version of other software.  
 
It isn't that it is an issue per se, it's that policy (both inrust, and in Alpine) is presently
Rustcompiler for an entire 2 year lifecycle  
 
This hasn't been that much of an issue for otherLinuxdistributions. Yes, newer software requires newerRust, but stable distributions typically keep the same base version ofRustand the same base version of other software. 
 
This issue would
For distributions, however, the story is different:cryptographymoved to usingRust, because they wanted to
	leverage all of the static analysis capabilities built into the
	language.  This, too, is a reasonable decision, from a development
	perspective.  From the ecosystem perspective, however, it is
	problematic, as theRustecosystem is still rapidly evolving, and
	so we cannot support a single branch of theRustcompiler for an
	entire 2 year lifecycle, which means it exists in community.  Our
	solution, historically, has been to holdcryptographyat
	the latest version that did not requireRustto build.  However,
	that version is not compatible with OpenSSL 3, and so it will
	eventually need to be upgraded to a new version which is.  And so,
	sincecryptographyhas to move to community, so doesparamikoand Ansible.
Thefirst dayof the onlineKangrejos conferencewas focused on
introducing the effort to bring theRustprogramming languageinto theLinuxkernel.  On the second day, conference organizer Miguel Ojeda shifted
to presenting theRustlanguage itself with an emphasis on whatRustcan
provide for kernel development.  The result was a useful resource for
anybody who is curious about this project, but who has not yet had the time
to become familiar withRust.
linuxdevelopment, but from the articles and comments on this site my understanding is that lot (some?) of the changes require some modifications even in other subsystems, even if your main patch is focused on one. 
 
If the other subsystem is (partially) inrust, which you do not know, how would
Linuxdevelopment that "kernel maintainers shall not be required to learn anything new"? Presumably over time kernel devs have had to learn new rules for writing C code, as the kernel C dialect has moved away from standard C and issues like memory ordering have become important. I guess the problem is that those changes have been incremental but "learnRust
linuxdidn't, why shouldrust? 
 
What's that saying? If you don't evolve you die? Mayberustis the next evolution forlinux? Maybe it isn't, but don't put artificial obstacles in the way - you should knowlinuxwell enough to know
Rustdoes not yet work on all of the architectures supported by theLinuxkernel; this was discussed a bit more in the later days (stay tuned).  That's recognized as a problem and is one of the reasons why people are looking forward to the native GCCRustcompiler
So what is not "safe" byRuststandards?  The list of not-safe behaviors
include using pointers after they are freed, dereferencing NULL pointers,
freeing memory twice, using the contents of uninitialized memory,
out-of-bounds memory accesses, data races, and more.  None of these things
will happen, he asserted, in safe sections ofRustcode; that is why he
wants to seeRustcode in the kernel.  About 70% of published C
vulnerabilities result from undefined behavior, he said, and the rate for
vulnerabilities in the Android media and Bluetooth components is closer to
90%.Rustcan help make those problems go away.Rustoffers a number
of other advantages as well, including stricter types, modules, pattern-matching
primitives, lifetimes, an extensive set of development tools, and much more.
From: Alan SchmittTo: "lwn", "cwn", caml-list@inria.fr
Subject: Attn: Development Editor, Latest OCaml Weekly News
Message-ID: <87eea08qok.fsf@m4x.org>
Date: Tue, 07 Sep 2021 15:23:55 +0200

Hello

Here is the latest OCaml Weekly News, for the week of August 31 to
September 07, 2021.

Table of
Rust( https://blog.torproject.org/announcing-arti ). Thanks to funding from Zcash Open Major Grants
(ZOMG), we can finally put the Arti project up in our priorities list!

We meet every two weeks to discuss development progress, and all meetings are open to the public,
plus recordings are uploaded to our YouTube channel:
 https://www.youtube.com/playlist?list=PLwyU2dZ3LJErozq7cT... 

If you're interested in contributing to Arti, get started here:
 https://gitlab.torproject.org/tpo/core/arti/-/blob/main/C... 

// ISO: Tor Bridge Operators //

Bridge relays ( https://support.torproject.org/#censorship-7 ) are Tor relays that are not listed in
the public Tor directory. Bridges are useful for Tor users under oppressive regimes that have
blocked access to the regular Tor network, because they help those users circumvent that
censorship.

We need your help to run more bridges! Bridges are relatively easy and low bandwidth to operate,
but they have a big impact on people impacted by internet censorship. By running a Tor bridge, you
help people bypass censorship to browse freely and privately.

Learn how to set up a bridge today with our easy step-by-step guide:
 https://community.torproject.org/relay/setup/bridge/. 

// New Releases //

Tor Browser 11.0a5
 https://blog.torproject.org/new-release-tor-browser-110a5 
(August 24) This version updates Tor to 0.4.6.7 that includes
Linux<el-errata@oss.oracle.com>  
   To : 
                 el-errata@oss.oracle.com  
   Subject : 
                 [El-errata] ELSA-2021-3063 Moderate: OracleLinux8rust-toolset:ol8 security, bug fix, and enhancement update  
   Date : 
                 Thu, 12 Aug 2021 07:04:23 -0700  
   Message-ID : 
                 <61152a67.xfgMW08dkbG0IBTn%keshav.sharma@oracle.com>  
  OracleLinuxSecurity Advisory ELSA-2021-3063

 http://linux.oracle.com
RustToolset linked in the References
section.

4. Solution:

For details on how to apply this update, which includes the changes
described in this advisory, refer to:

 https://access.redhat.com/articles/11258 

5. Bugs fixed ( https://bugzilla.redhat.com/ ):

1949194 - CVE-2021-28875rust: heap-based buffer overflow in read_to_end() because it does not
validate the return value from Read in an unsafe context
1949198 - CVE-2021-28876rust: panic safety issue in Zip implementation
1949204 - CVE-2021-28877rust: memory safety violation in Zip implementation for nested iter::Zips
1949207 - CVE-2021-28878rust: memory safety violation in Zip implementation when next_back() and
next() are used together
1949211 - CVE-2021-28879rust: integer overflow in the Zip implementation can lead to a buffer
overflow
1950396 - CVE-2020-36323rust: optimization for joining strings can cause uninitialized bytes to be
exposed
1950398 - CVE-2021-31162rust: double free in Vec::from_iter function if freeing the element
panics

6. Package List:

Red Hat Developer Tools for Red Hat EnterpriseLinux
difference. Maybe the vision is possible withRustand modern software engineering. Assuming the problem is actually real enough. How often doeslinuxcatch fire, by the way? The only problem I have on my servers is OOM, and that's rare and it seems to be getting fixed.
Rustwill let you write: 
 
let x = std::fs::File::open("/some/file/name.extension")?; 
 
You can write a LOT of code with this and never realise non-UTF8 filenames can even exist, you never use one. But, if you know perfectly well the file has some crazy non-UTF8 name, you can write it as an OSStr by whatever means and open() that instead sinceRustknows how to deal with that. OSStr is a type designed to allow whatever insanity is expected by your operating system, so, arbitrary non-zero bytes forLinux
Rust. Thanks to
funding from Zcash Open Major Grants (ZOMG), we can finally put the Arti project up in our
priorities list, and devote more time to it.

Read more about why we're doing this project, what it means for Tor users and operators, where it's
going in the future, and how people can help:  https://blog.torproject.org/announcing-arti 


// Transparency, Openness, and Our 2020 Financials //
 https://blog.torproject.org/transparency-openness-and-our... 

Every year, the Tor Project completes a Form 990 and independent audit of our financial statements.
After completing standard audits for 2019-2020, our federal tax filings and audit are both
available. We upload all of our tax documents and publish a blog post about these documents in
order to be transparent.

Read full 2020 financial report at our blog:
 https://blog.torproject.org/transparency-openness-and-our... 


// Upcoming Events with Tor //

II Seminário Criptografia, Política e Direitos Fundamentais | August 5, 2021
 https://blog.torproject.org/node/2058 

Free and Open Communications on the Internet (FOCI) workshop | August 27, 2021
 https://blog.torproject.org/node/2024 

// New Releases //

Tor Browser 11.0a2
 https://blog.torproject.org/new-release-tor-browser-110a2 
(July 20) This version updates Firefox to version 78.12.0esr on Windows, macOS, andLinux
LinuxEnterprise Module for Development Tools 15-SP3
                    SUSELinuxEnterprise Module for Basesystem 15-SP3
______________________________________________________________________________

   An update that solves one vulnerability, contains two
   features and has two fixes is now available.

Description:

   This update for git fixes the following issues:

   Update from version 2.26.2 to version 2.31.1 (jsc#SLE-18152)

   Security fixes:

   - CVE-2021-21300: On case-insensitive file systems with support for
     symbolic links, if Git is configured globally to apply delay-capable
     clean/smudge filters (such as Git LFS), Git could run remote code during
     a clone. (bsc#1183026)

   Non security changes:

   - Add `sysusers` file to create `git-daemon` user.
   - Remove `perl-base` and `openssh-server` dependency on `git-core`and
     provide a `perl-Git` package. (jsc#SLE-17838)
   - `fsmonitor` bug fixes
   - Fix `git bisect` to take an annotated tag as a good/bad endpoint
   - Fix a corner case in `git mv` on case insensitive systems
   - Require only `openssh-clients` where possible (like Tumbleweed or SUSELinuxEnterprise >= 15 SP3). (bsc#1183580)
   - Drop `rsync` requirement, not necessary anymore.
   - Use of `pack-redundant` command is discouraged and will trigger a
     warning. The replacement is `repack -d`.
   - The `--format=%(trailers)` mechanism gets enhanced to make it easier to
     design output
LinuxEnterprise >= 15 SP3). (bsc#1183580)
   - Drop `rsync` requirement, not necessary anymore.
   - Use of `pack-redundant` command is discouraged and will trigger a
     warning. The replacement is `repack -d`.
   - The `--format=%(trailers)` mechanism gets enhanced to make it easier to
     design output for machine consumption.
   - No longer give message to choose between rebase or merge upon pull if
     the history `fast-forwards`.
   - The configuration variable `core.abbrev` can be set to `no` to force no
     abbreviation regardless of the hash algorithm
   - `git rev-parse` can be explicitly told to give output as absolute or
     relative path with the `--path-format=(absolute|relative)` option.
   - Bash completion update to make it easier for end-users to add completion
     for their custom `git` subcommands.
   - `git maintenance` learned to drive scheduled maintenance on platforms
     whose native scheduling methods are not 'cron'.
   - After expiring a reflog and making a single commit, the reflog for the
     branch would record a single entry that knows both `@{0}` and `@{1}`,
     but we failed to answer "what commit were we on?", i.e. `@{1}`
   - `git bundle` learns `--stdin` option to read its refs from the standard
     input. Also, it now does not lose refs when they
that people with older hardware want to be sure that they kernel is safe. 
AsLinuxis considering addingRustas the second language, I guess someone has counted how many bugs it would help to avoid in the last X years. 
Does anyone know where such report is available?
The annualLinuxPlumbers Conference (LPC) is a gathering of a relatively
small subset of the developers working on the low-level (plumbing) details
ofLinuxsystems.  It covers topics from below the kernel through the user-space
components that underlie the interfaces and applications that mostLinuxusers interact with.  This year'seventwill be held
virtually September 20‑24; it is shaping up to be another
great edition of one of the premier open-registrationLinuxtechnical conferences on the
calendar.
Rust. Take of that what you will. We will see what kind ofRustcode you are going to find in theLinuxkernel.  
 
Hmm. Well, I found `parents_array` at least. Not *quite* sure why it needs to be specified there (possibly the length?), but type aliases would certainly
Rustcame onto the scene?  
 
How can you comment on this and the previous one with so much certainty if you have seemingly have not done your research? I obviously omitted a lot of information on Ada/SPARK. I am not supposed to sell it to you. That is not the point of the comment. I just wanted to know if Ada has been ever considered given that it is *perfectly suitable* for kernel development and is actually more safe thanRust(yes, it actually is, perhaps go through all of my links, then). To answer your question: they were actually working on it beforeRust. 
 
 > I think theLinux
Rust-like. The need for casts on the right and left side is also just weird…type deduction should make the left-hand type unnecessary (ignoring the unsafe-ness being presented). 
 
 > Plus, pointers are no longer an issue either:  https://blog.adacore.com/using-pointers-in-spark.   
 
Interesting how "cannot store pointers in structures" is considered suitable for "no longer an issue" in something like the kernel. That is still under active research and/or implementation by my reading of that post. And, withoutRust, Ada/SPARK might still be without pointers, so how would that have worked out beforeRustcame onto the scene? 
 
 > I would also like to add, that Ada has a package manager as well, namely Alire  
 
I think theLinux
Rustover Ada/SPARK?  
 
BecauseRustadvocates were willing to do the work (including the non-technical work of persuading the likes of Linus and Greg that their proposal is worthy of consideration at all), and Ada/SPARK advocates have apparently not been willing to do the work. 
 
Of course, I'd be surprised if the average Ada/SPARK advocate was interested in touching theLinux
A local root hole in theLinuxkernel, called Sequoia, wasdisclosed
by Qualyson July 20.  A full system compromise is possible until
the kernel is patched (or mitigations that may not be fully effective are applied).  At
its core, the vulnerability relies on a path through the kernel where
64-bitsize_tvalues are "converted" to signed integers, which effectively
results in an overflow.  The flaw was reported to Red Hat  on June 9,
along with a localsystemd
denial-of-service vulnerability, leading to a kernel crash, found at the same time.
Systems with untrusted local users need updates for both problems applied as soon as
they are available—out of
an abundance of caution, other systems likely should be updated as well.
Descriptorless files for io_uring:
  file descriptors are at the core of many things inLinux— except
  possibly when using io_uring.
Rustmight have more "mut"s. 
 
The thing that surprises me the most is how different it looks from C. For example I couldn't follow how the irqchip can be used from C code, all I could see is an implementation of irq::Chip. 
 
That on one hand means that the bindings are idiomatic, on the other hand it means theLinux
rustis too modern and still 
rapidly developed. 
 
I like both languages. I had developed applications in C for over 5 years as a 
professional job. And nowadays I feel fun writingrustcode and I am a 
maintainer of redBPF which isrustlibrary for eBPF. 
 
I knowrustis suitable for doing low-level stuff while providing memory 
safety. But I don't want to convince other developers to use it. It's a too 
different language from C. And I don't consider developers already satisfied 
with C want other modern languages. It's really hard to prove thatrustwill 
bring great advantages to theLinux
Linuxstyle requires the open brace of the function to be on it's own line, there be a blank line after a function's variable declarations, and often a blank line before the return statement. TheRustcode is also using 4 char indents and ignores the line
Linuxdominates the desktop with such attitude? 

 In the universe where I live it's market share  is about 2-3% for last two decades .  Precisely  because of that toxic attitude. 

 Linus kernel, on the other hand, which is religious about that… it's ubiquitous. Coupled with non- CADT  software it powers phones, robots, routers and almost anything you can imagine… except desktop. 

 If program worked then it must continue to work! Compiler, operation system and so on are, for the majority of people, are  only enablers  — their raison d'être is the need to have tools to run certain program or programs, they are useless on their own. 

 Sometimes said program doesn't even have sources and then quality of the compiler doesn't matter, of course, but if source  is  there then the  last  thing user wants to hear “this is incorrect program, you have to fix it”. Excuse me? How is it incorrect when I used it before and it worked? And I can still use it… except if I use  broken  new compiler. 

 Except in C/C++ land that obvious idea transformed into something completely crazy: if new version of compiler couldn't compile that old code
Rust"cargo" definitely is not trying to "reimplement the distro package repository". Distro-packaged libraries come nowhere near cargo's capabilities --- e.g. feature selection, library version selection, the ability to substitute patched versions of libraries, the ability to run multiple versions side by side, the ability to publish libraries whenever you want and use them in any project immediately regardless of whatLinux
Linux-next is the possiblity (precisely because there are no expectation that anything from there will ever land in mainline… it's there specifically to see if that would make sense or not).  
 
This is a very strange description oflinux-next. In factlinux-next is the repo where features are put that are expected to go into mainline. Of course it is not sure that they actually do. But the expectation is there. Solinux-next might be a good idea, especially if it is planned to merge these things into mainline. 
 
 > But mainline? Don't hold your breath. The chances are high (99%) it wouldn't land there before few years in some kind of distribution (Android, ChromeOS, maybe Arch or Fedora).  
 >Linuxdevelopers have become more strict over years about what they merge if it may effect more than people who directly touch that stuff. AndRust
Linux-next  is the possiblity ( precisely  because there are no expectation that anything from there will ever land in mainline… it's there specifically to see if that would make sense or not). 

 But mainline? Don't hold your breath. The chances are high (99%) it wouldn't land there before few years in some kind of distribution (Android, ChromeOS, maybe Arch or Fedora).Linuxdevelopers have become more strict over years about what they merge if it may effect more than people who directly touch that stuff. AndRust
Rust) and less incentive for upstreamRustto stabilize the features we need in the kernel (which could imply increasing the total time until the features are actually stabilized). 
 
In the end, if we are going to haveRustin the kernel, at some point we need to bite the bullet. And, in any case, if this disrupts your distribution that much, you are free to wait on your side until you can enableRustsupport -- nothing forces you to enable it right away. You can take the time to figure out how you want to support it. 
 
 > That's probably what I will do. But I think that's worse for the effort, since now there are fewer testers.  
 
Testers are definitely welcome, but please note that theRustsupport, even if merged, is experimental and needs work in several fronts (as noted in the cover letters) and thus testers should not be general users of aLinux
Linux.  The
  compiler, standard library, `dune' and `merlin', all work flawlessly
  on Windows. OPAM is not 100% ready yet on Windows (we don't use it)
  but it has never been easier to work "monorepo" style using `dune'.

  For beginners the main stumbling block is setting up the dev
  environment (C toolchain + Cygwin). OnLinuxinstalling a C toolchain
  is not needed because the compiler is installed by default, but this
  is not the case on Windows. As for Cygwin, it is strictly speaking
  only necessary when building the compiler itself. Once the compiler is
  installed you are free to never use Cygwin again…

  So if you want aRust
Rust): 
 > I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships. 
 Which is version of that one from The Mythical Man Month (that one is half-century old, as you know): 
 > Show me your flowchart and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowchart; it'll be obvious 

 Also: most ideas whichRustenforces mirror what so-called “modern C++” (with  owners  and  ownership passing ) and, surprisingly enough, “modern kernel C” proposes with it's  sparse tool , ownership trees and other such things. 

 Also: very small, very limited “fuzzing with coverage” finds so many violations of these rules in most large codebases (like Chromium orLinux
Rusthas already today" (e.g. a hypothetical C++ 23) this is not Undefined Behaviour, like inRustyou get two's complement arithmetic and so the assert survives the removal of redundant code and fires if you overflow. 

 This was proposed and rejected. Apparently benchmarks are sacred. Thus it's not happening. 

 Well… it may happen if people would start abandoning C/C++ ship and switch toRust(and other languages). But if that would be massive enough movement to make C/C++ committees actually care… then I think it wouldn't matter anymore. So don't expect anything like that any time soon. 

 > They produce programs with good performance characteristics. 

 They turn working programs into broken ones. Once you pass that threshold “performance characteristics” become secondary concern. 

 > What can we say about the compiler which turned my incorrect program into a binary which gave one result, versus a different compiler which turned my incorrect program into a binary with a different result? Nothing whatsoever. 

 What can we say about compiler which produces mathematically  impossible result ? Function which takes an integer and the returns  b || !b  should always return true. Any mathematician would say so and even just someone
Linuxkernel will for the foreseeable future have tonnes of C code in it, which likewise you can call from unsafeRustand might do anything, but hopefully even theRustsceptics don't blameRustfor that. 
 
I was only making claims about what the unsafeRustitself
Rustcode still compile and run in 30 years? For theLinuxkernel this is a very real concern. This is a test that I do not believeRustcan reasonably pass.Rustis making very hard guarantees about backward compatibility. Thus I would guess that the chances of compiling
Say what you will, but will currentRustcode still compile and run in 30 years? For theLinuxkernel this is a very real concern. This is a test that I do not believeRustcan reasonably pass.
Linuxkernel. ReadingRusthurts my head about as much as reading C--the former because the language is unfamiliar; the latter because there are booby traps everywhere. 
 
 > If you're used to cook your own meals from good raw products and suddenly someone replaces them with industrial
rustdevelopers than C developers in the world, even less skilled ones that are able to code safely, to review code and to help fix issues. How long will we have to insist on "we have a bug here" when we'll repeatedly get in the face "no it's not possible it's in a safe section,rustdoesn't have such class of bugs, find something else" ? 
 
An operating system has to deal with hardware bugs, CPU bugs, datasheet bugs, compiler bugs, API bugs, some of them having no effect until someone figures a way to exploit them for fun (e.g. spectre). The currentlinux
Rustgoes into mainline, of course.  
 
This feels a bit like putting the responsibility on the wrong actors... Not depending on unstable compiler features should be (IMO as a distro maintainer who doesn't want (or have time) to maintain oneRusttoolchain for each kernel release - we ship all supported kernel releases) a requirement for being merged at all. Saying this minimal requirement can be achieved more easily if the work is accepted into the kernel in a manner completely unsuitable for distribution usage makes it seem like the responsibility is onLinux
whatever) of _existing_ code.  Rewrites are _very_ expensive. 
 
Back on-topic, the big question I have about "RustinLinux" is how the conceptual differences between the C preprocessor andRust's macros are handled.  Given how heavilyLinuxrelies on cpp, this is IMO a significant question.
years of experience.Rust, for me, is an embodiment of these lessons. 
 
I'm not one of those obnoxious advocates who are going to pushRusteverywhere, but it would be really nice if projects likeLinuxfound a way to include it and made it work for their purposes.
Linuxkernel, where you gradually add features to C and remove features from C and update the kernel accordingly until you have something with the benefits ofRust. That would be more incremental than writing new kernel components inRust, in some sense, and perhaps be more palatable because all along
rust?" 
 
Good morning! 
 
This is entirely MY point of view, and MY context. 
 
The company I work for is building machinery. There are a several components running a very smallLinuxsystem inside. 
We work hard on providing all sources to fulfill our obligations with respect to all involved
linuxkernel is not just a memcpy() implementation, it does a huge amount of controls that must be safe in their logic. And based on all the patches that I've seen posted, it seems particularly hard to quickly grasp a missing or misplaced check. 
 
Overall I'm a bit irritated by all the marketing around the use of the "safe" word. I tend to consider a lot of C code as "safe" because it trivially translates to machine code. I haven't seen safeRust
Rustcode for its subsystem, such maintainer will need to not only learnRust, but will also need to become an expert on it.  
 
That's exactly it. To put it blunt, the discussion is important because it's more a matter of replacing people than a new way to write code. And it's totally natural that those having done their work meticulously for so many years to make whatlinux
want to read about. Consider that theRustinLinuxsession atLinuxPlumbers last year was the most attended session at the conference. 
 
Put that together with it being a substantial change to the way people work, which also makes it interesting to read about and talk about the implications.
thank you! On top of thatRustmay bring new developers toLinuxkernel who would not touch it otherwise.Rustis a marketable programming language, C is legacy. Switching from any modern programming language to C feels like going to a minefield. Even more so when going from userspace to kernel development.
Rust. The original motivation forRustwas that Mozilla were fed up with C++ bugs. That's C++, where you have RAII types that clean up for themselves. In kernel style C code, with gotos for cleanup, the potential for bugs is greater and is putting a huge burden on developers. To this end there have been efforts like Sparse [1], originally written by Linus Torvalds, but I'd question whether heavily annotated C code aiming at emulatingRustis just a poor man'sRust- why not put the same energy into just supportingRust? 
 
For some concrete examples of the problemsRustsolves from myLinux
Linuxenvironment. Their effort might be rejected because they end up not meeting the reasonable entry criteria. And that is not relevant. 
 
What is relevant is that they have a goal that is quite different to most other improvement efforts, and believe in it enough to spend resources (time, money, etc). And if they fail, then that failure will inform future efforts, including languages other thanRust
I don't remember if it was brought up already, but does thisrustthing especially if used for subsystems, implies that bunches of old architectures won't be supported byLinux?Rustonly supports small handful of arches afair.
The theme ofRustproving itself was also present in a thread on the ksummit-discuss mailing
list.  At the end of June, OjedaproposedRustforLinuxas a technical topic for the Kernel Summit track at this
year'sLinuxPlumbers
Conference.  On July 6,  Linus Walleijreplied, 
agreeing that it was a topic that should be discussed.  He noted that there
are already quite a few languages that kernel developers need to be
up on (e.g. C, assembly, Make, Bash, Perl, Python, ...), so a question in
his mind is whatRustwill bring to the table that makes it worth adding to
the list.
RustforLinuxredux: support for
  writing kernel code inRustis getting closer to merge-ready, but the
  development community is not yet fully sold on the idea.
Linuxin practice). The ftruncate()-based scenario is only somewhat interesting because it might seem like it only changes the file metadata, but in fact the data in the truncated tail also changes (as observed by mmap() users). 
 
To be clear, the same behavior within the last page of the file is already possible with current kernels: ftruncate() that doesn't remove the last page completely will look like filling its remainder with zeros (though it's also formally unspecified). 
 
So, overall, I don't see how MAP_NOSIGBUS would help with unsafety ofRust
> Not every system is an overcommit system. Windows isn't.Linuxwith vm.overcommit_memory=2 isn't either.  
 
Yes, that's why I included the footnote about the OOM killer being out of scope. It's not part ofRustin the first place.
Linuxwent with the no-mandatory-file-locking model, that length can change at any time, regardless of whether you're usingRust, C, or a magnetic needle and a steady hand. If you want to end up with a "safe" object, you need it to not get suddenly
allocation and require the application to handle an OOM condition explicitly.  
 
Not every system is an overcommit system. Windows isn't.Linuxwith vm.overcommit_memory=2 isn't either.  
 
Anyway,Rustwouldn't be having this problem at all if it had just adopted exceptions for error handling.
Ojeda isworkingon theRustforLinuxproject, which welooked atback
in April; hesaidthat he has also been working on a bot:
TheLinuxkernel is at the heart of the modern Internet, from
servers to client devices. It’s on the front line for processing network
data and other forms of input. As such, vulnerabilities in theLinuxkernel
can have a wide-ranging impact, putting security and privacy for people,
organizations, and devices at risk. Since it’s written largely in the C
language, which is not memory-safe, memory safety vulnerabilities such as
buffer overflows and use-after-frees are a constant concern. By making it
possible to write parts of theLinuxkernel inRust, which is memory-safe,
we can entirely eliminate memory safety vulnerabilities from certain
components, such as drivers.
Linux(as long as you have a
  fairly recent kernel. Otherwise the kernel crashes).  We also have a
  [Grand Central Dispatch effect backend] to give us a totally different
  execution model to exercise our effect handler abstractions.

  While we won't publish the performance numbers for the effect-based IO
  this month, you can get a sense of the sorts of tests we are running
  by looking at the [retro-httpaf-bench] repository, which now has
  various permutations of effects-based, uring-based and select-based
  webservers. We've submitted a talk to the upcoming OCaml Workshop
  later this summer, which, if accepted, will give you a deepdive into
  our effect-based IO.

  As always, we begin with the Multicore OCaml ongoing and completed
  tasks.  The ecosystem improvements are then listed followed by the
  updates to the Sandmark benchmarking project. Finally, the upstream
  OCaml work is mentioned for your reference.  For those of you that
  have read this far and can think of nothing more fun than hacking on
  multicore programming runtimes, we are hiring in the UK, France and
  India – please find the job postings at the end!


[eio library] < https://github.com/ocaml-multicore/eio >

[ocaml-uring
Linuxstack in one go inRustis stupid. 
 
Rewriting small pieces of it one-by-one is perfectly fine. It's exactly the small gradual refactoring that we need. 
 
For perspective, coreutils is around 70k lines of code in C. This is not a huge project by any means
Rustinto projects with massive user bases likeLinuxand Android is yet another evidence of growing large scale adoption by multiple companies across many different industries.  This is the only realistic way you are ever going to see adoption of any new(er) language.  It won't be massive
Rustisn't used anywhere at Google. <shown uses> 
  - Oh, it's being looked at forLinuxdrivers, that's meaningless at the scale of Google. 
 
As if on day 1 there has to be millions of lines of code for it to be meaningful
100B of lines of C++ by now (I don't have updated numbers). In comparison, theLinuxkernel with its ~30M LOC is a drop in the ocean; assigning one or two engineers onto looking at the prospect of maybe writing device drivers inRustone day, even more so.
> That's precisely the kind of small-scale adoption I was talking about. Nothing at scale, no big rewrites, hyped by the media.  
 
Which media?  Also, integratingRustintoLinuxkernel and Android isn't exactly what I would consider small-scale.
There are a bunch of efforts.  The one with the widest impact is their efforts to integrateRustintoLinuxkernel and Android 
 
 https://security.googleblog.com/2021/05/integrating-rust-...
Linux.Linuxalready contemplatesRust, too. 

 > Modern C++ practice, writing at a level of abstraction that confines risky operations to trusted libraries, is another. 

 Modern C++ is unsitable. You can't write safe software using it. Simply because you never know how and when code style would be retroactive
Rustdoesn't  that explains one route that could be taken to dynamic linking inRustwithout losing too much of theRustbenefits.
 Ultimately, though, we're at the "needs an innovation" stage - dynamic linking is built around the idea that compilation takes a single independent unit of source and turns it into complete object code with unresolved symbols. Linking then resolves all the symbols to get an executable binary. In that model, dynamic linking is a big win; there's a clear divide between the single units of source and the symbol resolution.
 Modern languages (C++,Rust, Swift, Go and others) are not as amenable to this model; units of source code are not independent any more, because the use of generics and vtables both mean that inlining and specialisation of the inlined code is a huge win and thus we want to either have huge units of source (entire programs, say), or we want the link phase to do significant compilation effort, possibly changing the units that it has on disk.
 Note thatRustis, in a very technical and useless sense, dynamically linked onLinux
Rustcompiler permits is encouraged by neglect as part of the Holy Mission to driveRustinto universal enterprise use. ("Rewrite It inRust" has lately been repudiated as official policy ofRustadvocacy, for reasons, but uutils seems to have missed the memo.) 
 
When bugs do trap, such as array indexing errors, the resulting panic cannot be presumed to clean up properly before exiting. This sort of thing is hard to get right, and only comes with maturity. Coreutils probably still have bugs of their own, but they are manifestly bugs we have found we can live with. 
 
All of the core utilities, and many others, could be switched over to build with a C++ compiler and then incrementally modernized with overwhelmingly smaller effort than a wholesale rewrite, at much less risk of introducing new bugs, and without abandoning those targets LLVM poorly serves. No Holy Mission drives such activity, so we see it happen with resounding success in Gcc and Gdb, but not yet in less active projects, or in more hidebound ones like PosgreSQL, SQLite, Git, Systemd, the BSDs, orLinux
would imagine is the rapid adoption ofRustand willingness to adopt new features and taking advantage of new capability in theLinuxkernel.  GPL has been falling out of favor for many of these new projects for other reasons and that is not a new trend 
 
 https://redmonk.com/sogrady/2017/01/13/the-state-of-open-...
Incidentally or not, they all are written inRust. 
I'm looking forward to coreutils rewrite. Using all theLinuxkernel features and all the CPU cores would be nice. It's 2021, we do not need code to support AIX from the '80s of the last century.
As movement toward memory-safe languages, andRustin particular, continues to
grow, it is worth looking at
one of the larger scale efforts to port C code that has existed for decades
toRust. Theuutils projectaims to
rewrite all of the individual utilities included in theGNU Coreutilsproject inRust. Originally created by Jordi
Boggiano in 2013, the project aims to provide drop-in
replacements for the Coreutils programs, adding
the data-race protection and memory safety thatRustprovides.
LinuxEnterprise Module for Server Applications 15-SP2
______________________________________________________________________________

   An update that fixes one vulnerability is now available.

Description:

   This update for 389-ds fixes the following issues:

   - CVE-2021-3514: Fixed a sync_repl NULL pointer dereference in
     sync_create_state_control() (bsc#1185356)

   389-ds was updated to version 1.4.3.23~git0.f53d0132b:

   Bump version to 1.4.3.23:

   * Issue 4725 - [RFE] DS - Update the password policy to support a
     Temporary Password Rules (#4727)
   * Issue 4759 - Fix coverity issue (#4760)
   * Issue 4656 - Fix cherry pick error around replication enabling
   * Issue 4701 - RFE - Exclude attributes from retro changelog (#4723)
     (#4746)
   * Issue 4742 - UI - should always use LDAPI path when calling CLI
   * Issue 4667 - incorrect accounting of readers in vattr rwlock (#4732)
   * Issue 4711 - SIGSEV with sync_repl (#4738)
   * Issue 4649 - fix testcase importing ContentSyncPlugin
   * Issue 2736 - Warnings from automatic shebang munging macro
   * Issue 2736 -  https://github.com/389ds/389-ds-base/issues/2736 
   * Issue 4706 - negative wtime in access log for CMP operations

   Bump version to 1.4.3.22:

   * Issue 4671 - UI - Fix browser crashes
   * lib389 - Add ContentSyncPlugin class
   * Issue 4656 - lib389 - fix cherry pick error
   * Issue 4229 - FixRust
linux"hang": gui/terminal not respond to any key in reasonable time/ ssh timeout ,you can't kill bad app, anything you're doing just makes it slower. you may wait it for hours (or forever) to restore, or just hard reset. I've hit such problems multi times.  
Windows XP and spinningrust
linux-restricted-modules-gcp 5.8.0-1032.34 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 *linux-meta-gcp 5.8.0.1032.32 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * pillow 7.2.0-1ubuntu0.3 -  https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * python-babel 2.8.0+dfsg.1-4ubuntu0.1 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * linux-gcp_5.8.0-1032.34_amd64.tar.gz -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * livecd-rootfs 2.694.5 -  https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * google-compute-engine-oslogin 20210429.00-0ubuntu1~20.10.0 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * ceph 15.2.11-0ubuntu0.20.10.2 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * sosreport 4.1-1ubuntu0.20.10.2 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * python3.9 3.9.5-3~20.10.1 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * fabric-manager-460 460.73.01-0ubuntu0.20.10.1 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * fabric-manager-450 450.119.04-0ubuntu0.20.10.1 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 *linux-meta-raspi 5.8.0.1025.28 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 *linux-raspi 5.8.0-1025.28 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * grub2-unsigned 2.04-1ubuntu44.2 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * libnvidia-nscq-460 460.73.01-0ubuntu0.20.10.1 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * libnvidia-nscq-450 450.119.04-0ubuntu0.20.10.1 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * grub2-signed 1.167.2 -  https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * nvidia-graphics-drivers-460 460.80-0ubuntu0.20.10.2 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 
 * nvidia-graphics-drivers-450-server 450.119.04-0ubuntu0.20.10.2 -
 https://lists.ubuntu.com/archives/groovy-changes/2021-May... 

End of life: July 2021

=== Ubuntu 21.04 Updates ===

 * intel-microcode 3.20210216.0ubuntu0.21.04.1 -
 https://lists.ubuntu.com/archives/hirsute-changes/2021-Ma... 
 * intel-microcode 3.20210216.0ubuntu0.21.04.1 -
 https://lists.ubuntu.com/archives/hirsute-changes/2021-Ma... 
 *linux-riscv 5.11.0-1009.9 -
 https://lists.ubuntu.com/archives/hirsute-changes/2021-Ma... 
 *linux-meta-riscv 5.11.0.1009.22 -
 https://lists.ubuntu.com/archives/hirsute-changes/2021-Ma... 
 * linux-kvm_5.11.0-1008.8_amd64.tar.gz -
 https://lists.ubuntu.com/archives/hirsute-changes/2021-Ma... 
 *rust
Rustis a systems programming language that runs blazingly fast, prevents
segfaults, and guarantees thread safety.

The following packages have been upgraded to a later upstream version:rust(1.49.0). (BZ#1896712)

Security Fix(es):

*rust: use-after-free or double free in VecDeque::make_contiguous
(CVE-2020-36318)

*rust: memory safety violation in String::retain() (CVE-2020-36317)

For more details about the security issue(s), including the impact, a CVSS
score, acknowledgments, and other related information, refer to the CVE
page(s) listed in the References section.

Additional Changes:

For detailed information on changes in this release, see the Red Hat
EnterpriseLinux
Linux21.5 was released
with an even larger amount of supported, 18 pre- and cross-compiled
set of architectures ever: alpha, arm, arm64, hppa, ia64, m68k,
mips64, mipsel, ppc, ppc64-32, ppc64le, riscv, riscv64, s390x, sparc64,
superh, x86, and x86-64.

Major performance improemvnts were implemented, including: not yet
upstream x86 concurrent TLB flushing, faster in-kernel zstd update as
well as smarter (profile guided Os vs O3) whole system optimizations!

The 21.5 release received updates across the board, while a major
point of work was the GCC 11 update as well as re-basing and fixing
upstream regressions for the Sony PS3 support as well as various small
improvements, including an up to 15 seconds faster system shutdown when
using sysvinit.

All 18 official ISO images are fully cross compiled! Over 224 Subversion
revisions, of which many are now AI updated by our nightly package bot
we named “Data” ;-)

Usually most packages are up-to-date, includingLinux5.12.4, GCC
11.0, LLVM/Clang 12, as well as the latest version of X.org,
Mesa, Firefox,Rust
ISRG is targeting several different improvements to Rustls as part of
Ochtman's work, including working toeliminate functions that
panic, which effectively cause the program to crash.  As theRustdocumentationpoints
out, usingpanic!()precludes callers from recovering from an
error, which is probably not appropriate in a lot ofRustcode.  The
presence of panics in theRustcode making its way toward theLinuxkernel washighlighted as a problemby
Linus Torvalds as part of his review.  The Rustls project is working toward eliminating
panics in its own code as well as eliminating calls into library routines
that might panic, so that it provides a panic-free API for applications.
Rustyet for some dozen years because it's a young, unstandardized, and unproven language without a second compatible implementation. As such it's uncertain whether or not future revisions of the implicitRustlanguage semantics necessitate changes to theRustparts ofLinux. One would hope that
LinuxKernel Style is outdated whether compared toRustor not. This is to be expected of a thirty year old code base started when ANSI C was still a tad moist behind the ears. Since then there have been two significant standard revisions, both introducing various syntax and library
If the result of the exercise is that a typical device driver will
	 contain more unsafe code than not, then device drivers are not a
	 good starting point forRustin theLinuxkernel.  In that case I
	 would recommend thatRuststart at a point where there is a lot of
	 abstract code that is prone to the kind of problems thatRustis
	 trying to solve. My intuition would be such things as network
	 protocols. But I may be wrong.
LinuxEnterprise Module for Packagehub Subpackages 15-SP3
                    SUSELinuxEnterprise Module for Packagehub Subpackages 15-SP2
______________________________________________________________________________

   An update that solves one vulnerability and has one errata
   is now available.

Description:

   This update for librsvg fixes the following issues:

   - librsvg was updated to 2.42.9:
     * Update dependent crates that had security vulnerabilities: smallvec to
       0.6.14 - RUSTSEC-2018-0003 - CVE-2018-20991 (bsc#1148293)
   -the bundled version of the cssparser crate now builds correctly onRust
Rustisn't. For example when you ask Cargo for a newRustprogram, the one you get says "Hello, World!". But Wuffs can't do that. Because that would involve I/O and Wuffs deliberately doesn't have I/O at all, it considers that to be orthogonal to its concerns entirely. 
 
It is good for these special purpose languages to exist, particularly when they address some difficult and interesting problem such as "Wrangling Untrusted File Formats Safely". I should like to do this sometimes, and apparently Wuffs would help. But if my current problem is that my USB Foozle doesn't work, an "untrusted file format" is only at best a tiny fraction of my problem and Wuffs isn't interested in helping me with the rest of it. Whereas perhaps I can write a driver for the USB Foozle inRust. 
 
Today I can write a _userspace_ USB driver inRust. Maybe my Foozle can be driven that way. IfLinux
Rustare implemented as Traits. 
 
So things you can Add have an implementation of add() such that the result of the function is the same type as the left hand side - andRustwill call that when you use the + operator. String implements add (using the allocator implicitly). Because the result must be the same type, you can't get a Result back and so we can't have allocation which might fail. 
 
Presumably we should not like to have this implicit allocation in theLinux
have to decide how much language and compiler work to do before you really push onRustbeing used in theLinuxkernel --- because before you do the latter, you will need to settle once and hopefully for all the idiomatic way to handle Errno results for various common T types.
Linuxkernel quality very seriously today. Let me (re)raise a few suggestions that will help, which are standard practice in other projects: 
 
Use a system for tracking bug reports (especially regressions) that is more reliable than "email LKML and hope it gets noticed and not forgotten". 
 
Expect every submitted code change to come with an automated test (that is run before any release), or an explanation as to why such a test is infeasible. Create test frameworks to systematically reduce occurrences of the latter case. 
 
Enthusiastically adoptRust
Rustin the kernel will enable allRustdevelopers to become kernel developers.  
 
Sorry but this is exactly how I understood it: make it easier to write drivers (implicit "forrustdevelopers" as not everyone is fluent in it and even those used to it say the learning curve is pretty steep). 
 
 > The main goal ofRustin the kernel is to make the kernel code better, not to attractRustfans and newcomers.  
 
Better in terms of what ? Maintainability, with only 1% of kernel developers being able to review and fix that code instead of the previous 100% ? Ease of use, with everyone having to install two separate toolchains, some combinations of which will possibly cause trouble that will have to be detected and rejected ? Portability, with a number of existing architectures not even being implemented by the language ? Fame and ego forrustfanboys for having won a victory overLinux
rustones because the libs themselves will not be safer than the example above and will not be audited by those who area used to deal with operating system issues. 
 
It could very well be thatLinuxis the last project adoptingrustin the end... That's a dangerous
Linux's C code. There area tons of READ_ONCE(), likely(), atomic_inc(), smp_rmb(), readb(), iowrite{8,16,32}(), div64_* etc everywhere that rely on asm and need to be applied not directly because of the language but because of the underlying hardware constraints, that make C code less easy to write.  
 
And ifRust
linuxkernel. When 1 out of 10 lines was in fact an inline function calling an asm statement it shows there were some limitations. I don't see howRustwill avoid this. There will be tons of "unsafe" blocks everywhere making the code very hard to read
block device driver intoRust4 years ago, and gave a talk atLinuxcon. 
 
 
So we've been working on it for a while now, including writing drivers. 
 
(Turns outRustwasn't quite ready back then, but the hard part is definitely the safe abstraction layer.)
Rustisn't "designed to write browsers".Rustis designed to be a general-purpose systems language for everything from kernels/firmware/embedded to browsers to WebAssembly. There is, by design, no "gap" between assembly andRust. 
 
In any case, one of the critical values of theLinux
Rust-for-LinuxusesRustin no_std mode which means libstd and liballoc are not linked in by default.  Only by explicitly defining a global_allocator ( https://github.com/Rust-for-Linux/linux/blob/9e6e67e06bdc... ) are they making use of liballoc right now and AFAIK this is to be removed in favor of custom, fallible
Rustcompiler ends up doing hidden allocations, and they then cause panics [...]  
 
In contrast to C++,Rustdoes not have such a thing as a core-language allocation primitive (like C++'s `new` operator).  As long as you don't link in the `alloc` crate, the is zero possibility for any kind of heap allocation to happen, much less a hidden one.  If I understood correctly, this is the routeRust-for-Linux
Rust's alloc library with different code more suited to theLinuxkernel seems like a good step, and it's something supported by the language just fine and is used in various situations already, it doesn't make the code any lessRust. I do hope
Rustcurrently uses the C11 memory model, Boqun Fengsaid, mostly
because the LLVM compiler supports it by default, but there is interest in
ensuring that its memory model works well with the kernel's. Right now, 
"there is no code requiring
synchronization between C side andRustside, so we are currently
fine", but that will change eventually, so
there are plans to put the rightRustand kernel people together to discuss
the issue.  Almeidanotedthat the
plan is for mostRustcode in the kernel to only need to be concerned with
theRustmemory model:
Linuxbox? If so, how? -
 https://ubuntu.com//blog/should-you-ever-reinstall-your-l... 
 * KubeCon co-located events: Operator Day is back! -
 https://ubuntu.com//blog/kubecon-colocated-events-operato... 

== In the Press ==

=== Taking control of your Ubuntu desktop ===

Sandra Henry-Stocker starts by commenting how mostLinuxdesktops "start out charmingly
uncluttered", then tells how we can view how our desktop is setup using a few commands and
exploring the contents of a few suggested files. This is a beginner introduction in understanding
some features of our desktop, and how we can make use of that to make some minor changes.

 https://www.networkworld.com/article/3614349/taking-contr... 

== In the Blogosphere ==

=== Canonical Publishes New UbuntuLinuxKernel Updates to Fix 20 Vulnerabilities ===

Marius Nestor alerts us to new kernels for Ubuntu 20.10, Ubuntu 20.04 LTS, Ubuntu 18.04 LTS, Ubuntu
16.04 LTS,  and Ubuntu 14.04 ESM systems. Marius provides details of the CVEs impacted by various
releases that have been fixed, with a reminder for us to update our installations as soon as
possible.

 https://9to5linux.com/canonical-publishes-new-ubuntu-linu... 

== Featured Audio and Video ==

=== Ubuntu Security Podcast: Episode 112 ===

"This week we look at a reboot of the DWF project,Rust
Rustprobably wouldn't exist. 
 
Certainly at this point I wouldn't try to argue that a project as large and complex asLinuxshould switch to C++ now that we haveRustas a viable alternative;Rustlooks like clearly the better choice to me. But an argument
Rust's safety claims come at a compile-time cost, but there is no reason why there should be a run-time performance cost.  
 
Let's consider, for example, index-is-in-bounds enforcement. 
 
A simple example (pseudocode): 
 > string idx2s(int inval) {  
 >     string vals[] = { "foo", "bar", "xyz" };  
 >     int idx = SHA256(int2str(inval))[0];  
 >  
 >     return vals[idx];  
 > }  
 
SHA256() here is a placeholder for any complex transformation. 
 
I don't see how one can enforce a perfect memory safety here without adding an extra bounds check on "idx" before accessing the "vals" array. 
Even though the programmer writing this function might have known that it will never be called with a value that would result in an out-of-bounds access. 
I don't see how one can guarantee absolutely no runtime performance impact of this extra check - especially that it is likely that there will be at least a few sites like this in a large program (whichLinux
Rustand C++ inLinuxkernel, not in user space. 
 
 > The reasonRustis a game changer is because it's a "quantum leap" for memory safety (hence security)  
 > _without_ any significant performance difference.   
 
What is an insignificant performance difference for one case might well
Rustaims much higher.  
 
That's absolutely a wrong analogy. 
 
First, both iPhone (I believe you refer to iP4 antenna problems in your "holding it right" comment) and cars are consumer products. 
They are designed to be used by minimally-trained or even untrained operators. 
 
Developing OS kernel code is definitely not something for general population or even beginner programmers to do. 
Kernel engineers are supposed to be highly trained people, more like a Formula One driver than your ordinary sedan driver. 
 
Second, while kernel crashes are unpleasant they don't kill or maim people - general purpose OSes aren't suitable for systems where human life is at stake. 
 
Adding these two together, and the huge number of devices that runLinux
Linuxplatforms. 
 
 > With python cornering itself behind the sole list of platforms supported byrustand betraying its users, we're certain never to ever see python 4.  
 
Python has done no such thing. The maintainers of cryptography may arguably have done this (I make no claim to either
rusthas a pretty clear opinion on this. A dereference of a raw pointer is never obviously correct. This rather hard judgement can of course not work in C++. According toruststandards almost every line in C++ is not obviously correct. 
 
 > > Then you will only have a few lines that have to be verified by humans.  
 > "A few lines" of unsafe code in an OS kernel?  
 > Even the current C code inLinux
rust, I can just take a pointer to the subobject, as long as the lifetime of the pointer to the subobject is contained in the lifetime of the whole object.  
 
It depends what do you specifically mean by a subobject. 
If it's like a class field then normally one does not provide a direct pointer to the field to an unrelated code but implements a specific interface and provides it instead. 
 
 > How complex should code be such that you think that one should actually verify correctness?  
 > People will disagree about the complexity that can be checked by humans.  
 
There is no "scientifically-correct" answer to that question, since it's mostly an individual opinion. 
One can simply identify obviously-correct code (like in my example) and treat any disagreement over this as an evidence that the code is not obviously-correct. 
 
 > Then you will only have a few lines that have to be verified by humans.  
 
"A few lines" of unsafe code in an OS kernel? 
Even the current C code inLinux
Rustis thatRustprovides memory safety by default. You can escape memory safety via "unsafe", but *only* those parts are unsafe. C++ doesn't provide memory safety, so C++ is no better than C if your goal is memory safety. TheLinuxkernel does unusually well
rustnot supporting alllinuxarchitectures, will we eventually get 
to a situation when there are two drivers for the same device, one inrust(written first) and second one in C (for the unsupported architectures)? 
 
Also this will mean that you will no longer be able to build kernel
Some of you have noticed the past few weeks and months that a
	serious attempt to bring a second language to the kernel was being
	forged. We are finally here, with an RFC that adds support forRustto theLinuxkernel.
From: Alan SchmittTo: lwn, cwn, caml-list@inria.fr, comp@lists.orbitalfox.eu
Subject: Attn: Development Editor, Latest OCaml Weekly News
Message-ID: <87a6q25xmp.fsf@m4x.org>
Date: Tue, 13 Apr 2021 11:42:22 +0200
Archived-At:Hello

Here is the latest OCaml Weekly News, for the week of April 06
Rust, Elixir, Ruby, etc.) with way too many options in the second group to support them all. 
 
In '98, it seems like there was Perl, Python, C, C++ and a few specialist languages. Sure, you could use Fortran, Pascal, etc., but they didn't really have any traction, and Java hadn't gained traction onLinux
Linuxdevs still give C++ a firm "No", while they're givingRusta cautious "Maybe". You shouldn't ignore that hint.  
 
We've had that discussion elsewhere.Linuxneeds a low-level language, and probably the best definition of such a language
counter-argument: being source-incompatible might actually be a good thing, as the clear demarcation between the C world and theRustworld could be more manageable than the fuzzy C/C++ demarcation. 
 
The jury is still out onLinux-Rust, butLinux-C++ looks like a well-beaten dead horse.
Rusttolinux-next are surely capable of it. 
 
The most difficult sources of incompatibility don't come from C99 initialisers 
(which can be rearranged) but from code like this: 
 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/...  
 
If someone knows how C++ people deal with macrology/features above, please tell me. 
 
Modules also have
Followers of thelinux-next integration tree may have noticed a significant
addition: initial support for writing device drivers in theRustlanguage.
There is some documentation inDocumentation/rust,
while the code itself is in therusttop-level directory.  Appearance inlinux-next generally implies readiness
for the upcoming merge window, but it is not clear if that is the case
here; this code has not seen a lot of wider review yet.  It is, regardless,
an important step toward the ability to write drivers in a safer language.
Rustthe same asLinux; there's only one completeLinuxkernel, but it's not exactly owned by any one company in particular. In theory, someone could buy out Linus and have the One TrueLinuxKernel, but in practice enough other people are involved that this is not a risk
Rusthas impressed me the most. They have delivered on much of what we set out to deliver with Midori, but actually shipped it (whereas we did not). My hat goes off to that team, seriously, because I know first hand what hard, hard, hard work this level of type system hacking is. [...] I trust their system more than ours, because they have shipped and had thousands of eyes and real-world experience applied to it.  
 
(and that was 5 years ago). 
 
If someone nowadays wanted to take the 'software isolated processes' concept into production, where safety is guaranteed by the language and verified by a small TCB and doesn't need to be enforced by expensive hardware,Rustsounds like a good place to start. (And would be nicer than just extendingLinux
Rustwith.
 The problem is that, having done this, they got several sets of responses (once you strip out the flames):
 
 Alpine users being tripped up because their CI wasn't expecting this dependency, and Alpine'sRuststory has only very recently stabilised.
 Debian users being tripped up because the early version needed a newerRustcompiler than Debian stable.
 Dr Glaubitz for M68K saying "I'll be OK with this in the future, but not just yet - please hold off while I get the M68KRuststory sorted out".
 Various people getting upset about "another dependency" to keep using the py-cy project.
 Gentoo's maintainer getting upset that Portage had a hard dependency on py-cy for all architectures, but they don't supportRuston all the architectures they claim to support Gentoo on.
 
 Of those, Alpine and Debian users got changes to help them out. I lost track of what happened with M68k in all the heat, but I think Dr Glaubitz is taking a reasonable approach, and I'd hope the py-cy upstream is giving him the time needed to sort out theRuston M68kLinux
Ruston M68kLinuxworking well) from people who aren't willing to put any work in to keep the C code in good shape.
 Fundamentally, it all boils down to who expects what from whom - and this episode has brought some implicit expectations people have that haven't been
linux). 
 
An analogy.  I decide to make a huge compost heap on my property, but right next to the fence with my neighbour and 3 meters from their bedroom window.  I am perfectly within my right to do this.  A court of law may even officially make a statement to that effect.  Yet, the relationship with my neighbour has gone sour because the stench, visuals and rodents are leaking into his house.  Now, the only way to not make the relationship sour is if I understand and accept when my neighbour explains to me that my actions are effecting him and then I, with my own power, move the compost heap someplace else.  No amount of screaming "I have a right to this" or "if you don't like it pay yourself to move it" is going to fix things.  This case is not entirely dissimilar. 
 
"never having another memory safety issue again."  
 
Is this truly an honest statement ?  As I understand it pycy didn't reinvent itself inrust
Rustfor code generation. Would you also accept the answer "Well, then go and maintain an old fork of LLVM yourself!"?  
 
EVERY piece of code you use from somebody else is a potential problem for you, each of those thousands NPM packages you have in node_modules/ is a reliability of your project, and you are responsible for doing something when it stops working for you. You did study all that code when including it to your project, the code which you effectively ship to your clients, right? 
 
And if you maintain code for s390 than you are not doing it for free (there are some things in the world, which people don't do for free; I will keep the list PG-13, but maintaining s390 software certainly belongs there). Either you switch to use some other cryptography library (hey, I am an upstream maintainer of M2Crypto!), fork pyca and keep updating it in the C-only form, or port LLVM to your platform. Choice is yours. And THAT is the choiceLinux
Linuxkernel development and make such drastic changes to the codebase that the kernel will only run on ARM and POWER devices. Would you also accept the answer "Well, then go and maintain an old fork of the kernel yourself if you need it for x86_64!"? 

 First of all, these things are incredibly unlikely to happen to a big project like LLVM or theLinuxkernel.  LLVM wants to maintain support for popular languages, andRust
Rustfor programming them. 
 
For obsolete enterprise hardware, not so much.  I can certainly see the value in preserving these for posterity like many other artifacts we save in museums, but in that case shouldn't you have the period-appropriate software on them rather than an up to dateLinux
Linuxecosystem software working well on Arm for decades, covering not just the kernel proper but also gcc, llvm, gdb,Rust, Fortran compilers, browser Javascript engines, Java, fixing build issues, scanning distro package archives for programs with inline asm that would benefit from having Arm versions of that asm, and a lot of other
Rustwasn't taken from anybody. It's just not being maintained.  
 
Imagine a hypothetical situation where the LLVM developers change their code in such a way that it can no longer be used forRustfor code generation. Would you also accept the answer "Well, then go and maintain an old fork of LLVM yourself!"? 
 
Or a big company like Google becomes in charge of theLinux
Rustisn't saying that "we support on any random x86_64Linuxsystem" -- instead they are saying "we test on x86_64-unknown-linux-gnu 64-bitLinux(kernel 2.6.32+, glibc 2.11+)" with the unspoken implication of "if you're not using
Memory barriers are an old acquaintance for someLinuxkernel programmers.
The first document vaguely resembling a specification of what one could
expect from concurrent accesses to data in the kernel is, in fact, calledmemory-barriers.txt.
That document describes many kinds of memory barriers, along with the expectations
thatLinuxhas concerning the properties of data and control dependencies.It also describes "memory-barrier pairing"; this could be seen as a cousin
of release-acquire pairing, in that it also helps creating cross-threadhappens beforeedges.
efficiently as in e.g. C or C++. But for the other 99 % of programs I write forLinuxI believe Go could be an alternative.  
 
 > better sticks to languages without runtime.  
 
Which leaves C, C++, and a lot of older/less common languages?Rust? 
 
I often use C but people always tell me that is wrong by definition ;-)
Rustcommunity. 
 
 > […] the language is still evolving and gaining features, for instance async/await which was not available in the version of rustc originally shipped with Debian (the situation has since changed).  
 
Yes, in other words, the language is still too immature for the projects of the size ofLinux
rustto another platform - can you, which is doing an actual port, please comment on that? (out of pure interest).  
 
If the new platform is just a newLinuxarchitecture, the port is pretty much straight-forward and easy provided that LLVM has a backend for the architecture. 
 
I cannot
Rustlibrary via a temporary Cargo [patch], and later submitted those changes upstream --- and had them accepted. The former step is indeed the path of least resistance and lets me make progress in my project. The latter step is justified because there is an ongoing maintenance cost to those patches, so reducing the number of them that we're carrying at any one time pays off long term.  
 
_This_ is "real" open-source: zero boundary between downloading/using/cloning/branching/forking/experimenting = complete freedom. This is why decentralized version control felt liberating. I would even argue that a project still stuck in centralized/medieval version control cannot really be considered open-source because of the added friction. And don't get me started on directories with sometimes long lists of *.patch files... never heard about branches? 
 
Configuring and building C/C++ code at large is a nightmare andLinux
Rustto your platform" and "you only need a C compiler and Posix environment to portRustto your platform". 
 
That said, the free software ecosystem has historically only roughly needed a C compiler to get perl, python, etc. which helped a lot various platform projects to get stuff working. 
 
If the bar is raised too much, the possibility of interesting projects lowers. 
 
If bash/gcc/gdb/etc. were not easy to port in early 90s, we would just not haveLinux
rustdependency, it's "just" a (pretty important) python package that is. Python *is* dropping support for the s390 platform, as support had already been dropped left and right, including in theLinuxkernel. 
 
IMHO the "dream of free software" is intact: all the tools
Linuxdevice driver. (I know there is work on usingRustin the kernel so in a few years this point might be less relevant.) 
 
Yet another reason is that I happen to know C quite well and can actually produce working code in reasonable time. So for a lot of quick
depend onrustbasically means excluding from the free software game any non-LinuxOS unless somebody takes up the daunting task of explaining the libc headers toRust, whileRustcould simply act like all other such languages (perl, python, haskell) do: just interpret the libc headers at configure time.
Rustis a pain.Rustcompilation is slow. ARustspecification would be a good thing. gcc-rustwould be a good thing. 
 
Bad points: 
 
 >Rustostensibly supports several dozen targets, but only the tier 1 platforms can be reasonably expected to work.  
 
This is an exaggeration. For example both Fuschia platforms are officially tier-2 but Fuschia itself usesRustcomponents, so presumably they work. x86_64-unknown-linux
Rustsupports the s390x as a Tier 2 platform, Gentoo just doesn't have packages for it yet. However,Rustdoes not support the s390 and neither hasLinuxsince 2015. Besides, if a company bought an IBM mainframe then they shouldn't be making *any* complaints about
rust.  
 
"All your libc headers" are not all architecture-specific, are they? Can you elaborate? 
 
 > > fringe platforms which can't even run aRustcompiler.  
 
I can't wait the next LWN article on the real issue: how much effort is this really. Plural starts at two so LLVM must have some solid architecture abstractions, no? 
 
 > >  The LLVM developers have been somewhat leery of taking on new architectures, unless they can be convinced there will be long-term support for them, which is understandable, but makes the problem even worse.  
 
This could/should start in an unofficial branch. Don't distributions routinely tweak toolchains already? This caused most C portability issues acrossLinux
The latest issue came up on the Gentoo development mailing list;  Michał
Górnynotedthat the Pythoncryptographylibrary
has started replacing some of its C code withRust, which is now required
to build the library. Since the GentooPortage package managerindirectly depends oncryptography, "we will
probably have to entirely drop support for architectures that are not
supported byRust".  He listed five architectures that are not
supported by upstreamRust(alpha, hppa, ia64, m68k, and s390) and an additional five
that are supported but do not have  GentooRustpackages (mips,
32-bit ppc, sparc, s390x, and riscv).
Some ideas that were discussed are not going to happen; these include
replacing elisp with JavaScript or some other "more modern" language.
Similarly, porting Emacs's C code toRustis not something to hold one's
breath for.  Other desired changes are more "socially easy", but are hard
technically; these include making elisp faster so that more of Emacs could
be written in Lisp rather than C.  Another is rewriting the Unix
graphical interface, which is fragile; small changes can break obscure
platforms in surprising ways.
Rustglog-0.4.0: Google Logging Library application-level logging
       rav1e-0.4.0: An AV1 encoder focused on speed and safety
  xfce4-notes-plugin-1.9.0: Notes plugin for the Xfce panel
         zutty-0.7: A Tetminal emulator

New versions: (36)
  bison                   :           3.7.3 ->           3.7.4
  buildah                 :          1.19.0 ->          1.19.2
  conmon                  :          2.0.24 ->          2.0.25
  dnsmasq                 :            2.81 ->            2.83
  elogind                 :         246.9.1 ->         246.9.2
  erlang                  :          23.1.4 ->          23.2.2
  flat-remix-gtk          :        20201129 ->        20210115
  garcon                  :           0.8.0 ->          4.16.1
  go                      :          1.15.6 ->          1.15.7
  grep                    :             3.5 ->             3.6
  gtk                     :           4.0.1 ->           4.0.2
  help2man                :         1.47.16 ->         1.47.17
  ImageMagick             :       7.0.10-56 ->       7.0.10-58
  inkscape                :           1.0.1 ->           1.0.2
  jack                    :          1.9.16 ->          1.9.17
  janet                   :          1.13.1 ->          1.14.1
  kickshaw                : 1.0.36_GTK3_source_only -> 1.0.38_GTK3_source_only
  krita                   :           4.4.1 ->           4.4.2
  libretls                :           3.3.0 ->           3.3.1
  libsigsegv              :            2.12 ->            2.13linux
Rustdevelopers improving LLVM and the vast majority of these contributions tend to be as employees of other organizations like Google or Mozilla etc.  I don't think anyone would bother with contributions just to help Apple.  That's just incidental and as long as it is a commonly used open source project, largely unavoidable.  The financial benefit that Apple would get from these contributions are far higher than some nicheLinux
Linux. There's dozens of C compilers out there, and OrangeC seems to be a functional free C compiler. It's not true that every compiler for a language has to compile most large codebases, either; there's space for compilers for weird targets, like VMs or other languages, or verified implementations. 
 
There's oneRust
rusthas a mandatory runtime, and that runtime depends on libc  
 
Not at all.Rusthas a mandatory core library (libcore) which does not depend on anything at all; and an optional standard library (libstd), which requires some kind of runtime. The default implementation of libstd uses libc (on Unix-like platforms) or Win32 (on Windows platforms) to provide said runtime, but could be ported to some other runtime if required. 
 
[Though it would be possible to write a suitable runtime inrust, depending on nothing but libcore andLinux
linux(an improvement on one, which is what existed for many years). It took a long time for the second compiler (LLVM clang) to be able to compile most large codebases. Also, it took hefty corporate support from Apple. So giverusta break. Specs or no specs, nobody's going
On this last day of 2020, theRustprojecthas announced therelease of version 1.49.0of the programming language. It establishes the arm64Linuxtarget as aTier 1 platform, which is the highest level of support; "Tier 1 platforms can be thought of as 'guaranteed to work'". Also, arm64 macOS and Windows have risen to Tier 2 status, which means they are guaranteed to build and are likely to work just fine, but the automated tests are not run.  Beyond that, the test framework now captures output from multiple threads and some library changes were made. See thedetailed release notesfor more information. "Rust1.49.0 promotes the aarch64-unknown-linux-gnu target to Tier 1 support, bringing our highest guarantees to users of 64-bit ARM systems runningLinux! We expect this change to benefit workloads spanning from embedded to desktops and servers.

This is an important milestone for the project, since it's the first time a non-x86 target has reached Tier 1 support: we hope this will pave the way for more targets to reach our highest tier in the future.

Note that Android is not affected by this change as it uses a different Tier 2 target."
Linux20.10 - ARM64, PowerPC64le, RISCV & more!
Message-ID: <375885E9-8D4C-499B-8630-DFB8615F834C@exactcode.com>
Date: Fri, 04 Dec 2020 14:05:43 +0100
Archived-At:After a decade of development we are proud to announce the availability of
the new T2LinuxSource and EmbeddedLinuxdistribution build kit stable
release 20.10.

The 20.10 release received updates across the board, while a major working
target was adding new architecture support for ARM64, and RISCV as well as
further improving cross compilation, and all official ISO images are now
fully cross build! Over 13800 Subversion revisions indicate the magnitude
of the release, with over 1000 new packages, new features and various other
improvements and fixes, including the latestLinuxkernel, GCC, LLVM,
Clang,Rust
Rustare PITAs to package and maintain in traditional distributions, and invite a painful and unsettling amount of bundling.  
 
Sure, they could be possible in open-source C. But they haven't been written in C. Why? I surmise because some people like solving problems instead of dealing with all the boilerplate involved with setting up a build system[1], wrangling dependencies like you're from the 90's (because, surprise, some people tend to target things other thanLinux
i3status-rust:    other/x11-wm -> other/x11-wm/i3-wm
  i3-workspace-names      :    other/x11-wm -> other/x11-wm/i3-wm
  parcellite              : other/x11-utils ->    other/crater
  polybar                 :    other/x11-wm -> other/x11-wm/i3-wm
  py3status               :    other/x11-wm -> other/x11-wm/i3-wm
  sselp                   : other/x11-utils -> other/x11-wm/suckless
  swarp                   : other/x11-utils -> other/x11-wm/suckless
  vte                     : other/x11-utils ->    other/crater
  xtrlock                 :    other/x11-wm -> other/x11-utils


=====================================================================

The Lunar-Linuxteam

_______________________________________________
Lunar mailing list
Lunar@lunar-linux.org
 http://lists.lunar-linux.org/cgi-bin/mailman/listinfo/lunar
A Google project aims to bring theLinuxkernel virtualization
mechanism, KVM, to Android systems.  Will Deacon leads that effort and he
(virtually) came toKVM Forumto
discuss the project, its goals, and some of the challenges it has faced.
Unlike some Android projects of the past, though, "protected KVM" is being
worked on in the open, with code going upstream along the way.
rustecosystem, but I still have difficulty understanding why something like k8s or terraform couldn't be re-implemented in a more traditional language which doesn't force an up-ending of ecosystems that are tried-and-tested.  
Why should somebody bend over backwards to make stuff easier forLinux
LinuxSecurity Advisory ASA-202011-1
=========================================

Severity: Critical
Date    : 2020-11-02
CVE-ID  : CVE-2020-15254 CVE-2020-15680 CVE-2020-15681 CVE-2020-15682
          CVE-2020-15683 CVE-2020-15684 CVE-2020-15969
Package : firefox
Type    : multiple issues
Remote  : Yes
Link    :  https://security.archlinux.org/AVG-1256 

Summary
=======

The package firefox before version 82.0-1 is vulnerable to multiple
issues including arbitrary code execution, information disclosure and
content spoofing.

Resolution
==========

Upgrade to 82.0-1.

# pacman -Syu "firefox>=82.0-1"

The problems have been fixed upstream in version 82.0.

Workaround
==========

None.

Description
===========

- CVE-2020-15254 (arbitrary code execution)

An undefined behaviour leading to memory corruption issues has been
found in the crossbeamrust
Rustand most other modern languages have many of the same caveats (and you could argue that even languages like Python and Perl also are similar in certain respects). And while you can go and write all of your own projects in C/C++, the wider software community is simply not going to do that -- very few developers deeply care about difficulty packaging their code inLinux
Linuxdevice driver as a test-bed forRust's adoption as a kernel development language offers a low risk entry, and could well lead to identifying additional new low-level interface features that will improveRust's usefulness and viability in similar low-level system use cases
Rust, and many
other languages.  GDB can target (i.e., debug programs running on)
more than a dozen different processor architectures, and GDB itself
can run on most popular GNU/Linux, Unix and Microsoft Windows variants.
GDB is free (libre) software.

You can download GDB from the GNU FTP server in the directory:

         ftp://ftp.gnu.org/gnu/gdb 

The vital stats:

  Size   md5sum                            Name
  21MiB  1822a7dd45e7813f4408407eec1a6af1  gdb-10.1.tar.xz
  39MiB  67b01c95c88ab8e05a08680904bd6c92  gdb-10.1.tar.gz

There is a web page for GDB at:

         http://www.gnu.org/software/gdb/ 

That page includes information about GDB mailing lists (an announcement
mailing list, developers discussion lists, etc.), details on how to
access GDB's source repository, locations for development snapshots,
preformatted documentation, and links to related information around
the net.  We will put errata notes and host-specific tips for this release
on-line as any problems come up.  All mailing lists archives are also
browsable via the web.

GDB 10.1 includes the following changes and enhancements:

* Support for debugging new targets:

  - BPF  (bpf-unknown-none)

* GDBserver support for the following targets:

  - ARC GNU/Linux
  - RISC-V GNU/Linux

* Multi-target debugging support (experimental)

* Support for debuginfod, an HTTP server for distributing ELF/DWARF
  debugging information as well as source code.

* Support for debugging
Autoconf has built-in support for various compiled languages: C, C++,
Objective C, Objective C++, Fortran, Erlang, and Go. More crucially, it
performs feature detection with knowledge of a wide variety of POSIX
platforms. If you are building new software that has few arcane
dependencies and your users are all on modernLinuxesplus FreeBSD, or if you
want tomake Ninja build
files, perhaps you'd be better served usingalternativessuch asCMake,SCons, orMeson— and indeed many
projects have switched away from the GNU Build System over the years,
includingGTK+andKDE. Complaints that the
GNU Build System isslow,
complex, and hard to usehave been aired (including in LWN's comment
threads) for years. However, if your customers need to be able to build a
shared library on Solaris, AIX, HP-UX, IRIX, and all the BSDs, then
Autoconf will come in handy.
Linuxand macOS, but I would
  suppose that FreeBSD should be also working as a build system.

  ━━━━━━━━━━━━━━━━━━━━━━
   Targets              
  ──────────────────────
   android.arm64        
   android.x86_64       
   ios.arm64            
   ios.simulator.x86_64 
   linux.musl.arm64     
   linux.musl.x86_64    
  ━━━━━━━━━━━━━━━━━━━━━━


What I tested
╌╌╌╌╌╌╌╌╌╌╌╌╌

  In the past I was able to build `Revery' the UI framework for
  `Android' and `iOS'

  But recently I did compile `esy' the package manager itself for all of
  the following platforms above from an `ArchLinuxx86_64' and `macOS
  Catalina x86_64'. Including `iOS', with the right version of OCaml it
  will run inside of the new `macOS ARM64' and inside of a jailbroken
  iPhone.


OCaml User Survey 2020
══════════════════════

  Archive:
  < https://discuss.ocaml.org/t/ann-ocaml-user-survey-2020/66... >


gasche announced
────────────────

  We are happy to announce the [OCaml User Survey 2020]. We are trying
  to get a better picture of the OCaml community and its needs. It would
  be very useful if you could fill the survey (10-15 minutes), and share
  it widely with other OCaml programmers!

  The survey is run by the [OCaml Software Foundation]. Thanks in
  particular to our sponsors OCamlPro (@MuSSF) for preparing many of the
  questions, Jane Street (@Yaron_Minsky) for excellent feedback
Rustpresumably has similar tools, but I get the impression a lot of the standard library relies on a global allocator and has little interest in providing non-allocating APIs. 
 
It's not always easy to write allocation-free code, and it's not always the most memory-efficient (because if your program uses objects A and B at non-overlapping times, it'll statically allocate A+B instead of dynamically allocating max(A,B)), but sometimes it is feasible and it's really nice to have the guarantee that you will never have to debug an out-of-memory crash. And even if you can't do it for the whole application, you still get some benefit from making large parts of it allocation-free. 
 
(This is for code that's a long way below "complex applications" from a typicalLinux
Rustthe language should, in theory, be fine, butRust's standard library is not really designed for that, which, for all practical purposes makes an event of “running out of memory” very hard to handle  
You can't realistically get an "allocation failed" situation inLinux
Rustis an obvious choice for a language to compare Zig to, as both are
seen as potential replacements for C and C++.  TheZig wikihas apagethat compares Zig toRust, C++, and theD
languagethat outlines advantages the Zig project believes the language
has.
For example, both flow control and allocations are not hidden by Zig; there is no
operator overloading or other mechanisms where a function or method might
get called in a surprising spot, nor is there support fornew, garbage collection, and the like.
It is also interesting to note that there is aprojectto use Zig to
buildLinuxkernel modules, which is also an activearea of interest forRustdevelopers.
Linux<el-errata@oss.oracle.com>  
   To : 
                 el-errata@oss.oracle.com  
   Subject : 
                 [El-errata] ELSA-2020-3631 Important: OracleLinux7 thunderbird	security update  
   Date : 
                 Thu, 17 Sep 2020 07:58:04 -0700  
   Message-ID : 
                 <fa712166-ef7a-23b4-af8c-f4c35bb2df99@oracle.com>  
  OracleLinuxSecurity Advisory ELSA-2020-3631

 http://linux.oracle.com/errata/ELSA-2020-3631.html 

The following updated rpms for OracleLinux7 have been uploaded to the 
UnbreakableLinuxNetwork:

x86_64:
thunderbird-68.12.0-1.0.1.el7_8.x86_64.rpm


SRPMS:
 http://oss.oracle.com/ol7/SRPMS-updates/thunderbird-68.12... 



Description of changes:

[68.12.0-1.0.1]
- Replaced thunderbird-redhat-default-prefs.js with 
thunderbird-oracle-default-prefs.js
- Build withrust
In 2018, three formerGnuPGdevelopers began
  work onSequoia, a new implementation
  ofOpenPGPinRust. OpenPGP is an open standard for data
  encryption, often used for secure email; GnuPG is an implementation of that
  standard. The GPLv2-licensed Sequoia isheading
  toward version 1.0, with ahandful
  of issuesremaining to be addressed. The project's founders believe that
  there is much to be desired in GnuPG, which is the de facto standard
  implementation of OpenPGP today. They hope to fix this with a
  reimplementation of the specification using a language with features that
  will help protect users from common types of memory bugs.
An online event requires an online platform to host it.  TheLinuxFoundation, which supports LPC in a number of ways, offered a handful of
possibilities, all of which were proprietary and expensive.  One cannot
blame theLinuxFoundation for this; the events group there was under great
pressure with numerous large events going up in flames.  In such a
situation, one has to grasp at whatever straws present themselves.  We,
though, had a bit more time and a strong desire to avoid forcing our
attendees onto a proprietary platform, even if the alternative required us
to build and support a platform ourselves.
Linuxkernel is notorious for its use of intrusive doubly-linked lists, andRustis notorious for the difficulty/discouragement of linked lists. Surely if it was just a matter of finding a safe abstraction inRust(i.e. wrapper around unsafe code),Rustwould also have easy-to-use linked lists
SupportingLinuxkernel development inRust: aLinuxPlumbers Conference session on incorporating a safer
  language into the kernel.
Firefox development drives (drove?)Rustdevelopment, so of course it requires the latest nightly build. 
 
There's no requirement for doing the same withLinux. Programs written against stableRust~never need changes due to newRustreleases.
Rustfeatures, not about keepingRustcode working and relevant. 
 
You're presumably using a kernel with a ~10-week release cycle, would you claim that fact makesLinuxunstable and unsuitable for sizable projects?Rustis *serious* about stability. Since theRust1.0 release in May 2015, they
Rustshouldn’t be a systems language at all  
 
Yeah, that’s one of reasons why I think thatLinuxshouldn’t jump on theRustbandwagon… yet. More mature languages have been rejected in the past to be used forLinuxcode, and by now we cannot be sure
Rustruns on a 6-week release cycle (like Firefox), and each release seems to bring some changes to the language, and therefore to the compiler front-end. (OTOH, in recent releases the language changes have been relatively small). Trying to re-implement the whole compiler would involve lots of churn. So starting from  the MIR (Mid-level IR)  seems much wiser, IMHO.
 
Of course, a backend that can translate MIR into GCC's internal representation would be a major win not only forLinux
TheRustprogramming languagehas long aimed to be a suitable replacement for C in operating-system
kernel development.  AsRusthas matured, many developers have expressed
growing interest in using it in theLinuxkernel. At the 2020 (virtual)LinuxPlumbers Conference, theLLVMmicroconference track hosted a session
on open questions about and 
obstacles to acceptingRustupstream in theLinuxkernel.  The interest in
this topic can be seen in the fact that this was the single most heavily
attended session at the 2020 event.
Rustdeveloper (formerly Firefox, currently rr and Pernosco), I think only build times are really serious, and I have some hope that's fixable with some research and a lot of hard work. 
 
Making ownership checking somehow optional isn't going to happen, nor should it. Ownership and borrowing are the basis ofRust. Throwing them away and losing the associated guarantees of memory safety, data race freedom, etc, would be a nightmare in practice *and* thoroughly confound the messaging aroundRust. Instead, work continues to make theRustcompiler and other tools better at helping developers fix their ownership models. 
 
Yes, this meansRustisn't the ideal quick-and-dirty prototyping language --- but C++ isn't either. GC-heavy languages will probably continue to have an edge there. Too bad; there's guarantee there exists a single tool that's ideal for all tasks. 
 
I think the idea that C++ has better libraries is exactly backwards. C++ libraries outside the standard library are largely useless because managing and shipping those dependencies is far too hard. If you can limit deployment to one or at most a fewLinux
rust-1.43.1-12.1rust-analysis-1.43.1-12.1rust-debuginfo-1.43.1-12.1rust-debugsource-1.43.1-12.1rust-std-static-1.43.1-12.1
      rustfmt-1.43.1-12.1
      rustfmt-debuginfo-1.43.1-12.1

   - SUSELinuxEnterprise Module for Development Tools 15-SP2 (noarch):rust-src-1.43.1-12.1

   - SUSELinuxEnterprise Module for Development Tools 15-SP1 (aarch64
linux-gnu.
     - Option::{expect,unwrap} and Result::{expect, expect_err, unwrap,
       unwrap_err} now produce panic messages pointing to the location where
       they were called, rather than core's internals. Refer toRust's
       platform support page for more information onRust's tiered platform
       support.

   + Libraries
linux-gnu.
     - Option::{expect,unwrap} and Result::{expect, expect_err, unwrap,
       unwrap_err} now produce panic messages pointing to the location where
       they were called, rather than core's internals. Refer toRust's
       platform support page for more information onRust's tiered platform
       support.

   + Libraries
rustspectrwm-3.4.1: A minimalistic automatic tiling window manager
  sphinx_rtd_theme-0.5.0: Read the Docs theme for Sphinx

New versions: (29)
  bind                    :          9.17.1 ->          9.17.2
  bind-utils              :          9.17.1 ->          9.17.2
  broot                   :          0.17.0 ->          0.18.0
  busybox                 :          1.31.1 ->          1.32.0
  gnome-calculator        :          3.34.1 ->          3.36.0
  gtk+-3                  :           24.18 ->           24.21
  gtksourceview           :           4.4.0 ->           4.6.1
  haveged                 :          1.9.12 ->          1.9.13
  i3lock-color            :        2.12.c.3 ->        2.12.c.4
  ImageMagick             :       7.0.10-21 ->       7.0.10-22
  kickshaw                : 1.0.27_GTK3_source_only -> 1.0.28_GTK3_source_only
  libemf                  :           1.0.9 ->          1.0.13
  libmicrohttpd           :          0.9.70 ->          0.9.71
  libva                   :           2.7.1 ->           2.8.0
  libwacom                :             1.3 ->             1.4
  lyx                     :         2.3.5.1 ->         2.3.5.2
  ModemManager            :         1.12.10 ->          1.14.0
  netdata                 :         v1.22.1 ->         v1.23.0
  nspr                    :            4.25 ->            4.26
  openttd                 :           1.9.3 ->          1.10.2
  papirus-icon-theme      :        20200602 ->        20200702
  podman                  :           2.0.0 ->           2.0.1
  postfix                 :           3.5.3 ->           3.5.4
  python-numpy            :          1.18.5 ->          1.19.0
  shfmt                   :           3.1.1 ->           3.1.2
  stellarium              :          0.20.0 ->          0.20.2
  unrar                   :           5.9.3 ->           5.9.4
  vala                    :          0.48.6 ->          0.48.7
  xxHash                  :           0.7.3 ->           0.7.4


=====================================================================

The Lunar-Linux
Rust, have a look at "ttdl":  https://crates.io/crates/ttdl  
 
I use it as a daily driver and the filters are pretty helpful. Supports recurring tasks, too. Bonus points: Works onLinux, MacOS and Windows. 
 
While TaskWarrior has more bells and whistles than todo.txt, the simplicity and the cleverness
poured money into it" 
 
Mozilla usingRustin Firefox was a very important step in gettingRustinto all theLinuxdistributions paving the way for other uses like librsvg etc.  It's not just about the money.  It's more the visibility that Mozilla provided that was crucial initially
Linuxwould have to disable? I guessLinuxwould have to avoid `new` anyways as it does `malloc`, so maybe it wouldn't be *that* far off. But without `std::optional` and some nice wrapper around `std::variant` to act as Haskell's `Either` orRust's `Result`, the algorithms
Linuxand MacOS.  `rr' currently requires an
  Intel CPU with Nehalem (2010) or later microarchitecture.


Credits
╌╌╌╌╌╌╌

  The analysis was originally proposed by Mark Shinwell (@mshinwell).


KC Sivaramakrishnan added
─────────────────────────

  As @gasche had mentioned earlier, the no-naked-pointers mode was
  already there in OCaml and it is known to work on all the platforms
  that OCaml was supported. Hence, it was a reasonable path to pursue
  for Multicore.

  The concurrent minor collector in Multicore OCaml uses the virtual
  address space trick, but only for the minor heap area. It needs
  contiguous 4GB reserved for 128 domains, each with max 16MB minor heap
  arena. This can be modified at compiler configure time. For comparison
  the minor heap is 2MB by default in OCaml and so 16MB should be quite
  enough.  We hadn't considered this trick for the major heap in
  Multicore.

  However, given our experimental evaluation (see [paper]), we have
  chosen not to pursue concurrent minor collector for the initial
  version of multicore support to be upstreamed. The alternative
  stop-the-world parallel minor collector scales better and does not
  break the C FFI. The parallel minor collector does not need the
  virtual address space trick.

  Given that the space
Linux. We are briefly told of new
features, workarounds and fixes included, plus given a link to GitHub for more details or
binaries.

 https://www.phoronix.com/scan.php?page=news_item&px=A... 

=== Ubuntu Touch Demoed on the PineTabLinuxTablet [Video] ===

Joey Sneddon tells us he's excited for the release of the PineTab, being arguably the first realLinuxtablet. With some discussion on selected history ofLinuxtablets, the star of the article is
the embedded youtube video on Ubuntu Touch running on the Pine64.

 https://www.omgubuntu.co.uk/2020/05/ubuntu-touch-pinetab-... 

== In Other News ==

=== Ubuntu Touch OTA-12 Release ===

Ubports announces the Ubuntu Touch OTA-12 for supported devices. Including the last of Canonical's
Unity 8 changes, it involves many changes for Ubuntu Touch users. The updates include the software
stack, visual color changes to improve contrast making devices easier to use, keyboard
functionality improvements, Morph Browser improvements, plus some device specific features are
added. This is a big update, with thanks tendered to those who helped make it happen. Links are
provided for seeking help, to view the changelog, reporting bugs, and more.

 https://ubports.com/blog/ubports-blog-1/post/ubuntu-touch... 

== Featured Audio and Video ==

=== Ubuntu Security Podcast: Episode 74 ===

"Special guest, Tim McNamara, author ofRust
Linux(other unixes), libreoffice (MS office), etc., etc.  Even GIMP has recently seen a push to "be like [compatible with] photoshop".  There is truly no end to the list. 
 
It's not just SW though.  Any look at upcoming and past gaming consoles show that there is a great push to be compatible with prior generations.  x86 is pretty much compatible all the way back to the 8086.  The PC architecture is still compatible all the way back to the first Personal Computer.  s390 is famously backwards compatible to its initial version.  This list, too, could go on and on. 
 
It's not like breaking compatibility is a new thought and there are no lessons to learn from history.  We have seen HW platforms fail miserably because the competition was backwards compatible while it was not.  We have seen the huge and decade long pains that incompatible SW changes causes: everything from programs not compiling (e.g.Rust
Linux, which means a working container system may just have two of the three mentioned services and still be complete). With userdbd and homed this hasnt changed.
 
One nice side-effect of containers is that because they run with almost nothing, this means the "simple systemd" case of turning almost everything non-systemd-core off is routinely tested and doesn'trust
Rust. 
 
If you're part of the Lua community and are willing to put in the effort to solve package management, it's probably because you love Lua more than any other language. You wouldn't want to extend e.g. pip to support Lua packages, because then you'd be spending the next several years writing code in Python and you'd much rather be writing Lua. 
 
 >> [..] and because you don't want your language to be weighed down by a dependency on someone else's language [..]  
 > However, if that reason sticks it is just another instance of the not-invented-here syndrome which forcing upon users and developers alike is not productive.  
 
I don't think that's NIH: there are real practical costs to having dependencies. I can go to  https://www.python.org/downloads/  and download an installer for Windows that includes a fully-functional pip. But if pip was written in e.g. Perl, either the Python installer would have to tell me to go and download a Perl installer first, or else the Python installer would have to include a bundled copy of Perl (which would make the download much larger, and would likely introduce
Linuxkernel development workflow is. For such a 'terrible' workflow it sure seems to have produced excellent results. Maybe it's not so terrible after all? Maybe, just maybe, it's actually a GOOD process and we should learn from it rather than dismiss it because it doesn't use 'hip' proprietary Microsoft-owned-and-controlled web interfaces. It seems to me that rather than saying 'what can theLinuxkernel developers learn from Javascript kids on GitHub' we should be asking 'what can the Javascript kids on GitHub learn fromLinuxkernel development'. That's a question with a lot more answers that are a lot more interesting: 
 
1. You don't need a 'web interface' to use version control. 
2. You don't need a centralised repository for code hosted on a website. 
3. You don't need inaccessible proprietary software to discuss things, because email works very well for discussing things already. 
 
get-lore-mbox seems like a wonderful tool and ironically is only possible because theLinuxkernel development process is done in the open through a standardised protocol. Projects that organise through GitHub, like theRust
The requirements for working with the robot and Snek are pretty minimal: a
USB connection from the host to the robot running Snek and a Python program
running on the host.  Windows 10 has finally joinedLinuxand macOS in
not requiring drivers to talk to USB serial devices, so it is all pretty
straightforward.  It is easier to install than the Arduino environment
because there is no need for a compiler.
Rustprogram just to copy a bunch of files  
 
`cp` and many other utilities handle non-Unicode filenames correctly. That's not surprising; C programs that accept filenames in argv[] and treats them as a null-terminated char strings should work. 
 
We've had a couple of decades to try to enforce that filenames are valid UTF8 and I don't know of anyLinux
Rustyou pass a command-line argument by calling Command::arg(...) to add the argument to the command you're building, and Command::arg(...) accepts Paths. Each platform has a standard way to pass arbitrary filenames as command-line parameters, andRustdoes what the platform requires. 
 
A few programs accept arbitrary paths as strings on stdin; they need to define how those paths are encoded on stdin. OnLinux
Linux, it is easy to write a C orRustprogram that spawns another program, passing a non-UTF8 filename as a command line argument. It is easy to write the spawned program in C orRustand have it open that file. In fact, the idiomatic C andRust
Rustfor core software? You're trying to have your cake and eat it too.  
 
That sounds reasonable in isolation, but when it's part of a causal chain that results in a few hobbyists holding back important improvements for the other 99.999% of users, it becomes unreasonable. 
 
 > produces proprietary software and hardware with their proprietary Qualcomm Hexagon ISA.  
 
While you're wielding "proprietary" as a slur, keep in mind that almost every architecture that you think it's important to support is also proprietary. 
 
 > We could start with community.  
 
Can you elucidate the actual argument here? 
 
 > If that doesn't move you, go with simple politics; free software has its own politics, and that guy who wrote the code you need to change to compile the kernel with LLVM turns out to be one of the guys who did the original Alpha port (which did all the work needed to makeLinux
Linux, as an operating system, is not going to drop support for hardware that's not the latest and greatest. I've got a laptop that has 20 times the processor and eight times the memory of what I went to college with, that has Windows 10 on it, and response times are vastly worse than that laptop I used in college. I don't want to seeLinuxgo that way. There's an environmental cost in forcing perfectly good hardware to be replaced, as well as a financial one. 
 
 > I suspect that once you can buildLinuxwith clang, CPU vendors will start choosing to just implement an LLVM backend and not bother with gcc,  
 
Cool. What you're saying is that if you have your way, the programming language that has my heart strings, Ada, will get much harder to use on modern systems, and should I return to active work on Debian I have an interest in discouragingRust
Rust, Swift and Julia; clang-only applications like Firefox and Chromium (Firefox requiresRusttoo of course); and random other stuff like Gallium llvm-pipe. 
 
I suspect that once you can buildLinuxwith clang, CPU vendors will start choosing to just implement an LLVM backend and not bother with
library toRust, which broke that library for other architectures he was working on. It doesn't matter that another language can use LLVM; it matters that it only uses on LLVM, at least onLinux, and I can't name another language that is only supported by LLVM onLinux.
Rust, and liking the language a lot more than Go ... so far.. 
 
I haven't run into any issues with LLVM support, what have you seen?  
Odd that this would be unique toRust, and not the plethora of other languages that use LLVM, with no complaints. Or is this something that crops up, no matter the language, and I just haven't heard of the use case yet?Linux
Rustsnap by Example -  https://ubuntu.com/blog/building-a-rust-snap-by-example 

== In the Blogosphere ==

=== Canonical's Multipass 0.9 Released For Easily Spinning Up Ubuntu VMs ===

Michael Larabel informs us that Multipass version 0.9 has been released, with chances 1.0 may be
ready for Ubuntu 20.04 LTS. We are reminded of what Multipass is, and what it can do for us, and
Michael provides links for more details.

 https://www.phoronix.com/scan.php?page=news_item&px=M... 

=== Radeon OpenGLLinux
Linuxpeople added rpm and deb-incompatible things in it, was easy to map). 
 
And then the result of the install is useless for therustdev if there is no system workspace enabled by default. The crates will be installed but not used. 
 
 > Of course, if the distros
Rustworld - Cargo is good enough as a package manager that I can bypass operations.
 So, distros no longer have leverage; how do operations get heard in this world, given that if you push back against good development practices like "releases early, release often", users will bypass distros to get the tooling they want? Remember thatLinux
models thanLinuxdistros. But you've made it quite clear that either I fall in line with your views based on your experience of Go (notRust, the language under discussion!) or you will see me as the enemy, so maybe I should stop pushing for more dynamic linking…
Rustecosystem gets big enough, you'll have library A that depends on version 1 of library X, and library B that depends on version 2 of library X, and library/program C that wants to use A *and* B (and maybe also X directly). 
 
How is that supposed to work? Esp. if library X exposes some OS- or UI-level thing that needs persistent state that can't be initialized twice? 
 
A distribution's job is to provide a coherent whole. Yes I can do that myself when I write and package some code, but that's like a smaller clone of the old days when people had to hand-assemble theirLinux
In summary, for me, for 2020,Rust's already very inclusive approach to its community needs to turn outward and look for ways to increase the chances that it can be included into other projects such asLinuxdistributions. I see this as increasing the inclusivity of the project by including into our worldview the particular needs of these other projects and communities and ensuring that by treating them as first-class consumers ofRust, we can become first-class members of their projects and communities as well.
like in app-stores or such. 
The currentLinux-distribution model is probably a good filter, or has been so far, but it seems they also struggle with these new language-environments, and the pace at which components turn over. Python maybe less so, but definitely javascript, go, orrust.
Rustlibraries and executables all sharing the same dependency versions (i.e. a single Cargo.lock file). And Cargo doesn't lock you into either of those extreme policies; you can easily update on whatever schedule or policy you like. Tools like cargo-audit help you update in response to security issues. 
 
One big issue missed by proponents of depending onLinux
ever developRustimplementations of any of these components seems to depend on these components being maintained by people who are primarily concerned with whatLinuxdistributions want, which seems like an unsupported assertion. 
 
Basically: If nobody cares about the shared libraries a distribution ships, why should a distribution care?
I forgot to mention GStreamer in my list. That community is trying the hardest to find a place forRustinLinuxsystems. It is security-critical, and has strict API/ABI stability requirements. I'm curious what its future will be.
Rustcommunity were to better understand and address the concerns of theLinuxdistribution community, the potential exists to significantly increase adoption and acceptance ofRust.Rusthas no real incentive to play by distribution rules. Firefox's usage ofRustand subsequent increasingly widespread adoption will not be hampered
Rust, yes), plus a distro runtime, either a traditionalLinuxdistro or something that looks very similar (in the case of flatpaks, that would be freedesktop-sdk or the derived runtime, which represents a careful balancing act between sharing the most important common dependencies and avoiding stuffing too much stuff
Rustneeds those developers".Rustis already successful without those developers, and theRustcommunity knows it ... which means they won't readily make significant concessions to better fit into the classicLinuxdistro shared library model. 
 
If you specifically mean "Rustneeds those developers if it's to completely
Linuxis now the OS that matters, and replacing it will be tough when theRustand Redox folks don’t care about POSIX compliance or API/ABI stability. 
 
The Ada people have been ranting about unsafe languages and poor programming for a long time, and they were correct to do so. TheRust
Rustadoption would be quicker and easier if it were to better accommodate existing expectations regarding API/ABI stability. I regard API/ABI stability as the paramount goal for developing a successful system library, and I have no intention of usingRustbecause it does not allow me to achieve that goal. This means I'll continue to write buggy, insecure code in unsafe languages, because there seems to be no safe language that is both suitable and popular. 
 
Let's reduce the difficulty of the problem somewhat. I don't thinkRustneeds a *permanent* stable ABI to be useful for replacing C shared libraries. That is, the ABI doesn't need to be permanently locked down. It just needs to be stable for a reasonable period of time, so that distros don't have to rebuild theRustworld when it changes. For example, two or three years of ABI stability would be sufficient for the purposes ofLinux
Rust. 
 
I thinkRustneeds those developers.Rustcurrently proposes to upend two well-established norms: (a) the use of memory unsafe languages in systems programming, and (b) current aversion to use of bundled dependencies, especially for system libraries. Challenging either norm, on its own, would be tremendously difficult. Challenging both at the same time seems like a strategic mistake. TheRustcommunity loses essential allies, and we wind up with more and more code written in unsafe languages. 
 
Currently,Rustseems like the only memory-safe systems programming language that's generated enough interest amongLinux
Rustcommunity's self-defeating choices  
 
 > This topic is too often discussed from the premise that they way distros have done packaging for C is right and anything that doesn't fit that model is wrong. Your comment appears to imply that premise.  
 
AOL.Linuxis a decent system
Linuxdesktop approach of applications depending on lots of interdependent shared libraries. Cargo makes managing and updating dependencies so much easier than manual vendoring in C/C++ that it's not really the same thing at all, and it's definitely nothing like 90s-style "DLL hell". (It's a helpful safety valve that by default it works to link multiple versions of the sameRust
rustcrates today, it just means losing a lot of the higher-level functions of nativeRust. In contrast, Apple recently stabilized Swift ABIs for a bunch of their platform. I understand it was a huge effort over the last few years. See  gankra's recent post  if you're curious about the details. 

 Given that difficulty, and the immaturity ofRust, I think their resistance to a dylib ABI for stableRustis appropriate.Linux
Linuxsystems programmers who would be ready to join this bandwagon, myself included, if only theRustand cargo ecosystem were not so friendly to vendoring static libraries. It seems theRustcommunity is not serious about shared libraries with API/ABI stability and without vendored dependencies, and therefore I claim
Rust? I don't know much about driver development, but an abstract driver framework looks interesting: You write the framework (API) once, drivers once and two (or more) implementations (one forlinuxand one for Redox)... and can use the same driver onlinuxand Redox. Another pro: this would
Fedora'sModularity
initiativehas been no stranger to controversy since itsinceptionin 2016.  Among other things, there
were enough problems with the original design that Modularitywent back to the drawing boardin early 2018.
Modularity has since been integrated with both the Fedora and Red Hat
EnterpriseLinux(RHEL) distributions, but the controversy continues, with
some developers asking whether it's time for yet another redesign — or to
abandon the idea altogether.  Over the last month or so, several lengthy,
detailed, and heated threads have explored this issue; read on for your
editor's attempt to integrate what was said.
Continuing on theRusttheme, Alibaba, AWS, CloudBase, Google, Intel, and Red
Hat have collaborated onrust-vmm, which is a collection ofRustcrates for virtualization software. Florescu and Samuel Ortiz
talked about that in "Playing
Lego with Virtualization Components". They explained thatRust's key
features (memory safety, safe concurrency, and great performance) fit
well with the VMM requirements.  Some examples of components provided byrust-vmm are API bindings (KVM, VirtIO, VFIO), a memory model, a kernel
loader, and several utility libraries.
Seems we're finally getting useful async io for disks onLinuxwith io_uring. 
 
Speaking of which, any project wiring upRustasync/await with io_uring?
rust>= 1.38.
     * Fixrd LTO build without PGO.
     * Removed kde.js since disabling instantApply breaks extensions and is
       now obsolete with the move to HTML views for preferences. (bsc#1151186)
     * Updated create-tar.sh. (bsc#1152778)
     * Deactivated the crashreporter for the last remaining arch.


Patch Instructions:

   To install this SUSE Security Update use the SUSE recommended installation methods
   like YaST online_update or "zypper patch".

   Alternatively you can run the command listed for your product:

   - SUSELinux
rust-doc-1.36.0-4.1rust-gdb-1.36.0-4.1

   - SUSELinuxEnterprise Module for Open Buildservice Development Tools 15-SP1 (noarch):

      cargo-doc-1.36.0-4.1

   - SUSELinuxEnterprise Module for Development Tools 15-SP1 (aarch64 ppc64le s390x x86_64):

      cargo-1.36.0-4.1
      clippy-1.36.0-4.1
      rls-1.36.0-4.1rust-1.36.0-4.1rust
rust:          0.10.0 ->          0.11.0
  ico                     :           1.0.4 ->           1.0.5
  iso-codes               :             4.3 ->             4.4
  jbig2dec                :            0.16 ->            0.17
  libblockdev             :          2.22-1 ->          2.23-1
  libdrm                  :          2.4.98 ->         2.4.100
  libepoxy                :           1.5.2 ->           1.5.3
  libevdev                :           1.5.9 ->           1.8.0
  libfontenc              :           1.1.3 ->           1.1.4
  libICE                  :           1.0.9 ->          1.0.10
  libinput                :          1.12.6 ->          1.14.2
  libpciaccess            :            0.14 ->            0.16
  libreoffice-bin         :           6.2.7 ->           6.2.8
  librsvg                 :          2.46.1 ->          2.46.2
  librsync                :           2.1.0 ->           2.2.1
  libSM                   :           1.2.2 ->           1.2.3
  libuv                   :          1.32.0 ->          1.33.0
  libva                   :           2.1.0 ->           2.5.0
  libX11                  :           1.6.6 ->           1.6.7
  libXau                  :           1.0.8 ->           1.0.9
  libXcomposite           :           0.4.4 ->           0.4.5
  libXcursor              :          1.1.15 ->           1.2.0
  libXdamage              :           1.1.4 ->           1.1.5
  libXdmcp                :           1.1.2 ->           1.1.3
  libXext                 :           1.3.3 ->           1.3.4
  libXfont2               :           2.0.3 ->           2.0.4
  libXft                  :           2.3.2 ->           2.3.3
  libxkbfile              :           1.0.9 ->           1.1.0
  libXmu                  :           1.1.2 ->           1.1.3
  libXrandr               :           1.5.1 ->           1.5.2
  libXt                   :           1.1.5 ->           1.2.0
  libXvMC                 :          1.0.10 ->          1.0.12
  man-pages               :            5.02 ->            5.03
  mesa-lib                :          18.2.0 ->          19.2.1
  mpd                     :         0.21.15 ->         0.21.16
  netdata                 :         v1.17.1 ->         v1.18.0
  node                    :         12.11.1 ->         12.12.0
  openssh                 :           8.0p1 ->           8.1p1
  parted                  :             3.2 ->             3.3
  pixman                  :          0.34.0 ->          0.38.2
  py3status               :            3.19 ->            3.21
  python                  :           3.6.8 ->           3.8.0
  python-attrs            :          18.2.0 ->          19.3.0
  python-prompt_toolkit   :           2.0.9 ->          2.0.10
  qjackctl                :           0.5.9 ->           0.6.0
  qpdf                    :           9.0.1 ->           9.0.2
  rage                    :           0.3.0 ->           0.3.1
  sessreg
Like any other kernel API, pidfds will continue to evolve over time,
Brauner said.  One feature he would like to add is sending aSIGKILLsignal to a process when the last pidfd referring to it is
closed.  That is something FreeBSD supports now, butLinuxwill need to do
things a bit differently.  When a FreeBSDclose()call returns,
all of the work in the kernel is done;Linux, instead, can defer work to a
workqueue to be done asynchronously later.  Thus, the process may continue
to exist for a while after that lastclose()call returns, which
may not be what the application expects.  He has
a proof-of-concept implementation of how this feature could work inLinux,
but he's not entirely happy with it yet.
rust-0.10.0: A replacement for i3status, written in pureRustlibmpack-lua-1.0.8: libmpack lua binding
     libwmf-0.2.12: A library for reading vector images in Windows Metafile Format (W
        lpeg-1.0.2: A pattern-matching library for Lua
  luafilesystem-1.7.0.2: File System Library for the Lua Programming Language
  ripgrep-all-0.9.3: Search in PDFs, E-Books, Office documents, zip, tar.gz, etc
  speedtest-cli-2.1.2: Command line interface for testing internet bandwidth
   starship-0.18.0: The cross-shell prompt for astronauts

New versions: (42)
  acpid                   :          2.0.31 ->          2.0.32
  bluez-5                 :              50 ->              51
  compiler-rt             :           7.0.1 ->           9.0.0
  cups-filters            :          1.25.5 ->          1.25.6
  enchant                 :           2.2.6 ->           2.2.7
  gst-libav               :          1.16.0 ->          1.16.1
  gst-plugins-bad         :          1.16.0 ->          1.16.1
  gst-plugins-base        :          1.16.0 ->          1.16.1
  gst-plugins-good        :          1.16.0 ->          1.16.1
  gst-plugins-ugly        :          1.16.0 ->          1.16.1
  gst-python              :          1.16.0 ->          1.16.1
  gstreamer               :          1.16.0 ->          1.16.1
  ImageMagick             :        7.0.8-65 ->        7.0.8-66
  kmymoney                :           5.0.6 ->           5.0.7
  libqmi                  :          1.22.6 ->          1.24.0
  libwacom                :             1.0 ->             1.1
  libwpe                  :          1.3.91 ->           1.4.0
  links                   :          2.20.1 ->          2.20.2
  lld                     :           8.0.1 ->           9.0.0
  llvm                    :           8.0.1 ->           9.0.0
  lunar                   :              34 ->              35
  memcached               :          1.5.14 ->          1.5.18
  mpd                     :         0.21.14 ->         0.21.15
  mutt                    :          1.12.1 ->          1.12.2
  newsboat
rust-gdb-1.36.0-3.21.1

   - SUSELinuxEnterprise Module for Open Buildservice Development Tools 15 (noarch):rust-src-1.36.0-3.21.1

   - SUSELinuxEnterprise Module for Development Tools 15 (aarch64 ppc64le s390x x86_64):

      cargo-1.36.0-3.21.1
      clippy-1.36.0-3.21.1
      rls-1.36.0-3.21.1rust-1.36.0-3.21.1rust-analysis-1.36.0-3.21.1rust-gdb-1.36.0-3.21.1rust
LinuxWeekly News, fyi ...

26th Annual Tcl/Tk Conference (Tcl'2019)
 https://www.tcl-lang.org/community/tcl2019/ 

November 05 - 08, 2019
Crowne Plaza Houston River Oaks
2712 Southwest Freeway, 77098
Houston, Texas, USA

[ NEWS
  * Our keynote speaker is [Will Duquette]( https://github.com/wduquette )
    talking about "Tcl,Rust, and the Death of Rube Goldberg"

  * Registration
Rust's immaturity as a language, regardless of its supposedly groundbreaking special features (which don't exist inside "unsafe" blocks), and the discussion moved forward perhaps to its conclusion.Rustis a huge crock. The reasons why it looks good to some are that contemporary C++ is also a crock (e.g. for attempting parity withRust); and because its advocacybots[0] soak up all the flak that its features and lack thereof should rather face. Oh, and also security[1], and indistinct references to studies supposedly proving how people[2] just aren't good enough to handle sharp-cornered objects. This is not substantially different from the 1996 Java deal[3], only now it's a good thing that there's not going to eventually be a sufficiently smart just-in-time compiler and prescient garbage collector. 
 
 >(...) having Redox's kernel andLinux
Rustcode unwind in panic situations? (I'm guessing `fn drop` calls would be skipped). 
* Problem domain is similar to loadingRust-based DSOs in userspace, for frameworks that are not originally written inRust(think about a GIMP plugin, for instance). Perhaps we should tackle that problem first? 
 
Bottom line, I think that it would be quite hard to extract value from this, given how much of the APIs exposed by the kernel are engrossed in C-based complexity and unsafety assumptions. When I do imagine such framework, I see it would need a to provide a thick layer with a disparate set of APIs, if it ever wants to be viable and a fully idiomaticRust. 
 
Maybe it's just a crazy idea, but perhaps a different project can be realized, for example - having Redox's kernel andLinux
Linuxkernel doesn't guarantee API/ABI stability, so it's hard to design a universalRustinterface. At least it is almost impossible to make it work on all versions ofLinux. 
2. Many C language features have no correspondingRustsupport. For example, it seems like impossible to construct
Linuxis supported under "Tier 2.5" in the  chart of supported targets  as  sparc-unknown-linux-gnu . 

 Bare-metal RISC-V (ie. not on top ofLinux) is supported by the  riscv32imac-unknown-none-elf ,  riscv32imc-unknown-none-elf ,  riscv64gc-unknown-none-elf , and  riscv64imac-unknown-none-elf  targets under tier 2.

 The others are blocked on LLVM  not having code generators for them  though, last I checked, Debian was exploring using the  mrustc  transpiler to support m68k. (However, currently, mrustc doesn't do borrow checking and is primarily intended for re-bootstraping the self-hostingRust
I don't have many experience withLinuxkernel programming, but I loveRustand I would love to help if I can.
technically feasible is to have some parts written in different languages, andRustwould fit just as well as C++ there. 
 
Introducing a new compiler dependency on the other hand... A much much harder sell. Maybe when LLVM can compileLinuxwithout patches, or if GCC got aRustbackend.
Linuxcould migrate from C toRust?
 
The only realistic choice is migrating to C++ exactly because of backwards source compatibility.
It is curse for C++ and it is a blessing for anyone migrating upwards. 
 
I have small .config back-to-back compiled and linked with g++ [1].
 
The flag
Rust. This would already be quite a lot of work --- integratingRustinto theLinuxbuild system, writingRustwrappers around kernel APIs --- but much has already done experimentally. There's a good chance that encouraging people to submit their wacky drivers inRustwould improve the quality of the driver
linuxhelps, inrust(and yes all other lagnuages which use a similar system) this is more problematic. 
 
cargo gets problemtatic as when you as a maintainer have to even out the developer cargo dependencie trees from multiple groups, so update a dependency which has a CVE (or some other
Linuxcould migrate from C toRust?  For instance, c andRustinteraction; writing new sources, new packages, new modules inRust; replacing old stable sources withRust. 
 
I explicitly do not mean fantasies about Linus declaring a 5 year holiday while everything is rewritten all at once :-) 
 
It's been
Rustis. 
 
Beyond the standard library,Rust's library ecosystem is already far superior to that of C++ becauseRusthas a modern package manager that makes managing dependencies on third-party libraries a breeze, while in C++ it's a disaster (choose one of "vendor the code", "depend onLinux
LinuxKernel,    git-packagers@googlegroups.com
Archived-At:The latest feature release Git v2.23.0 is now available at the
usual places.  It is comprised of 505 non-merge commits since
v2.22.0, contributed by 77 people, 26 of which are new faces.

The tarballs are found at:

     https://www.kernel.org/pub/software/scm/git/ 

The following public repositories all have a copy of the 'v2.23.0'
tag and the 'master' branch that the tag points at:

  url =  https://kernel.googlesource.com/pub/scm/git/git 
  url = git://repo.or.cz/alt-git.git
  url =  https://github.com/gitster/git 

New contributors whose contributions weren't in v2.22.0 are as follows.
Welcome to the Git development community!

  Ariadne Conill, Barret Rhoden, Ben Avison, Carmine Zaccagnino,
  Daniel Ferreira, Doug Ilijev, Dr. Adam Nielsen, Jakub Wilk,
  John Lin, Mark Rushakoff, Matheus Tavares, Mazo, Andrey,
  Michael Osipov, Michael Platings, Miguel Ojeda, Mike Mueller,
  Morian Sonnet, Philipp Weißmann, Quentin Nerden, Robert Morgan,
  Simon Williams, Steven Roberts, Tigran Mkrtchyan, Varun Naik,
  Vishal Verma, and Xin Li.

Returning contributors who helped this release are as follows.
Thanks for your continued support.

  Ævar Arnfjörð Bjarmason, Alessandro Menti, Alexander
  Shopov, Beat Bolli, Boxuan Li, brian m. carlson, Carlo Marcelo
  Arenas Belón, Cesar Eduardo Barros, Chris Mayo, Christian
  Couder, Christopher Díaz Riveros, Denton Liu, Derrick Stolee
Rustat the upcomingLinuxPlumbers Conference .  From what I have seen, things like split counters, sequence locks, and base RCU (as opposed to RCU use cases like RcuCell) have been carefully avoided in earlierRust-languageLinux-kernel drivers.  Maybe they will take them head-on in this talk
LinuxWeekly News, fyi ...

26th Annual Tcl/Tk Conference (Tcl'2019)
 https://www.tcl-lang.org/community/tcl2019/ 

November 04 - 08, 2019
Crowne Plaza Houston River Oaks
2712 Southwest Freeway, 77098
Houston, Texas, USA

[ NEWS
  * Our keynote speaker is [Will Duquette]( https://github.com/wduquette )
    talking about "Tcl,Rust, and the Death of Rube Goldberg"

  * [Submission
LinuxWeekly News, fyi ...

26th Annual Tcl/Tk Conference (Tcl'2019)
 https://www.tcl-lang.org/community/tcl2019/ 

November 04 - 08, 2019
Crowne Plaza Houston River Oaks
2712 Southwest Freeway, 77098
Houston, Texas, USA

[ NEWS
 * Our keynote speaker is [Will Duquette]( https://github.com/wduquette )
   talking about "Tcl,Rust, and the Death of Rube Goldberg"

 * [Submission
Linux* CVE-2019-11694: (Windows only) Uninitialized memory memory leakage in
     Windows sandbox
   * CVE-2019-11698: Theft of user history data through drag and drop of
     hyperlinks to and from bookmarks
   * CVE-2019-5798: Out-of-bounds read in Skia
   * CVE-2019-7317: Use-after-free in png_image_free of libpng library
   * CVE-2019-9797: Cross-origin theft of images with createImageBitmap
   * CVE-2019-9800: Memory safety bugs fixed in Firefox 67 and Firefox ESR
     60.7
   * CVE-2019-9815: Disable hyperthreading on content JavaScript threads on
     macOS
   * CVE-2019-9816: Type confusion with object groups and UnboxedObjects
   * CVE-2019-9817: Stealing of cross-domain images using canvas
   * CVE-2019-9818: Use-after-free in crash generation server
   * CVE-2019-9819: Compartment mismatch with fetch API
   * CVE-2019-9820: Use-after-free of ChromeEventHandler by DocShell

   - Disable LTO (boo#1133267).

   - Add patch to fix build usingrust
Rust* Cross platform (well,Linux+ other unix-like OSs; Windows may work, I've never managed to getRustto work on it). 
 
It doesn't support much in the way of permissions/ACLs ATM, it's still an intermittent WIP. 
 
I did look at using O_DIRECT, but I get EINVAL
Linuxkernel, or you write in a larger subset of C with annotations to help the static analyzer/verifier prove absence of classes of bugs. The problem with the latter approach is that even though a C compiler might compile your code, you're not really writing C anymore, you're writing a superset of a subset of C that everyone other than the C compiler needs to understand. And is twisting the syntax and semantics of your language so that a C compiler can compile it really worthwhile, or should you take the opportunity to fix some of the bad C decisions? 
 
It's possible that creating your own language that's a bit likeRust
linux-libre 5.0.10, mate 1.22.0, ocaml 4.07.1,
 octave 5.1.0, openjdk 11.28, python 3.7.0,rust1.34.0, r 3.6.0,
 sbcl 1.5.1, shepherd 0.6.0, xfce 4.12.1, xorg-server 1.20.4

 ** Programming interfaces
 *** New ‘this-package’, ‘this-origin’, and ‘this-operating-system’ macros
 *** The ‘self-native-input?’ field was removed from <package>
 *** New ‘package
Linuxaway from unsafe-C to be able to disable current and future C-insecurity mitigations are practically zero. (Though it still might make sense to write parts of the kernel inRust... writing drivers inRustwould reduce the bug exposure and make reviewing them easier.) 
 
There's an opportunity
From: Alan SchmittTo: "lwn", "cwn"Subject: Attn: Development Editor, Latest OCaml Weekly News 
Message-ID: <87d0l3nb4b.fsf@polytechnique.org>
Date: Tue, 30 Apr 2019 10:36:04 +0200

Hello

Here is the latest OCaml Weekly News, for the week of April 23 to 
30,
2019.

Table of Contents
─────────────────

FYI
Licensing information is notoriously complex to get right.  Packages are
often made up of source files that come with their own licenses, based on
where the code originally came from—or the aims of the original
developers.  For example, even though theLinuxkernel is licensed under
GPLv2, it hasmanydifferent licenses throughout the tree.  Theeffortover the past few years to addSoftware Package Data Exchange(SPDX) headers
to the kernel's source files is still ongoing.  What seems like it should
be a simple, straightforward process turns out to be quite a bit less so.
Rust==

We've seen the discussion on the opensuse-project mailinglist why 
openSUSE wasn't at Cloudfest.

* base requirement (as always) is to have volunteers 
* commercial booth prices are insane, we'd have to find out if they 
  offer free community booths



Regards,

Christian Boltz
-- 
Es ist halt nur nicht eine einzige zentrale Filterdatei. Vorteil ist,
dass die Anwender ihre eigenen Scripte verwalten (und sich dabei in den
Fuss schiessen können). Nachteil ist genau das gleiche. (^-^)
[Sandy Drobic in suse-linux
rust, as it has some cheap volume to offer. 
 
Our potential customers' traffic pattern was: read-mostly, with numerous clients trying to download the bulk content from the servers. I.e., imagine a hundred HTTP server threads, each performing a sequential download of a large file - but in time, their individual read requests get interleaved, leading to a pretty good approximation of random access to the LBA address space of the disk (or RAID volume). 
 
BFQ seems to promise to solve something similar: apparently it tries to keep some "flow stats" per "control group" (?) and if the summary pattern for the group amounts to sequential access, it can do transaction combining to achieve performace benefits. Similar but not the same, I suspect. 
 
The "parallel readers" pattern is probably not what Facebook are facing - by the description they have a more varied mix of different load patterns, and basically consider the access paterns to be mostly random. 
 
I also tested a scenario with many parallel *writing* threads. Imagine a storage back end for surveilance video recording from many cameras. Here theLinux
Linux4.20 for head and 4.19 for the 12-STABLE branch.

   The DTS are now compiled for some arm64 boards, as the one present in
   U-Boot are not always up-to-date.
     __________________________________________________________________

ENA FreeBSD Driver Update

   Links
   ENA README URL:
    https://github.com/amzn/amzn-drivers/blob/master/kernel/f... 

   Contact: Michal Krawczyk <mk@semihalf.com>

   ENA (Elastic Network Adapter) is the smart NIC which is used in the
   virtualized environment of Amazon Web Services (AWS). It supports
   multiple queues and can handle up to 25 Gb/s, depending on the instance
   type on which it is used.

   ENAv2 has been under development for FreeBSD, similar toLinuxOS and
   DPDK. New changes are including:
     * Upgrade of the HAL to the version supporting ENAv2
     * Optimization of the logging on the Tx path
     * LLQ (Low Latency Queue) feature, which is reducing latency on
       instances supporting ENAv2
     * Optimization of the locks on hot paths by adding Tx queue
       management and lockless Rx queue cleanup
     * Fixes on the error handling paths
     * Use bitfield for tracking device states
     * Add additional doorbells on Tx path
     * Add queue depth setup in the runtime and allows Rx queue depth to
       be configured independently
     * And more minor bug fixes and code reorganization

   Todo:
     * Internal review
The next layers he described were those for filesystems.  In a traditionalLinuxfilesystem stack, there are neat layers starting with the block
device at the bottom, RAID and volume-management above that, dm-crypt for
encryption, an ext4 or other traditional filesystem layer, and finally the files
themselves available at a 
mount point.  As instructed, the audience said: "what if we got rid of some
of the layers?"
Sharing a disk between users inLinuxis awful.  Different applications
have different I/O patterns, they have different latency requirements, and
they are never consistent.  Throttling can help ensure that users get their
fair share of the available bandwidth but, since most I/O is in the
writeback path, it's often too late to throttle without putting pressure
elsewhere on the system.  Disks are all different as well.  You have
spinningrust, solid-state devices (SSDs), awful SSDs, and barely usable
SSDs.  Each class of device has its own performance characteristics and,
even in a single class, they'll perform differently based on the workload.
Trying to address all of these issues with a single I/O controller was
tricky, but we at Facebook think that we have come up with a reasonable
solution.
With the uptake of Python 3 (and the imminent end of life for
Python 2.7), there is a question of
which version of Python a user should get when they type "python"
at the 
command line or have it as part of ashebang("#!") line in a script.  Back in 2011,PEP 394("The
'python' Command on Unix-Like Systems") was created as an informational PEP
that relayed the recommendations of the Python core developers  toLinuxdistributions and others in a similar 
position about which version
to pointpythonto.  Now, Petr Viktorin, one of the authors of the
PEP, would like torevisit
those recommendations, which is something that issuggestedin the PEP 
itself.
rustplugin refactoring, and added support for
multipass. Relevant links are provided and 30 changes are listed.

 http://blog.sergiusens.org/posts/snapcraft-3.1/ 

=== What’s the OOPS ID? ===

Brian Murray writes of the difficulty to find the right OOPS ID for a crash and that he has made a
change to whoopsie to write the OOPS ID to the corresponding .uploaded file in /var/crash.
Presently only available in Disco Dingo, however, it can be made for other releases. Contact Brian
or update the bug report to push.

 http://www.murraytwins.com/blog/?p=167 

== Canonical News ==

 * Ubuntu at Embedded World 2019 -  https://blog.ubuntu.com/2019/02/04/ubuntu-embedded-world-... 
 * Fresh snaps from January 2019 -
 https://blog.ubuntu.com/2019/02/05/fresh-snaps-from-janua... 
 * Ubuntu 14.04 Trusty Tahr End of Life -
 https://blog.ubuntu.com/2019/02/05/ubuntu-14-04-trusty-ta... 
 * Ubuntu at Mobile World Congress 2019 -
 https://blog.ubuntu.com/2019/02/06/ubuntu-at-mobile-world... 

== In the Blogosphere ==

=== Intel Mesa Driver Getting Better Support For ETC2 On Older Hardware ===

Michael Larabel reports of Eleni Maria Stea's pending patches to improve the ETC2 format support on
"Gen 7" and older cards (Intel i965 Mesa driver). Michael gives a short definition of ETC2 and he
provides a link to Mesa-dev for more details.

 https://www.phoronix.com/scan.php?page=news_item&px=I... 

=== Canonical PatchesLinux
rustis more stable and works faster. (so called) user experience is more pleasant than on the previous versions without rust/servo. I have it on x86_64, aarch64 and armv7 and it works on all without any crash. On AlpineLinuxbugs.a.o we don't have any serious bug/issue, only
linux-image 4.15.0-44.47 kernel, or the
alternatelinux-image 4.18.0-14.15~18.04.1. The eleven patches encompass the seven flaws uncovered
by  Wen Xu, a race condition, two security issues discovered by Cfir Cohen and Wei Wu, and two
security vulnerabilities discovered by Jann Horn of Google Project Zero, and a fix in the HID
subsystem debug interface,. All users are encouraged to update immediately. Instruction/links are
provided to update your system.

 https://news.softpedia.com/news/canonical-outs-major-linu... 

=== NVIDIALinuxBeta Rolling Out "G-SYNC Compatible" FreeSync Monitor Support ===

Michael Larabel reports the release of the 418.30 driver that now has FreeSync support to reduce
tearing and stuttering. The driver supports GeForce GTX 1000 series graphics card or newer. The
driver is not generally available but must be obtained by a direct download from the Nvidia site.
Michael gives links to the release notes for more details as well as a link to his testing
results.

 https://www.phoronix.com/scan.php?page=news_item&px=N... 

=== Canonical Releases Snapcraft 3.1 Snap Creator Tool with Various Improvements ===

Marius Nestor reports of the first point release in the Snapcraft 3.x series tool. Application
developers now have the ability to clean parts, the "cmake" and "rust
Linux, Jami takes advantage of an
active development community thanks to the support of Google Summer of
Code developers, as well as research partnerships with Polytechnique
Montréal and the Université du Québec à Montréal. Visit GNU Jami at
the Free Software Directory at < https://directory.fsf.org/wiki/Jami >
or on Savannah at < https://savannah.gnu.org/projects/jami/ >.

 * < https://blog.savoirfairelinux.com/en-ca/card/ring-becomes... >

### UK health service prescribes nonfree "app therapy" for children

*From January 23 by Denis Campbell*

Cognitive behavioral therapy (CBT) can be an effective treatment for
depression and anxiety, but having it administered through a nonfree
app -- and to children, at that! -- is an extremely bad idea. The UK
National Health Service (NHS) will be prescribing "app therapy" to
children as young as age five in 2019, delivered via mobile phones,
tablets, or computers. This may give kids some relief for their mental
health issues, but it will also create a tremendous pool of
easily-harvested information about their day-to-day emotional state,
and neither children nor parents will be able to ascertain how it
works or how their information is used. This is a tremendous
injustice.
 
 * < https://www.theguardian.com/society/2019/jan/23/nhs-presc... >

### It's now clear that none
Many projects use continuous-integration (CI) testing to improve the
quality of the software they produce.  By running a set of tests after
every commit, CI systems  can identify problems quickly, before they find
their way into a release
and bite unsuspecting users.  TheLinuxkernel project lags many others in
its use of CI testing for a number of reasons, including a fundamental
mismatch with how kernel developers tend to manage their workflows.  Atlinux.conf.au 2019, Russell Currey
described a CI system calledSnowpatchthat, he hopes,
will bridge the gap and bring better testing to the kernel development
process.
LLVM and gcc support these stack probes onLinuxtoo.Rustuses them, I'm not sure if clang/g++ do.
Firecracker began as a fork of Google'scrosvmfrom ChromeOS. It runsLinuxguest VMs using theKernel-based Virtual Machine (KVM) APIand
emulates a minimal set of devices. Currently, it supports only Intel
processors, but AMD and Arm are planned to follow. In contrast to the QEMU
code base of well over one million lines of C, which supports much more
than just qemu-kvm, Firecracker is around 50 thousand lines ofRust.
Rust. Please review
the CVE identifiers referenced below for details.

Impact
======

A remote attacker able to control the value passed toRust's
str::repeat function could possibly cause a Denial of Service
condition.

In addition, a local attacker could trick another user into executing
arbitrary code when using rustdoc.

Workaround
==========

There is no known workaround at this time.

Resolution
==========

AllRustusers should upgrade to the latest version:

  # emerge --sync
  # emerge --ask --oneshot --verbose ">=dev-lang/rust-1.29.1"

AllRustbinary users should upgrade to the latest version:

  # emerge --sync
  # emerge --ask --oneshot --verbose ">=dev-lang/rust-bin-1.29.1"

References
==========

[ 1 ] CVE-2018-1000622
       https://nvd.nist.gov/vuln/detail/CVE-2018-1000622 
[ 2 ] CVE-2018-1000810
       https://nvd.nist.gov/vuln/detail/CVE-2018-1000810 

Availability
============

This GLSA and any updates to it are available for viewing at
the Gentoo Security Website:

  https://security.gentoo.org/glsa/201812-11 

Concerns?
=========

Security is a primary focus of GentooLinux
Linuxand
    `sandbox-exec' on OSX to ensure that package scripts:
    • don't make any network access
    • don't interact with other processes
    • don't write outside of their build dir, /tmp, and (in the case of
      install) the switch prefix (excl. opam files)

  • this is done using simple wrapper scripts [2] and some default hooks
    configuration in ~/.opam/config, so if you know about built-in
    sandboxing engines for other OSes, it is fairly easy to experiment
    with them, and a contribution would be very welcome.

  • while I expect this to be reasonably secure, it's intended first and
    foremost to avoid dramatic errors, not to protect against malicious
    repositories

  • package scripts are protected but **not any use made by the users of
    the programs or libraries that were installed through opam**. In
    other words, building should be safe, but there is no guarantee
    about what the result of the build will do: that is not restrained
    by opam in any way

  • the effort to provide end-to-end package signatures in the
    repository [3] is still ongoing. Cheers to Hannes Mehnert for the
    awesome work he has already done here. Most of the work should be
    done, but then
Linuxuser, even Fedora users, can easily consume? And though this approach creates a pile of ongoing work for the software vendor, it also brings back the issue of whether you trust the application vendor to choose good versions of dependent libraries and keep them up to date. 
 
TheRust
Rustports for 20 different architecture targets for glibcLinux. Even if you remove targets that are ISA supersets of other targets (i.e. collapse various 32-bit ARM flavors, collapse 32-bit x86 with and without SSE2) but still count 32-bit and 64-bit flavors separately, the count is still
Linuxhistory 
 - the list of packages broken is limited: but still, it's highly unlikely that nobody will be impacted and the list will only grow in the future 
 
I think the good solution is to make more (all) arch supportrust(Glaubitz did some good work in this direction
Rusthas its own conditional compilation mechanisms and target-specific mechanisms, as well as many other ways it needs to know about the details of the target platform. Going by way of C does not automatically make it perfectly portable. Quoting  https://github.com/thepowersgang/mrustc/blob/master/READM...  : 
 
 > - Supported Targets:  
 >   - x86-64linux
rusthas the option to generate C code,  
 
This is just wishful thinking.Rustis not C, that is, not allRustcan be 1:1 mapped to C. A lot ofRustis platform specific, so even if one could compileRustto C, one would need a platform library abstracting syscalls, libc, compiler extensions, etc. wrapping the C systems APIs way beyond what libc offers. 
 
Unless a big company pays 100 people to work on this full-time for a couple of years, this won't become production ready enough such that hobbyist can start modifying the parts required for the resulting C to even compile in the less supported platforms.  
 
If you only want to target x86_64linux
LinuxFrom Scratch[1] it involves building the toolchain three times: First you build a cross-compiler using the host tools, then you use that cross-compiler on the host to build a native toolchain and other packages required for standalone operation (what LFS calls the "temporary system"), and finally use this temporary system to build the host-independent tools. 
 
This is for a complete system, of course, but bootstrapping a compiler is similar. Use the host'sRust
Rust, on the other hand, most people in Debian suddenly don't care about portability anymore and just accept thatRustis breaking multiple architectures and kFreeBSD and the Hurd.  
 
 > So, it seems that either priorities within Debian have changed or the portability argument against systemd was just an excuse back in 2014.  
 
I'd strongly suggest it's the former. systemd's approval itself was a death knell for kFreeBSD -- it'll never again have the prominence it once had (something which I personally think is a shame and a loss for the entireLinux
The other potential candidate forRustsupport is m68k. There are ongoing
efforts to add m68k to both LLVM andRustand while many people think
that supporting modernLinuxsoftware on 30 year-old hardware is insane, I think
it's actually fun :-).
From: Alan SchmittTo: "lwn", "cwn"Subject: Attn: Development Editor, Latest OCaml Weekly News 
Message-ID: <877ehqbhw4.fsf@inria.fr>
Date: Tue, 06 Nov 2018 11:49:15 +0100

Hello

Here is the latest OCaml Weekly News, for the week of October 23 to
November 06, 2018.

Sorry for the
Rustcode
  muparser-2.2.6.1: Fast Math Parser Library
   pid-tools-5.0.1: Commandline tools for dealing with pids
  python2-future-0.16.0: Clean single-source support for Python 3 and 2
  python2-uTidylib-0.4: TidyLib Python wrapper
  python3-uTidylib-0.4: TidyLib Python wrapper
  python-future-0.16.0: Clean single-source support for Python 3 and 2

Removed modules: (43)
  akonadi4
  automoc4
  ctl
  gluon
  guidance-power-manager
  kdelibs
  kdepimlibs4
  kdevplatform
  kde-workspace
  kfax
  kgrab
  kimono
  kmid
  kmldonkey
  korundum
  kradio4
  kvpnc
  kwebkitpart
  libbluedevil
  libdbusmenu-qt
  libkdcraw4
  libkdegames4
  libkexiv2-4
  libkipi4
  libksane4
  libkscreen4
  nepomuk-core
  nepomuk-widgets
  oxygen-icons
  perlkde
  perlqt
  pykde4
  qimageblitz
  qmpdclient
  qtpfsgui
  qtruby
  qyoto
  signon
  smokegen
  smokekde
  smokeqt
  strigi
  uTidylib

New versions: (73)
  abi-compliance-checker  :         1.99.25 ->             2.3
  abi-dumper              :         0.99.19 ->             1.1
  audacious               :             3.9 ->            3.10
  audacious-plugins       :             3.9 ->            3.10
  bzflag                  :          2.4.16 ->          2.4.18
  cairo                   :         1.15.12 ->          1.16.0
  c-ares                  :          1.14.0 ->          1.15.0
  cups-filters            :          1.21.2 ->          1.21.3
  dconf                   :          0.30.0 ->          0.30.1
  dnsmasq                 :            2.79 ->            2.80
  docker                  :         18.05.0 ->         18.06.1
  evolution               :          3.30.1 ->          3.30.2
  evolution-data-server   :          3.30.1 ->          3.30.2
  file                    :            5.34 ->            5.35
  firefox                 :          62.0.3 ->            63.0
  gedit                   :          3.30.1 ->          3.30.2
  gnome-terminal          :          3.30.1 ->          3.30.2
  harfbuzz                :           1.9.0 ->           2.0.2
  hedgewars               :    src-0.9.20.5 ->    src-0.9.24.1
  httpd
LinuxEnterprise Module for Development Tools 15:

      zypper in -t patch SUSE-SLE-Module-Development-Tools-15-2018-2403=1



Package List:

   - SUSELinuxEnterprise Module for Development Tools 15 (aarch64 ppc64le s390x x86_64):rust-1.24.1-3.6.1rust-debuginfo-1.24.1-3.6.1rust-debugsource-1.24.1-3.6.1rust-std-1.24.1-3.6.1


References
Linuxand BSD kernels, where parochial FUD still rules) is essentially all in C++, for thoroughly practical reasons. Writing programs in modern C++ is just more productive than alternatives, and the language is still improving at a fast pace. C++20 is to have Concept, Module, and Contract support. C++23 is already in the works. 
 
Other languages with less history are approaching readiness, but success is still many years off. It's far from clear which the winners will be. Can Haskell be beefed up for industrial use? CanRust
For too long, the Open Source world has been complicit with Google in undermining the privacy and freedom of Android users. It's understandable—Android has helped makeLinuxthe most widely used operating system in the world, overthrowing Windows. Fighting against Google in the early days of smartphones, as it tried to establish Android as an alternative to completely proprietary offerings, would have been quixotic. But the time has come to assert free software's underlying ethical foundation and to move on from an Android world to something better—in all senses. Whether that will be Duval's eelo or something else is a matter for the Open Source community to debate. But it's a debate that we need to have now, as a choice, before it becomes a necessity.
Rust. Quite the prolific, largely unsung inventor. 
 
I knew Graydon from my time at Red Hat, where we both worked for Red Hat and met from time to time in the Toronto offices of the former Cygnus. Around that time, I was also casting around for a good design model for a distributed revision control system, as an alternative to Bitkeeper. I found Monotone, some months before the drama unfolded resulting in Linus's post above. Then, Monotone had no concept of directories, it only had a flat forest of objects with each content-hashed object indexed under the full path name. 
 
One day in some dim hallway, possibly at Red Hat headquarters during a conference, I buttonholed Graydon and launched into a polemic about what I thought needed to be done to Monotone to make it truly useful. That was basically, elaborate the metadata design so that directories are objects too. Graydon initially found the idea offensive compared to what he perceived as his simpler and purer approach, but the next time I saw him, he informed me that he had in fact changed Monotone's metadata design along those lines, and Monotone's manifest was born. This
Linuxhas no monopoly on hibernate bugs). 
 
Back in the days of spinningrustin laptops you could break the hard drives with surprise hibernations too.  Even today a hot SSD is not a happy SSD, and severe data loss can be expected. 
 
Current laptops can sit for days in suspend
Linus andLinuxare fairly regularly used in keynotes as _the_ example of a toxic/dysfunctional community. e.g.rustjust recently: 
 
 https://www.youtube.com/watch?v=J9OFQm8Qf1I&feature=y...  
 
(jumps directly to the right spot)
Rust, and anyway unsigned integers wrapping around is nowhere near so benign as many like to believe. 
 
There would be no problem with C++ in theLinuxkernel if not for mindless bigotry, with many fewer opportunities for silly-bugger mistakes, and both faster and shorter code. It will happen
Sound good, though ultimately I'd like kernel devs to adoptRustas their mainLinuxkernel development language. Beats the crap out of C and C++ combined.
While Dat is designed to work on larger data sets, processing them
for sharing may take a while. For example, sharing theLinuxkernel source code required about five minutes as Dat worked on
indexing all of the files. This is comparable to the performance offered byIPFSand BitTorrent. Data sets with
more or larger files may take quite a bit more time.
Like most recent open-source conferences, OSCON included talks aboutLinuxcontainers and container orchestration.  One of these,
 "TL;DR: NIST container security standards," was
presented by CoreOS staff Elsie Phillips and Paul Burt. In 2017, the US
government'sNational Institute of
Standards and Technology(NIST) released a report titled "NIST Guidance
on Application Container Security."  Thisreportwas issued with uncharacteristic alacrity by the usually slow-moving
government agency, which generally advises on technologies well after
they've become mainstream.  NIST staff apparently wanted to make
recommendations to curb what they saw as an alarming ignorance ofLinuxcontainer security requirements.
Rustis not Java even if there are corporation backed contributors. And about the "niche language" aspect, that's true that theRustcommunity is (at least for the moment) smaller than the Python one, butRustis quite young too. What I tried to communicate was that it just seems to work and that from the beginning they tried to follow a scalable approach to language design. 
 
Their is not much example of bad "dictatorized" project still around, because they tend to die or to be forked. However, I realize that perhaps I misunderstood what you were meaning with "dictatorship" : are you, by this word, speaking about arbitration authority ? Like, the Debian Technical Committee, the LibreOffice Engineering Steering Committee, how the various project in Apache are managed and so on ? Having a unique Man having the role of a local god is not the most successful way of doing community but yes, there are some real high profile exceptions. And even then, in the case ofLinux
Since it was a keynote, he gave a "pre-recorded demo" of callingRustfrom
Python.   He compiled a Fibonacci function inRustto a.dylibon
his Mac (which is a shared library, like a DLL for Windows or a.soforLinux).  Then with "four lines of boilerplate" (using thecffimodule), he can call
theRustfunction from Python.
Linuxcould take hours and run out of memory on a different standard-compliant run-time which would copy all the strings. And there was no reasonable way to fix the performance bug without causing unpredictable performance regressions in other valid programs. 
 
What I'm getting to here is that the performance characteristics of strings, dictionaries and lists is part of the contract. Even if left unspecified, a lot of code in the wild will start depending on it. And once you specify the exact behavior and complexity of all the basic operations on a container, this leaves very little room for changing the internal representation in a significant way. 
 
Over time, Python 3 grew some clever string optimizations to mitigate the overhead of converting strings on the I/O boundary. But these optimizations are inherently data dependent. Let's say I want to read a 100MB html file into a string and then send it over a socket. This will take roughly 100MB of RAM in Python 2, while a Python 3 program will jump from 100MB to 400MB after someone inserted a single emoji in the middle of the file. 
 
While dynamic, garbage-collected languages are expected to have
A version of ZFS, originally developed by Sun Microsystems for Solaris (now
owned by Oracle), was forked for use on other platforms includingLinux(OpenZFS). However, itsCDDL-licensed
code is not able to be merged into the
GPLv2-licensedLinuxsource tree. Whether CDDL and GPLv2 are truly incompatible is a continuing
subject for debate, but the uncertainty is enough to make some enterpriseLinuxvendors unwilling to adopt and support it.
more broadly, new toolchains are LLVM-based (rust, etc), Google is developing Fuchsia which replaces theLinuxkernel, uses an LLVM-based toolchain, and replaces pretty much everything else in the "stack", and so on. There might not be much GPL code left if that succeeds and picks up momentum.
From: Theo de RaadtTo: tech@openbsd.org 
Subject: OpenBSD 6.3 released - Apr 2, 2018 
Message-ID: <93685.1522676970@cvs.openbsd.org>
Date: Mon, 02 Apr 2018 07:49:30 -0600
List-ID:  

The release was scheduled for April 15, but since all the components
are ready ahead of schedule it is being released now
Linux> > 7 if you need C++11 support.  The system compiler, GCC 4.8, 
  > > has limited support only.
  > 
  > When switching the programming langauge than I would think there 
  > are some better C-successors than C++, namelyRust? Mad rush of 
  > giving up on 46 years
Linux>> 7 if you need C++11 support.  The system compiler, GCC 4.8,
  >> has limited support only.
  >
  > When switching the programming langauge than I would think there
  > are some better C-successors than C++, namelyRust? Mad rush of
  > giving up on 46 years
Linux> 7 if you need C++11 support.  The system compiler, GCC 4.8, 
  > has limited support only.
 
When switching the programming langauge than I would think there 
are some better C-successors than C++, namelyRust? Mad rush of 
giving up on 46 years old language and switching
RustABI, after all there's no stable C++ ABI either, but the issue is exaggerated by theRustecosystem's obsession with microdependencies (there are modules which are really just one function, à la npm), and the fast speed at which theRustcompiler moves. 
 
 >practically allRustLinux
RustLinuxbinaries dynamically link to glibc by default (and by design), and you can easily dynamically link to C ABI shared libraries. If you want to build a static executable, you have to go out of your way to use the musl target. 
 
There's nothing "unsafe" about dynamic
Linuxbuild process must be one of the most wasteful things you can do on a computer
 
Oh God no. Compiler build processes with multiple-stage bootstrapping is the first thing that springs to mind (GCC building is *far* harder on a machine thanLinuxkernel building and most of it is thrown away); but then you look at new stuff likeRust
rusttowards SSD.  We also discussed the static.debian.org setup and whether
we could move that to a "caching proxy" setup, either by running our own
or relying on a partner CDN.

== security.debian.org
The traffic for security.debian.org currently peaks at around 25Gbps
globally for just thelinuxkernel in a single
Eventually he started scratching his own itch in the graphics subsystem,
which led to him getting hired to work onLinuxgraphics professionally on
a small team.   He got volunteered to be the kernel maintainer for that
team, which grew from three to twenty people in a year or two.  In that
time he learned the
tough lesson that "leading teams is leading people".  But he has
learned that the way kernel maintainers work is making developers unhappy,
including him.  The talk would be a look at how he learned just how broken
things are.
As part of the announcement, Hoyer makes a sweeping claim about the current
API to aLinuxsystem:  it could all be replaced with varlink-based
interfaces.  In that statement, he includes kernel interfaces, such asioctl()and 
other system calls, procfs, and sysfs; theLinuxcommand-line interface;
and various IPC mechanisms including D-Bus and Protobuf.  There is akernel modulethat
allows varlink interfaces to be added to the kernel, but it is a little
hard to see the kernel API being replaced, even if it was deemed desirable.
It would be decades (if not
longer) before the existing kernel interfaces could be removed, which would
make for a maintenance headache at minimum.
in network service development use cases (especially those based onLinuxcontainers), the process locale may not be configured at all, and if
it isn't, then the expectation is that components will impose their own
default encoding the wayRust, Go and Node.js do, rather than trusting the
legacy C default encoding of ASCII the way CPython currently does
will amount to choosing whether to keep or abandon relevance.  It's not there yet.   
 
Indeed the competition for theLinuxkernel is unfortunately nowhere near yet. In fact I haven't really seen any at all. I betRustwill pass C++ long before there's any credible one.
There is interest in using the systems programming languageRustfor
GStreamer development to improve memory and thread safety and to use modern
language features. In another talk, Sebastian Dröge described the
current state of theGStreamerRustbindings. They have been in development for quite some time and many 
people are actively developing with them. The bindings provide a mostly
complete set of functionality for both application and plugin development,
and no longer require the use of "unsafe" sections by users of the
bindings. They are mostly auto-generated now via GObject introspection and have
a nativeRustfeel while retaining the same API usage patterns familiar to
anyone used to working with GStreamer.
Rustapplications to the Ports Collection. This is further
   detailed in a separate entry in this quarterly status report.

   The compiler, rustc, is crashing sometimes when there is a compilation
   error. Therefore, there is a bit of work to do to improve its
   stability.

   There is some code duplication between the lang/rust* and devel/cargo
   Makefiles. These all deserve a bit of cleanup, and it might be useful
   to create a USES=rustMakefile helper.

   Open tasks:

    1. BootstrapRuston more platforms.
    2. Investigate compiler crashes.
    3. Investigate how to speed up lang/rust* compilation times.
     __________________________________________________________________

sndio Support in the FreeBSD Ports Collection

   Links
   Sndio Homepage
    URL:  http://www.sndio.org 
   Sndio Paper
    URL:  https://www.openbsd.org/papers/asiabsdcon2010_sndio.pdf 
   Comprehensive and Biased Comparison of OpenBSD and FreeBSD (Section 17)
    URL:  https://www.bsdfrog.org/pub/events/my_bsd_sucks_less_than... 

   Contact: Tobias Kortkamp <tobik@FreeBSD.org>

   sndio is a small audio and MIDI framework that is part of the OpenBSD
   project. It provides a lightweight audio and MIDI server, sndiod. It
   currently supports OpenBSD, FreeBSD, DragonFly BSD, andLinux
Rust, and Swift which principally rely on a static compilation model. I regularly make the point to peers and in forums that the evolution of dynamic linking emerged for very valid reasons, and the present trend back to static compilation has probably already gone too far. My point regarding copy+paste'able code is nuanced--that it can real value under the right circumstances, and cipher code is something where this can matter. And as attackers being to exploit hardware-based cryptographic implementations, the value of analogous qualities in hardware toolkits (copy+paste'able HDL?) will show itself. 
 
[1] Especially consider that system randomness is shared and doesn't currently scale well. Efforts to make it lockless introduce substantial complexity in a subsystem that should be kept as simple and transparent as possible. It's wasted effort considering that the solution of splitting the work between kernel and userspace is proven (see OpenBSD) to work well, naturally leveraging existing interfaces in an unobtrusive manner. 
 
[2]Linux
Rustproject has chosen to provide expressive power, and in many cases better defaults than C++, while making it harder to accidentally do many (but not all) unsafe operations.  In ten or twenty years, if it matures well, it may be a good choice for implementing a successor toLinux
Rust.

The v1.3 release is the 13th and the biggest public release in the history
of BAP, that brings lots of new stuff, including:

* New OGRE loader that works smoothly with all sorts of the binaries,
includingLinuxand Darwin kernel modules, shared libraries, and other
peculiar program representations
* Memory
thread onlinux-raid where data loss seems to have been tracked down to the fact that the drive said "yes I've got the data", then lost it somewhere between the cache and rotatingrust... 
 
(Oh, and fixing that - disabling write cache - really f***s up performance.) 
 
Cheers, 
Wol
Linux, but whereRusthas  missing or limited support . You may or may not care about these architectures in any given project, theRusttoolchain is getting better at this over time, etc., but even if you're only interested inLinuxthen it is still an issue to think
Rustand Go are still too immature in any number of ways -- portable to too few target architectures, too uncertain of future vigor, too little-known, with too few independent implementations, and too little third-party tool support -- to be a wise choice of language for ambitious projects today. In ten or twenty years each might be mature enough (or fading, and weren't you wise to have avoided it?).  While it should be obvious to all that C is too problem-ridden to be a good choice for new projects, and is frankly too expensive to code in, C++, used well, happily avoids all of C's problems, is as mature, portable, and vigorous as anyone can ask for, and is markedly *faster* than C, besides. 
 
But perhaps an even better question is, why should any new project depend on D-bus, and confine itself to such a limited target base?  The overwhelming majority of programming targets worldwide have some sort ofLinux
linux/{hash, poison}.h and check for drift (Jiri Olsa) 
[1387909]
- [tools] perf tools: Remove include/linux/list.h from perf's MANIFEST 
(Jiri Olsa) [1387909]
- [tools] Copy the bitops files accessed from the kernel and check for 
drift (Jiri Olsa) [1387909]
- [tools] remove: kernel unistd*h files from perf's MANIFEST, not used 
(Jiri Olsa) [1387909]
- [tools] perf tools: Remove tools/perf/util/include/linux/const.h (Jiri 
Olsa) [1387909]
- [tools] perf tools: Remove tools/perf/util/include/asm/byteorder.h 
(Jiri Olsa) [1387909]
- [tools] perf tools: Add missing linux/compiler.h include to perf-sys.h 
(Jiri Olsa) [1387909]
- [tools] perf jit: Remove some no-op error handling (Jiri Olsa) [1387909]
- [tools] perf jit: Add missing curly braces (Jiri Olsa) [1387909]
- [tools] perf record: Add --tail-synthesize option (Jiri Olsa) [1387909]
- [tools] perf session: Don't warn about out of order event if 
write_backward is used (Jiri Olsa) [1387909]
- [tools] perf tools: Enable overwrite settings (Jiri Olsa) [1387909]
- [tools] perf evlist: Make {pause, resume} internal helpers (Jiri Olsa) 
[1387909]
- [tools] perf record: Read from overwritable ring buffer (Jiri Olsa) 
[1387909]
- [tools] perf evlist: Setup backward mmap state machine (Jiri Olsa) 
[1387909]
- [tools] perf evlist: Drop evlist->backward (Jiri Olsa) [1387909]
- [tools] perf evlist: Map backward events to backward_mmap (Jiri Olsa) 
[1387909]
- [tools
linux/{hash, poison}.h and check for drift (Jiri Olsa) 
[1387909]
- [tools] perf tools: Remove include/linux/list.h from perf's MANIFEST 
(Jiri Olsa) [1387909]
- [tools] Copy the bitops files accessed from the kernel and check for 
drift (Jiri Olsa) [1387909]
- [tools] remove: kernel unistd*h files from perf's MANIFEST, not used 
(Jiri Olsa) [1387909]
- [tools] perf tools: Remove tools/perf/util/include/linux/const.h (Jiri 
Olsa) [1387909]
- [tools] perf tools: Remove tools/perf/util/include/asm/byteorder.h 
(Jiri Olsa) [1387909]
- [tools] perf tools: Add missing linux/compiler.h include to perf-sys.h 
(Jiri Olsa) [1387909]
- [tools] perf jit: Remove some no-op error handling (Jiri Olsa) [1387909]
- [tools] perf jit: Add missing curly braces (Jiri Olsa) [1387909]
- [tools] perf record: Add --tail-synthesize option (Jiri Olsa) [1387909]
- [tools] perf session: Don't warn about out of order event if 
write_backward is used (Jiri Olsa) [1387909]
- [tools] perf tools: Enable overwrite settings (Jiri Olsa) [1387909]
- [tools] perf evlist: Make {pause, resume} internal helpers (Jiri Olsa) 
[1387909]
- [tools] perf record: Read from overwritable ring buffer (Jiri Olsa) 
[1387909]
- [tools] perf evlist: Setup backward mmap state machine (Jiri Olsa) 
[1387909]
- [tools] perf evlist: Drop evlist->backward (Jiri Olsa) [1387909]
- [tools] perf evlist: Map backward events to backward_mmap (Jiri Olsa) 
[1387909]
- [tools
Linuxusers, it's time to upgrade Ubuntu -
 https://nakedsecurity.sophos.com/2017/07/24/yakkety-yak-w... 
* Ubuntu 17.10: Back to a GNOME Future -
 https://www.linux.com/learn/intro-to-linux/2017/7/ubuntu-... 
 * Canonical Looking for user input on software selection for Ubuntu -
 https://www.ghacks.net/2017/07/28/canonical-looking-for-u... 
 * The Elusive TotalLinuxConvergence Dream -
 http://www.linuxinsider.com/story/The-Elusive-Total-Linux... 
 * Canonical Works onLinux4.13 for Ubuntu 17.10, GCC 7 Transition in Early August -
 http://news.softpedia.com/news/canonical-works-on-linux-4... 

== In Other News ==

 * Full Circle Weekly News #67 -  http://fullcirclemagazine.org/podcast/full-circle-weekly-... 

== Featured Audio and Video ==

=== Ubuntu Podcast from the UK LoCo: S10E20 - Wry Mindless Ice ===

"It's Season Ten Episode Twenty of the Ubuntu Podcast! Alan Pope, Mark Johnson and Martin Wimpress
are connected and speaking to your brain.

We discuss tormenting Mycroft, review the Dell Precision 5520, give you some USB resetting command
line lurve and go over your feedback."

 http://ubuntupodcast.org/2017/07/20/s10e20-wry-mindless-ice/ 

=== Ubuntu Podcast from the UK LoCo: S10E21 - Godly Heady Airport ===

"It's Season Ten Episode Twenty-One of the Ubuntu Podcast! Alan Pope, Mark Johnson and Martin
Wimpress are connected and speaking to your brain.

This week we've been making a distro and playingRust
rustand Java environments which are trying to implement their own stack
guard page.  They are punching a new MAP_FIXED mapping inside the
existing stack Vma.

This will confuse expand_{downwards,upwards} into thinking that the stack
expansion would in fact get us too close to an existing non-stack vma
which is a correct behavior wrt. safety. It is a real regression on
the other hand. Let's work around the problem by considering PROT_NONE
mapping as a part of the stack. This is a gros hack but overflowing to
such a mapping would trap anyway an we only can hope that usespace
knows what it is doing and handle it propely.

Fixes: d4d2d35e6ef9 ("mm: larger stack guard gap, between vmas")
Debugged-by: Vlastimil Babka <vbabka@suse.cz>
Cc: stable
Signed-off-by: Michal Hocko <mhocko@suse.com>
---
Hi,
the original thread [1] has grown quite large and also a bit confusing.
At least therustpart should be fixed by this patch. 32b java will
probably need something more on top of this. Btw. JNI environments rely
on MAP_FIXED PROT_NONE as well they were just lucky to not hit the issue
yet I guess
Linux.)
 
  As I understand it, it seemsRustis supported on llvm/Clang, so it will run on any hardware that llvm/Clang is supported on.  
 
Not necessarily. People could still be pulling tricks in the implementation that don't work the same on every architecture even if LLVM/Clang run on it.
Rustsupport a given architecture.  
 
I wish people could tell the difference between maths and reality ... seriously, this whole argument is arse-about-face.Rust*does* *not* "support whatever architecture". VB does not support x86. Visual C++ does not support x86. They are *supported* *on* x86/Windows. 
 
Just look atlinux
Rustuntil or unless the software can be built for all the architectures in Debian (or maybe you're using some other yardstick for the relevance of an architecture). To this, I'd put forward two counterpoints. 

 (a) The cataract model of language and API design only works for the most trivial DSLs. For something decidedly nontrivial, you need a lot of iterations and feedback and whatnot. People who care about no longer having to audit, statically analyze, symbolically/concolically execute or otherwise test millions of like of C/C++ code for memory safety violations and data races, do the language a great service (and hence, further their goals) by actually putting it to its intended use. Not only do their efforts provide valuable feedback on what to prioritize in language development, they are also coming up with best practices and proving out the language to people who are wondering whether it's worth getting their feet wet. I don't think the importance of these efforts can be understated. 

 (b) It seems to me that the current practice in Debian or theLinux
Rustcargo. They each do things differently, they're all at odds with curated distribution level packaging (of which there are also multiple different ways in theLinuxworld).  
 
So we're back to the common denominator: HowLinuxC builds, tracks and combines dependent bits of code. That's likely
Rustis far less portable than C. 
 > No, it's not.Rust's compiler is less portable than gcc.  
 
What are you arguing about semantics now? 
 
 > >  https://buildd.debian.org/status/package.php?p=gcc-6& ;;...  
 > So? It doesn't have Itanium, for example.  
 
Because no one was willing to work on Itanium in Debian and Debian's glibc package removed support for Itanium. However, one architecture not being supported doesn't invalidate my point. 
 
There are, in fact, more architectures supported in Debian than currently being built for: 
 
 >  https://jenkins.debian.net/view/rebootstrap/   
 
 >> So, saying that most exotic architectures in GCC are unsupported is not correct from my own experience.  
 > These are not nearly exotic. Try some microcontrollers that don't even exist anymore but still have machine definitions.  
 
They are exotic enough forRustand LLVM. 
 
 > I very much prefer to have a CI-tested version of the code rather than something "maintained" by not touching it and hoping that it works.  
 
All the architectures listed on buildd.debian.org and in Debian rebootstrap are CI-tested. 
 
 >> There are a lot of architectures that theLinux
Rustis far less portable than C.  
No, it's not.Rust's compiler is less portable than gcc. 
 
 > >  https://buildd.debian.org/status/package.php?p=gcc-6& ;...  
So? It doesn't have Itanium, for example. 
 
 > So, saying that most exotic architectures in GCC are unsupported is not correct from my own experience.  
These are not nearly exotic. Try some microcontrollers that don't even exist anymore but still have machine definitions.  
 
I very much prefer to have a CI-tested version of the code rather than something "maintained" by not touching it and hoping that it works. 
 
 > There are a lot of architectures that theLinux
Rustcan support pretty much anything, there's even a 16-bit fork of it for AVR and there are no platform-specific parts in its basic runtime. So as long as LLVM supports an architecture, portingRustto it is mostly a matter of going through a well-documented bootstrap process:  https://github.com/rust-lang/rust/tree/master/src/bootstrap .  
 
We're not talking about theory here. We're talking about the actual situation and this shows thatRustis far less portable than C. 
 
 >Rustteam simply has limited manpower and access to hardware to properly run continuous integration on all exotic platforms to guarantee the resulting product quality. This is no different from GCC, though. Some of "supported" gcc architectures had probably bit-rotted long ago.  
 
Debian's build results disagree with that stance: 
 
 >  https://buildd.debian.org/status/package.php?p=gcc-6&...   
 
On a sidenote: I'm a very active porter within Debian and I have reported plenty of gcc and binutils bugs upstream even for obscure architectures like m68k and SH and so far, all bugs were fixed by upstream in time. So, saying that most exotic architectures in GCC are unsupported is not correct from my own experience. 
 
 >> TheLinux
Rustcurrently supports x86_64, x86_32, ARM and POWER8 only while only x86_64 and x86 are guaranteed to work. C, on the other hand, supports basically every architecture that was ever perceived by mankind. That's quite a difference.Rustcan support pretty much anything, there's even a 16-bit fork of it for AVR and there are no platform-specific parts in its basic runtime. So as long as LLVM supports an architecture, portingRustto it is mostly a matter of going through a well-documented bootstrap process:  https://github.com/rust-lang/rust/tree/master/src/bootstrap  .Rustteam simply has limited manpower and access to hardware to properly run continuous integration on all exotic platforms to guarantee the resulting product quality. This is no different from GCC, though. Some of "supported" gcc architectures had probably bit-rotted long ago. 
 
 >  TheLinux
Rustis currently highly unportable.  
 > Yeah, and it also eats children for breakfast. A bad language, indeed.  
 
No need to be cynical. 
 
 > Why isRustcode any more "unportable" than C code?  
 
Well, for a starter,Rustcurrently  supports x86_64, x86_32, ARM and POWER8 only while only x86_64 and x86 are guaranteed to work. C, on the other hand, supports basically every architecture that was ever perceived by mankind. That's quite a difference. 
 
Thus, writing anything inRustthat needs to be portable like theLinux
Wow, soRustalready supports 6(!) out of the more than 30 
architectures that theLinuxkernel supports.
> I do hope that one dayLinuxplumbing will move to a safer language lineRust.  
 > For example all the "*d" layer above the kernel, etc.  
 
This will not happen untilRustbecomes actually portable.
I do hope that one dayLinuxplumbing will move to a safer language lineRust. For example all the "*d" layer above the kernel, etc.
Python 3.7 is as fast as Python 2.7 on most benchmarks, but 2.7 was
released in 2010.  Users are now comparing Python performance to that ofRustor Go, which had only been recently announced in 2010.  In his opinion, the
Python core developers need to find a way to speed Python up by a factor of
two in order for it to continue to be successful.
Linuxruns on. So, I would make sure it's better than just "Better  than nothing". 
 
 > On the Mozilla side of things, i think they have extremely limited CI resources when it comes to non-x86/arm hardware, so, i think these are considered tier 3.  
 
If they don't have the resources, maybe they should reconsider making their own systems programming language. 
 
TheLinuxkernel supports close to 30 architectures. If you want to be able to seriously compete with C/C++ (which they do), you should at least be able to support half of that. Golang supports far more targets thanRust
Ruston non-x86Linuxtargets, but there is a PR open to add an ARM target tested via qemu [3].  
 > I don't understand why you think testing on QEMU is a reasonable idea. It isn't. QEMU is not guaranteed to behave like real hardware, so it should
Rusthas promised to this point to support Firefox onLinuxare implemented: mips, ppc, and s90x builds of rustc [1][2]. If there is more needed or expected from theRustteam at this time, I am not aware, and would like to discuss it (ideally not on this
Rustplatform support and CI.  

The coverage improvementsRusthas promised to this point to support Firefox onLinuxare implemented: mips, ppc, and s90x builds of rustc [1][2]. If there is more needed or expected from theRustteam at this time, I am not aware, and would
Linuxdistribution model. CoreOS, NixOS, and QubeOS come to mind. IMHO, kudos and such re-thinking needs to always be encouraged. 
 
And then there are distributions who delivers almost the same stuff and keep bike-shedding at both the plumbing layer and the GUI layers level. Thankfully for the plumbing layer at least, systemd shattered all that needless bike-sheddig nonsense in the foreseeable future. Hopefully it will even remove the ugly SELinux/AppArmor/SMACK bike-shedding soon through an easy configuration language of its own. 
 
Bike-shedding is still there in the upper layers though, where a group of people change some themes, or add a graphical framework + some applications, and call it a distribution. 
 
Over time though, technology disruption always removes "the middle man". This will hopefully be exactly the case withLinuxdistributions. 
 
Artistic control is getting back to upstream developers. Now the upstream engineers develop a single systemd service file and it will work the same for all distributions, along with logging, service discovery, cgroups sandboxing, etc. This is also the same at the dependency-resolution layer: artistic control is removed from distributions back to language-native dependency resolvers in NodeJS, Ruby, andRust
He got involved with open source in the 1990s; he actually started withLinux, but somebody told him that "Linuxis rubbish" and he should use
FreeBSD instead.  So he bought an iMac computer and got FreeBSD running on
it; the project then punished him by giving him commit access.  It is a
great project, but it does have some problems relating to three factors in
particular: FreeBSD is big, it's old, and its leadership can be slow to
act.
Rust: Debugging programs written inRustis now supported.

 * Fortran: Support structures with fields of dynamic types and
   arrays of dynamic types.

 * Various Python enhancements (new convenience functions,
   enhanced support for breakpoints).

 * Various GDBserver enhancements:

    ** btrace recording without maintaining an active GDB connection.
    ** tracepoints and fast tracepoints support added on s390-linux
Grönlund then changed the subject to theRustlanguage which, he said, is
useful in many settings where only C or C++ would work before.Rusthas
its own package manager called "cargo"; its packages are called
"crates", and there is a repository atcrates.io.  Cargo is "at the apex of
usability" for language package managers, he said, adding that developing
code inRustis "a painless and beautiful process".
Linuxare sequences of arbitrary 8-bit symbols, so byte strings work trivially there (as long as you don't assume they're e.g. UTF-8). And Python's Unicode strings work okay for paths on Windows since no conversion is needed. But it's a pain when you're trying to write code to run on both platforms - you either pick one type of string and suffer with error-prone conversions on the other platform, or you create a new opaque native-path type with explicitly lossy conversions to the standard string type (likeRust
The fast reactions in the thread led Gallagher to put out asecond proposalroughly six hours after the
first.  He summarized the objections raised to the first proposal and
listed two alternatives that had been proposed in the thread.  The first
would adopt theDebian Multiarchmechanism,
which uses a/usr/lib/$ARCH-linux-gnudirectory scheme.  One
advantage to that might be the emergence of a de facto standard between
distributions.  The other suggestion from the thread was to default
installations to a single architecture (i.e. 32 or 64 bit) and only install
libraries for that, but to allow additional architectures to be enabled in the DNF
package manager for those users that need them.
The list of SipHash users is large and growing; many projects have adopted
it in an attempt to defend againsthash-collision attacks.  These attacks 
exploit a known hash function to cause a hash table to degrade into a
simple linear list, with potentially devastating effects on performance.
The Python languageswitched to SipHashin
2013; other users include various BSD distributions, Perl, Ruby,Rust, and
more.  This move isnot
universally acclaimed, but most seem to see it as a step in the right
direction.  Thus far, however, the kernel has lacked a SipHash implementation.
Rust, it could all just be in a GC language like Go with no issues and perhaps even better performance due to easier maintenance and reusing better event loop code. 
 
SafeStack is ready to be applied to entire distributions. HardenedBSD is using it globally and Google is working on integrating it into Android (it's mostly stalled on bikeshedding at the moment). It separates the stack into one with all of the return pointers, register spills and safe data (no overflows or address leaks) and keeps the data where overflows can occur separately. It barely has a performance hit, and if you really want to you can still use SSP with it. Linear overflows can't get to the safe stack as long as there are guard pages, so it's a deterministic defence against that with probabilistic mitigation of arbitrary writes via ASLR / libc stack randomization (reserve random runs of guard pages on either side - and with typical 8M stacks, there's nearly zero cost since they already span multiple 2M regions anyway). It's too bad that there aren't hardware features available for a great implementation anymore (i.e. segmentation). 
 
Clang's CFI implementation is similarly ready
The free-software community is often proud that switching to aLinuxdesktop is an almost surefire way to avoid many of the security issues that
plague users of the Windows operating system. Malware forLinuxdesktops
practically doesn't exist. However a lot of that added security may simply
be attributable to the fact that fewer people useLinuxand thus it is a less
attractive target for malware authors. If theLinuxdesktop wants to stay a
secure choice for users it needs to strengthen its security. Bug finding
techniques, safer programming languages, sandboxes, and additional exploit
mitigation techniques can all play a role in this.
Linux-based operating
system tailored to meet specific use cases: Fedora 25 Atomic Host,
Fedora 25 Server, and Fedora 25 Workstation.

Each edition is built from a common set of base packages, which form the
foundation of the Fedora operating system. As with all new versions of
Fedora, Fedora 25 provides many bug fixes and tweaks to these underlying
components, as well as new and enhanced packages, including:

* Docker 1.12 for building and running containerized applications

* Node.js 6.5, the latest version of the popular server-side JavaScript
  engine

* Support forRust
Rust: Fedora 25 brings the support for theRustprogramming
  language.Rustis a system programming language which runs
  blazingly fast, and prevents almost all crashes, segfaults, and
  data races.

* Python: Alongside the "standard" Python versions included in
  Fedora 25 (3.5 and 2.7), Python programmers can now install Python
  3.4, 3.3, and 2.6 from the repositories to help them run test
  suites on multiple Python versions, as well as on PyPy, PyPy3, and
  Jython, which were already there.


Fedora Workstation
==================

The Workstation edition of Fedora 25 Beta is going to show off its
stuff, too:

* GNOME 3.22: Fedora 25 includes GNOME 3.22 in its pre-release and in
  the Final version, coming soon. Helpful new features include multiple
  file renaming, a redesigned keyboard settings tool, and many other UI
  improvements across the environment. For full details, refer to the
  GNOME 3.22 release notes.  https://help.gnome.org/misc/release-notes/3.22/ 

* New Fedora media writer: The new Fedora Media Writer is a tool that
  downloads the latest stable Fedora for you. It then helps you write it
  to media such as a USB stick, so you can take Fedora for a spin on your
  system. If you like what you see, you can install
Rust: Debugging programs written inRustis now supported.

 * Fortran: Support structures with fields of dynamic types and
   arrays of dynamic types.

 * Various Python enhancements (new convenience functions,
   enhanced support for breakpoints).

 * Various GDBserver enhancements:

    ** btrace recording without maintaining an active GDB connection.
    ** tracepoints and fast tracepoints support added on s390-linux
Linux, and have usedLinuxsince 1993 or so. I care about free software, I care about software freedom. 
 
Art is the oldest human endeavor that still persists. It's the thing that binds humanity together. If all anyone has is a cave wall and river full ofrust-red clay
Linuxkernel project is the incremental approach to improvements.  Today's kernel is very different fromLinux1.0, but it is still "the sameLinux".  What if we could do that with a Language?  The C standards process does to an extent, and "C11" is still "C", even though it is very different to K&R C.  But there a limits to how much change can happen there. 
It has always been possible for different projects to use different versions of C, thanks to the macro pre-processor.  Having "list_for_each_entry" and similar is the kernel is a real boon. 
Having pluggable semantic checks could be seen as just another step in that sort of approach.  Why are you so sure that replacing C is a better approach than making C better. 
I like the familiarity and universality of C, and the safety ofRust
The interesting facets of Servo are that it is written to be
extensively parallel in execution and that it is designed to be
intrinsically secure against the most common security bugs that plague
browsers (and other application software).  This security comes by virtue
of being developed in theRustlanguage, which has a variety of built-in memory-safety features.Rustalso offers concurrency features that Servo can leverage to do
parallel page rendering.  As a practical matter, this should enable
faster rendering on today's multi-core hardware.
Linuxkernel is large has little bearing on quality of C. 
 
Oh, and if C is so productive, then please, rewrite Chromium _and_ Qt in plain C. I think that can be done by... Wednesday? And by Thursday you'd probably finish rewriting all the Perl and Python code. 
 
And if you stop giggling, you'd notice that it's perfectly possible to write kernel-mode code inRust
On his blog, Andy Grovermakes a casefor using theRustlanguage for new projects instead of C or Python. 
"Second, there are people like me, people working in C and Python onLinuxsystems-level stuff — the “plumbing”, who are frustrated with low productivity. C and Python have diametrically-opposed advantages and disadvantages. C is fast to run but slow to write, and hard to write securely. Python is more productive but too slow and RAM-hungry for something running all the time, on every system. We must deal with getting C components to talk to Python components all the time, and it isn’t fun.Rustis the first language that gives a system programmer performance and productivity. These people might seeRustas a chance to increase security, to increase their own productivity, to never have to touch libtool/autoconf ever again, and to solve the C/Python dilemma with a one language solution."
Linux<= 4.5)
    * PR build/20029 (symfile.c ambiguous else warning)
    * PR python/20037 (GDB use-after-free error)
    * PR gdb/20039 (Using MI/all-stop, can't interrupt multi-threaded
      program after continue)a

  In the development GDB sources a couple of new features have been
  added:
  
    * Fortran: Support structures with fields of dynamic types and 
      arrays of dynamic types.

    *Rust
LinuxKernel. And just let us not talk about ANY C++ project... Matter of fact is, writing readable and maintainable code sucks in any close-to-the-metal language... 
Heck, even Java won't protect you from badly cobbled together piles of manure. 
 
Ok now, here some examples of why i think you are too pessimistic about Ds capabilities: 
 
 > C++ provides more-or-less standardized ways to transfer and keep track of ownership of data.Rust
OCaml is the implementation language ofCoccinelle, a "semantic
patching" tool for C that is regularly used in theLinuxkernel community and
frequently mentioned on LWN (for example in2009,2010, and2014). Some other notable open-source projects are theCoqproof
assistant, theMLdonkeypeer-to-peer client, and theMirageOSlibrary operating system for constructing unikernels — its supporting
company, Unikernel 
Systems, was acquired by Docker in January 2016.
Linuxyou can have valid file paths that are not valid unicode character sequences. 
 
 > Cannon moved the discussion there with a question: "When should pathlib stop being provisional?"  
 
Hopefully only after it stops assuming that on every platform file paths are anything more than byte strings separated by '/' bytes and terminated with a NUL byte. 
 
Last time I tried pathlib I set my home directory to a path which wasn't valid unicode, and the module threw an exception. 
 
 > Nick Coghlan proposed broadening that idea some:  
> 
 >> Option 4: define a rich-object-to-text path serialisation convention, as paths are not conceptually the same as arbitrary strings, and we can define a new protocol accepted by builtins and standard library modules, while third parties can't  
 >   
 > His wording was perhaps a bit over the top—Van Rossum jokingly called it "a classic 'serious programming' solution (objects, abstractions, serialization, all big important words)"—but the idea behind it was sound.  
 
It's also completely necessary if you want to support all the gory details of paths on every platform python runs on. 
Defining a "common subset" only works if you have full control
Often, two or more free-software projects that have similar goals prefer to
ignore the fact that they compete for users and adoption.  The
developers and advocates choose to let the rivalry remain the
unaddressed elephant in the room whenever they cross paths in public.  But that
was not the case in at least one session at the 2016EmbeddedLinuxConferencein San Diego, when a developer fromYoctoand one
fromBuildrootshared a podium for adiscussionof where the two projects overlapped and where they differed.  Both
are used to build an embeddedLinuxsystem from scratch (or, at least,
from the source code up) and both are popular, but that is about all
that they have in common.
One question that many will ask is "why a new operating system?"  The Redox
developers have ananswerthat boils down to dissatisfaction withLinux, the BSDs, and, even, MINIX
(which is "the most in line with Redox's philosophy").  There
is an admitted "Not Invented Here" sentiment within the project.  But one
thing that is explicitly not a goal for the project is replacingLinux.  Aone-word
answer("No") to the "will Redox replaceLinux?" question is contained in the book.
From : 
    	         Theo de Raadt <deraadt-AT-openbsd.org>   
   To : 
    	         tech-AT-openbsd.org   
   Subject : 
    	         OpenBSD 5.9 released - March 29   
   Date : 
    	         Tue, 29 Mar 2016 12:05:37 -0600  
   Message-ID : 
    	         <98498.1459274737@cvs.openbsd.org>  
   Archive-link : 
    	          Article ,  Thread 
          
   

------------------------------------------------------------------------
- OpenBSD 5.9 RELEASED -------------------------------------------------

March 29, 2016.

We are pleased to announce
"Redox is a Unix-like Operating System..." - So I really don't think it's discarding that much of the Unix tradition. 
Also, from the InfoWorld title: "Rust's Redox OS could showLinuxa few new tricks" - What *new* tricks exactly?
Linuxback. Just ask the BSD people about all that successLinuxdoesn't enjoy because the BSDs have got the market cornered. Not that success matters as such - empowering the user is more important - but I doubt we all agree about that. 

 We wanted to encourage the use, modification, and packaging of Redox in absolutely all realms. Open source should be open, for everyone. There's absolutely no reason for limiting the usage of the software. 

 GPL-licensed code is "open [dramatic pause] for everyone". But anyway, I suppose it's good to see another Free Software operating system project, and one that dares to chooseRust
InfoWorldtakes
a lookat Redox OS.  "Redox usesRustfor its kernel-level code to provide more memory safety considerations than C allows by default. But the project doesn't simply rewriteLinuxin a new language. Redox discards as much fromLinux's version of the Unix tradition as it keeps.

As explained in the project's wiki and design documents, Redox uses a minimal set of syscalls -- a deliberately smaller subset than whatLinuxsupports so as to avoid legacy bloat. The OS also uses a microkernel design to stay slender, in contrast toLinux's monolithic kernel."
LinuxFS community should sit down and define some kind of useful crash consistently model and uAPI enhancement to put this issue to rest for good. Maybe even try to standardize it..  
 
Well, Linus is on record as saying he ignores Posix when Posix is stupid. And (reported on LWN iirc) the filesystem developers did reach out to people like the Postgresql guys, asking what they needed in a file system. I know - I mucked in on that - but really, I think the thing most people really need is some guaranteed write barrier. If I *KNOW* that every write request I make before the barrier will hit spinningrust
rustdrives can keep up with that load and only sit at about 20% utilization, averaged over the time). 
 
In light of the 200TiB figure, it's safe to e.g. not care about doing builds and the like on SSDs, even very big builds of monsters like LibreOffice with debugging enabled (so it writes out 20GiB per build, that's nothing, a ten-thousandth of the worst observed failure level and a hundred thousandth of some of them). But things like huffyuv-compressed video being repeatedly rewritten as things mux and unmux it... that's more substantial. One of my processing flows writes a huffyuv-not-very-compressed data mountain out *eight times* as the mux/unmux/chew/mux/remuxes fly past, and only then gets to deal with tools that can handle something that's been compressed to a useful level. Ideally that'd all sit on a ramdisk, but who the hell has that much RAM? Not me, that's for sure. So I have to let the machine read and write on the order of a terabyte, each time... thankfully, this beingLinux
Rust& JetBrains CLion and Twine game
editor support in Ubuntu Make 15.11 ===

Didier Roche describes the new features in Ubuntu Make 15.11, notably
adding Netbeans,Rust, JetBrains CLion, and Twine game editor support.
He also shares that there have been minor fixes and changes in this
new release, and describes the many tests done by the Ubuntu Jenkins
system.

 http://blog.didrocks.fr/post/Netbeans-and-Rust-support-in... 
 http://blog.didrocks.fr/post/JetBrains-CLion-and-Twine-ga... 

=== Rohan Garg: A clockwork carrot ===

Rohan Garg describes his collaboration with other Kubuntu developers
at the annual LiMux sprint to work on the Continuous Integration
system used by developers, improving file tracking in projects and use
of packagekit and appstream with Muon. He also mentions a backward
clock that they made, inspired by one at the event venue and provides
a link from where it can be downloaded.

 https://kshadeslayer.wordpress.com/2015/11/24/a-clockwork... 

=== Canonical Design Team: An expanded device mono icon set ===

Matthieu James from the Canonical Design Team shares the new Suru icon
theme. He notes that this update focuses on more desktop icons, as
before they focused only on mobile icons. He briefly describes the
process they went through to make them, noting that he had to match it
with the previous
Rusthas a freestanding subset which some people are using for embedded. I expect mostly just "Hello, ARM Cortex-M World!" but you can do it. If you're only dealing with a single core it seems like a reasonable choice. Once you get to something like theLinuxkernel
An active community has built a number ofextensions
and additional toolsthat can be used alongside american fuzzy
lop. There are variants for Python,Rust, and Go, a special QEMU mode that
allows fuzzing binary applications onLinuxwithout having access to the
source code, and many more. The developers of the LLVM compiler framework
have implemented aspecial fuzzing
mode for librariesthat borrows several ideas from american fuzzy
lop.
Rust( http://www.rust-lang.org/ ), or similar.
 
Aside from such a redesign being a major undertaking, choosing a language
likeRusthas another problem: Many more developers can write C thanRust,
so the barrier for contribution would be much higher for most.

 > Unfortunately, such a project is not currently in sight, so the best
  > option media playback applications have right now to provide secure
  > and versatile playback capabilities is to sandbox the decoding process
  > like the Chromium browser. This is challenging to implement and
  > not-portable, which is however a stated goal of both Libav and FFmpeg.
 
Finding and fixing the remaining security problems is another option,
which is currently worked on.

 > Also, I would feel much more comfortable if someone could convince me
  > that FFmpeg is really not a one man show, and is taking maintenance of
  > both internal and external APIs seriously.
 
Your allegation that FFmpeg was a "one man show" is highly disrespectful
to all other FFmpeg contributors, including the Libav developers, whose
improvements are merged by Michael.

Anyway, let me try to convince you again:
FFmpeg 2.4 was released around the same time as Libav 11 in September
Bergstrom then spent a few minutes discussingRustand, in
particular, its memory-safety features.Rustis designed to provide
memory safety without overhead, he said: no reference counting is
required, no garbage collection is needed, and none of the "smart"
pointer classes "that litter most C++ codebases" are necessary.Rust's memory safety comes through its type system: every value has an
owner, and if ownership changes hands, the previous owner can no
longer access the object through references.  Thus, there are no race
conditions and no need to guard against them with locks.
Linuxprograms reproducible on allLinuxsystems [118]
  * chake — serverless configuration management tool for chef [119]
  * docker-compose — punctual, lightweight development environments using Docker [120]
  * fiona — command line tool for reading/writing vector geospatial data [121]
  * flamp — ham radio Amateur Multicast Protocol application [122]
  * git-crypt — Transparent file encryption in git [123]
  * pamu2fcfg — universal 2nd factor (U2F) PAM module command-line helper tool [124]
  * pluginhook — simple plugin system for Bash programs [125]
  * rustc —Rust
rust, and go by the distros. Maybe even Swift if it really takes off. I'm kind of skeptical about that one. Coreutils installations will start to be rare as whatever default dynamic language on the installation medium (python3) handles doing all the unixy regexes and transforms without shelling out of process... 
 
X will go back to being an immediate-mode drawing protocol and DRI will be a laughable thing of the past once the wayland ecosystem solidifies. Most of the application toolkits have already supported it for quite a while; then xwayland will handle loading the required xorg components when necessary, like when I want to play a good old fashioned game of xevil. Once enough time passes, xorg won't even be a default installed component anymore and it'll be like "whaaat, I have to go get xorg to run this? Pffft! I'm not going through that hassle, googleing for a native rebuild..." kinda like xQuartz on a mac... 
 
pixman and glamor will keep older fixed function graphics adapters reasonably operational, all the way back to the good ol' ATI mach64 and matrox G200w (Darn you, integrated server KVM devices!) and various framebuffer devices, including spitting
implemented inRust:  http://zinc.rs/  
 
There's nothing fundamental that can preventRustfrom being used for kernel development. I know folks who are already buildingLinuxkernel API bindings to allowRustmodules. And my friend works on a commercial OS X product that has a driver written inRust.
Rustdoesn't necessarily need one) that enforces isolation should be able to handle OOM and ensure that it can kill an OOM-ing isolate without bringing down the others. But that is orthogonal to whether the standard library APIs abort on OOM. 
 
As others have pointed out, onLinux
Rust(which isn't there yet in 1.0, but hopefully someday) is for OOM and other difficult errors to cause task termination, and for applications and libraries to detect and recover from task termination --- i.e. using tasks to delineate boundaries of failure and recovery. Mapping all catastrophic errors onto "the task died" should reduce the number of observable error states, in particular becauseRustprovides tools to constrain communication between tasks (e.g. preventing data races). 
 
BTW from Mozilla's point of view, systems programming includes browsers and low-level userspace libraries as well as kernels. Robust OOM handling for every individual allocation is so unknown in userspace that it would have been a bad idea to complicateRustto allow for it. Heck, as recently seen on LWN, it's not even the rule in theLinux
Linuxkernel also needs a context (is it GPF_ATOMIC, GPF_KERNEL, GPF_NOIO, GPF_NOFS, or something else?), so the standard library would need to be modified anyways. I'd expect anyone trying to write aLinuxkernel driver inRustto disable the standard library (#![no_std]) and use lower
Rustreleases. 
 
It won't surprise me if somebody manages to write a working "Hello, world"Linuxkernel driver using the "nightly"Rustrelease in less than a month. A more functional driver would have one large obstacle: theLinuxkernel uses a lot of C macros and inline functions
even if the C is far to be perfect, it is difficult to find a better "medium/low level" language. May beRust... 
 
And finally, the Hurd problems are unrelated to the programming language. Otherwise if C would be the problem, how could you explain the success of theLinuxkernel ?
Rustaims to be) is better served by a tasteful combination of features that have already proven themselves useful. Otherwise a decade later you'll just end up with a dumping ground of features that didn't turn out to be so awesome after all.

 
 
Read  this: 
 
 
It seems they are aware of the problem and  are working on fixing it.  
 
 
Besides that, what's the point of checking for errors from close() anyway? You need to call fsync and check its return value to make sure the data you've been writing to disk actually landed there.
 
 
fsync + close is a much more heavyweight operation than plain close. Perhaps there are use cases where knowledge that the data is in the client and/or server kernel buffers is sufficient?
 
 
According to the man page you can only get EIO, EINTR and EBADF.
 
 
I'm not sure that the man page list of errors is supposed to be exhaustive.. 

 
 
EBADF indicates a programming error and is thus not something you're supposed to attempt to handle and EINTR can be dealt with by simply calling it again in a loop, so there's no reason to expose that either.
 
 
Actually
Shortly thereafter, feature development in XFS on IRIX slowed down.  SGI
had shifted its focus to large NUMA machines and distributed IRIX;
development moved from XFS to the newCXFScluster filesystem.  But SGI
also had a new product line that was based onLinux, which didn't have a
filesystem with the features of XFS.  So a team was formed in Melbourne,
Australia to port XFS toLinux.
Linux& Tapas 2015 - Leon, sabado 21 Marzo
 * LoCo Events
 * Lubuntu Blog: [Results] Lubuntu 15.04 - Community Wallpaper Contest
 * Costales: A tablet with Ubuntu preinstalled: UbuTab
 * Costales: Ubuntu MATE: Fall in love
 * Dimitri John Ledkov: Intel CPU microcode support in
 ubuntu-drivers-common
 * Ubuntu Cloud News
 * Ubuntu Phone News
 * Ubuntu at WHD.global 2015
 * The New Ubuntu 15.04 Default Wallpaper Is Here
 * "WhyLinuxIs Still Not Ready For The Desktop"
 * Other Articles of Interest
 * Ubuntu Podcast: S08E01 - Breaking Wind Part 1
 * Weekly Ubuntu Development Team Meetings
 * Monthly Team Reports: February 2015
 * Upcoming Meetings and Events
 * Updates and Security for 10.04, 12.04, 14.04 and 14.10
 * And much more!

== General Community News ==

=== Ubuntu Membership Board call for nominations extended ===

Elizabeth K. Joseph announces the extension of the call for nominations
for the Ubuntu Membership Board as not enough applicants have been
gathered that meet the criteria for staffing the board. She reminds us
how nominations can be made, and confirms that the revised closing date
is March 30th at 12:00 UTC.

 http://fridge.ubuntu.com/2015/03/15/ubuntu-membership-boa... 

== Ubuntu Stats ==

=== Bug Stats ===

    * Open (118241) +339 over last week
    * Critical (271) -3 over last week
    * Unconfirmed (58896) +195 over last week

As always, the Bug Squad needs
linux: fix epoll_pwait() regression with < 2.6.19 (Ben Noordhuis)

*linux: fix epoll_pwait() sigmask size calculation (Ben Noordhuis)

*linux: fix sigmask size arg in epoll_pwait() call (Ben Noordhuis)

*linux: handle O_NONBLOCK != SOCK_NONBLOCK case (Helge Deller)

* doc: update project links (Ben Noordhuis)

* unix: add flag for blocking SIGPROF during poll (Ben Noordhuis)

* unix, windows: add uv_loop_configure() function (Ben Noordhuis)

# v8

* Fix debugger and strict mode regression (Julien Gilli)

* don't busy loop in cpu profiler thread (Ben Noordhuis)

* add api for aborting on uncaught exception (Julien Gilli)
--------------------------------------------------------------------------------
ChangeLog:

* Tue Feb 24 2015 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.34-1
- new upstream release 0.10.34
   https://github.com/joyent/libuv/blob/v0.10.34/ChangeLog 
- resolves incorrect revocation while reliquishing privileges security
  vulnerability (CVE-2015-0278, RHBZ#1194651)
* Thu Feb 19 2015 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.33-2
- add missing %{_?isa} to devel requires of main package
- fix some issues with the pkgconfig file and Group reported by Michael Schwendt
* Thu Feb 19 2015 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.33-1
- new upstream release 0.10.33
   https://github.com/joyent/libuv/blob/v0.10.33/ChangeLog 
- update URL to point to the new libuv.org
* Wed Nov 19 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.29-1
- new upstream
Rustwhen package management problem exists only for the developer as the tools generate statically linked executables. The problem with Python is that it is not simple to produce something that just works on end-user machine and shielding the user from dependency problems requires a careful job by aLinux
Rust. "Rustis a systems programming language that runs blazingly fast, prevents almost all crashes, and eliminates data races"
 
It's a close-to-the-metal language that's even suitable to write kernels in. Perhaps we'll even see parts of theLinuxkernel written inRustin the future
linux: try epoll_pwait if epoll_wait is missing (Michael Hudson-Doyle)

--------------------------------------------------------------------------------
ChangeLog:

* Wed Nov 19 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.29-1
- new upstream release 0.10.29
   https://github.com/joyent/libuv/blob/v0.10.29/ChangeLog 
* Fri Aug  1 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.28-1
- new upstream release 0.10.28
   https://github.com/joyent/libuv/blob/v0.10.28/ChangeLog 
* Thu Jul  3 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.27-3
- build static library forrust
linux: try epoll_pwait if epoll_wait is missing (Michael Hudson-Doyle)

--------------------------------------------------------------------------------
ChangeLog:

* Wed Nov 19 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.29-1
- new upstream release 0.10.29
   https://github.com/joyent/libuv/blob/v0.10.29/ChangeLog 
* Fri Aug  1 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.28-1
- new upstream release 0.10.28
   https://github.com/joyent/libuv/blob/v0.10.28/ChangeLog 
* Thu Jul  3 2014 T.C. Hollingsworth <tchollingsworth@gmail.com> - 1:0.10.27-3
- build static library forrust
Rust, SML (mlton), Haskell (GHC), Clojure. I love some of these languages. The compile/startup time is a downside. 
 
How limiting do you find the JVM dependency to be for startup time? A precompiled Java Hello World runs in about 0.06 seconds for me – could be better, could be worse, and I recognize that benchmarking Hello World is not representative of real code. 
 
[1] tests run on CPU i7-2630QM, DDR3-1600 RAM, SSD disk, ArchLinux
On the other hand, providing a thin compatibility layer to allowLinuxmodules inRustmight just be feasible.
Linuxas the OS, plus additional spinningrust.  Everything has changed a half dozen times over at least (except for the case, only four times for it, I think), but not all at once, and it has always been my primary personal system, and it remains exactly that today.  I've only
Rust):  An Introduction toRustfor
functional programmers (Invited talk).

There will be drinks and some food afterwards, thanks to our sponsors
for this event, LexiFi and Mozilla.

Best,
Thomas

[1] < https://github.com/braibant/oups/wiki >
[2] < http://www.meetup.com/ocaml-paris/ >
      
========================================================================
4) Uucp 0.9.0
Archive: < https://sympa.inria.fr/sympa/arc/caml-list/2014-06/msg001... >
------------------------------------------------------------------------
** Daniel Bünzli announced:

I'd like to announce uucp:

  Uucp is an OCaml library providing efficient access to a selection
  of character properties of the [Unicode character database][1].

  Uucp is independent from any Unicode text data structure and has no
  dependencies. It is distributed under the BSD3 license.

  [1]: < http://www.unicode.org/reports/tr44/ >

Home page: < http://erratique.ch/software/uucp >
Documentation: < http://erratique.ch/software/uucp/doc/Uucp >
Github mirror: < https://github.com/dbuenzli/uucp >

It should be available shortly in opam. A few comments about the
library can be found at the end of this message.

Part of this work was sponsored by OCaml Labs, many thanks for their
support.

Best,

Daniel


A few notes.

* Having seen unwarranted sights of horror at the simple mention of 
  Unicode by fellow peers I took the time to write an absolute minimal
  introduction to Unicode in the documentation:

  < http://erratique.ch
Rustand Go developers they should spend
their free time working on C compilers instead because the latter would be
more immediately useful to commercial users)

On top of this, various outreach efforts to encourage new contributors are
working, and working well enough that they are actually *exceeding* the
existing team's ability to effectively *absorb* those new contributors.

So, tremendously high stress levels for the core development team, on top
of whatever stress we have to deal with in our personal and professional
lives.

This stress then manifests as irritability, impatience and outright anger -
my own stress levels reached sufficiently high levels earlier this year
that I almost decided to walk away from my job. Red Hat management
intervened to keep that from actually happening, but I think it's important
to make that incident more public to help people understand how utterly
unsustainable the status quo is when it comes to CPython - we can't keep
relying on almost entirely volunteer effort to maintain 2.7 LTS, 3.x, all
the python.org infrastructure *and* the PSF without also anticipating
complete and total burnout of some highly invested contributors.

PEP 462 describes some ideas to make more effective
Linuxenvironments and software development tools.
- Design of Graphical User Interfaces.
- Hands-on experience with formal verification tools: Coq, PVS, Why3,
etc.

#### Applying

If you're interested in joining LSL, send us an email to share what
inspires you, and why you think you are perfect for the team. Send it
along with a resume at florent.kirchner@cea.fr.
      
========================================================================
4) IOCaml 0.4
Archive: < https://sympa.inria.fr/sympa/arc/caml-list/2014-04/msg000... >
------------------------------------------------------------------------
** Andy Ray announced:

IOCaml provides an OCaml REPL in a webbrowser.  Version 0.4 frees us
from the tyranny of Python and provides an OCaml based webserver.  Put
another way you no longer need IPython installed at all.

The project is split into 3 opam packages;

* iocaml-kernel (< https://github.com/andrewray/iocaml >) - byte code OCaml kernel
* iocamljs-kernel (< https://github.com/andrewray/iocamljs >) - javascript
OCaml kernel(s)
* iocaml (< https://github.com/andrewray/iocamlserver >) - iocaml webserver

In general from a 4.01.0 compiler

$ opam install iocaml

should get everything installed.  OS requirements are libssl-dev and
libzmq3-dev (possibly some others as well, let me know and I'll add
them to the project pages).  Chrome, Firefox and Safari have been
tested.

To run iocaml;

$ iocaml

or

$ iocaml path/to/dir

To bring up the dashboard interface
Well, I actually think that once a good contender comes (Rust, maybe?) it makes total sense to migrateLinuxto it bit-by-bit.
rustwas so slow compared to the rest of the system that it was worth just about any computational effort to optimize it  
 
Computational effort is one thing.  RAM cost is another, and it frequently dominates.Linuxhas worse problems with slow devices than with fast ones.  SSDs are raising
rust) workload, it's mostly large transfers.
  > Obviously these are misalgned at the ends, but we can fix some of that
  > in the scheduler.  Particularly if the FS helps us with layout.  My
  > instinct tells me that we can fix 99% of this with layout on the FS + io
  > schedulers ... the remaining 1% goes to the drive as needing to do RMW
  > in the device, but the net impact to our throughput shouldn't be that
  > great.
 
There are a few workloads where the VM and the FS would team up to make
this fairly miserable

Small files.  Delayed allocation fixes a lot of this, but the VM doesn't
realize that fileA, fileB, fileC, and fileD all need to be written at
the same time to avoid RMW.  Btrfs and MD have setup plugging callbacks
to accumulate full stripes as much as possible, but it still hurts.

Metadata.  These writes are very latency sensitive and we'll gain a lot
if the FS is explicitly trying to build full sector IOs.

I do agree that its very likely these drives are going to silently rmw
in the background for us.

Circling back
rust) workload, it's mostly large transfers.
  > > Obviously these are misalgned at the ends, but we can fix some of that
  > > in the scheduler.  Particularly if the FS helps us with layout.  My
  > > instinct tells me that we can fix 99% of this with layout on the FS + io
  > > schedulers ... the remaining 1% goes to the drive as needing to do RMW
  > > in the device, but the net impact to our throughput shouldn't be that
  > > great.
  > >
  > > James
  > >
  > 
  > I think that the key to having the file system work with larger
  > sectors is to 
  > create them properly aligned and use the actual, native sector size as
  > their FS 
  > block size. Which is pretty much back the original challenge.
 
Only if you think laying out stuff requires block size changes.  If a 4k
block filesystem's allocation algorithm tried to allocate on a 16k
boundary for instance, that gets us a lot of the performance without
needing a lot of alteration.

It's not even obvious that an ignorant 4k layout is going
LinuxPlumbers Conference is held in New Orleans, September 18 to
20 (LWNcoverage.
TheLinuxSecurity Summit is also heldon site, on September 19 and 20 (LWNcoverage).
Linuxdoes not 
 
Now about the "UI choice" (or whatever you want to call it) with multiple desktops onLinux. This was supposed to be some kind of "better approach" in order to satisfy the needs of just about everyone, but supposedly targeting exactly what each group wanted. That is what we (the remaining,rusted
Here is LWN's sixteenth annual timeline of significant events in
theLinuxand free software world for the year.  As per tradition, we
 divide up the timeline up into quarters; this is our account of
October–December 2013.  Timelines are also available covering  wasJanuary through March,April through
JuneandJuly through September;
the combined timeline for all of 2013 will appear after the start of
the new year, including any late-breaking stories.
LinuxPlumbers Conference is held in New Orleans, September 18 to
20 (LWNcoverage.
TheLinuxSecurity Summit is also heldon site, on September 19 and 20 (LWNcoverage).
LinuxThe only ambiguity here is what "it" refers to. It could be either the newly written kernel or theRustprogramming language. However, with the phrase "if you are correct" he clearly refers to some statement I made earlier, and I never said anything about some hypothetical new kernel
Rustis probably not even in the first hundred 'new secure languages that the kernel should be re-written in to solve all the evils of the world'  
I never claimed that any language will solve all evils of the world, or that the kernel should be rewritten. But a programming language *can* solve silly things like buffer overflows (well, most of them) or format string vulnerabilities. 
And let's not mention the fact that you didn't name even *one* argument whyRustwouldn't be a viable competitor. Especially when considering that I was talking aboutRust1.0 that isn't even released yet... 
 
 > If you think that writing a kernel in a different language is the right thing to do, go write it, and if you are correct and it is superior, you will displaceLinux
LinuxLinus has said many times that he expects that eventually there will be some other kernel written that will replaceLinux. It is possible that you are correct andRustwill be the language that such a kernel is written in. 
 
but given the track record of such claims
every 30s of
over 30,000 IOPS. Which filesystem is going to scale better on
desktops with spinningrust?

Cheers,

Dave.
-- 
Dave Chinner
david@fromorbit.com
--
To unsubscribe from this list: send the line "unsubscribelinux-fsdevel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at   http://vger.kernel.org/majordomo-info.html
There will always be a tension in language design between allowing
the programmer freedom of expression and guiding the programmer
toward clarity of expression.  In aprevious article, we saw
how the type system ofRustprefers clarity over freedom.  Go is not
such a stickler, and is satisfied with run-time type checks in places
whereRustwould insist on compile-time checks. Here, when we look at the structuring of statements and expressions, we
findRustprefers freedom while Go seems more focused on clarity by
eliminating unnecessary flexibility.
like to get more information about the state of the art of the AOO side, without having to parse changelogs and source code. Having that kind of digest-like information give a 20'000 feet view of the real process involved in the dev of LO, orRust, orLinux, etc.
BothRustandGohave embraced these trends, though not as fully as
BIND configuration files and other languages likeCrackwhich allow
all three (/* */,//,#).Rustand Go only
support the C 
and C++ styles.
Linuxdistros. Also it has Bash which makes it feel almost like home.
 
But there are multiple annoyances with it: lousy keyboard layout, inconsistent keyboard shortcuts for most applications (next tab anyone?), slooow with a spinningrustdisk, and very hungry for resources. I miss my XFCE/GNU/Linux desktop machine all the time
Petersen put up a list of the hints implemented or used byLinux, NFS, and
Windows, along with those proposed for T10 SBC.
Some of the hints themselves were questioned, including
"SEQUENTIAL_BACKWARDS" for NFS, which Ric Wheeler wondered about:
are there really applications that need to do that?  It turns out that some
unnamed database does actually have that access pattern.
> I've recently tried to useRustinstead of Go for simple "scripts" and I really loved it.  
 
What OS/distro are you using? I tried to buildRuston both OS X andLinuxMint 12.04, but both failed, for different reasons.
internals of the MMC device too. Which you can't. Although Samsung can. So that's nice for them.
 
Really, people who are serious about embeddedLinuxshould be driving the NAND  directly  rather than accepting the MMC "pretend to be spinningrust" approach, with all the disadvantages and unreliability that it brings.
rust. 
 
Successful projects require (i) good people; (ii) good technology; (iii) good process.  TheLinuxkernel has the first two in spades, but has gaps in the third. Maybe the time is coming for a few-month digression onto testing and tracking infrastructure, like there was in the past with
Linuxhas two easy options for parallelism. You can fork(), which gives you shared-nothing parallelism (which is great, very easy to reason about) with somewhat cumbersome and expensive IPC (serialized objects copied explicitly over sockets or shared memory, explicit chunk-of-shared-bytes via mmap, that sort of thing). Or you can use "threads", and get shared-everything parallelism (which is horrible) with fast IPC, except the GIL kind of kills that. 
 
But you can imagine PyPy implementing fork()-like shared-nothing semantics *with* fast IPC. It'd use pthreads underneath, but with each thread having a totally different Python namespace, and when you passed an object to another thread it would just mark it copy-on-write instead of actually making a copy. This is how languages designed for parallelism, like Erlang orRust
Linux, I had to order it imported from Canada, but no way was I going to be an eXPrivacy statistic, even if I did buy it with the express intent of immediately sticking Gentoo on it) -- before they killed things with the all butLinuxincompatible outsourced graphics. 
 
It's still going strong!  One of the first things I did was add a 1-gig stick of RAM to it, it's one of the first netbooks with a regular SATA interface and I chose the 120 gig "rotatingrust
Rustalso disallows null pointers, which I personally do not agree with. Maybe it's my background as a C programmer, but I like having a special value to represent "none." I always find myself using clunky workarounds to emulate NULL  
 
I don't remember the details, but I'm pretty sure it's easy and idiomatic inRustto define a "maybe<X>" type: a value which is either "none" or else has a real pointer-to-X in it. The trick is that unlike C, now you *can't* dereference such a pointer without checking for NULL-ness when "unpacking" it. This might seem like a burden, but of course it only applies to those pointers which *might* be NULL, which are exactly the ones that you have to check. So they're not trying to make this clunky; basically it's just like C, except now the compiler will keep track of when you need to check for NULL and when you don't. Boom, no more segfaults. 
 
 >Rusthas this concept of "typestate," which is kind of like theLinux
Rust's approach is viable.Rustalso disallows null pointers, which I personally do not agree with.  Maybe it's my background as a C programmer, but I like having a special value to represent "none."  I always find myself using clunky workarounds to emulate NULL when it is not present in the language-- especially in languages without exceptions (but more about that later.)Rusthas generics, and Go does not.  The creators of Go have publicly stated that generics might be added in the future, but nobody has a timeframe.  Generics are probably the thing that I most miss in Go. 
 
BothRustand Go try to encourage you NOT to use exceptions as a control flow mechanism.Rusthas "fail," and Go has "panic," but neither of them is a traditional exception mechanism like you might find in Java.  They don't allow you to associate much with the exception except a string.  This seems like a good choice to me-- flow control via exceptions is icky.  It will surprise some people, though.Rusthas this concept of "typestate," which is kind of like theLinux
rustingCygwin/X: Refactor framebuffer allocation/release in drawing engines
      Cygwin/X: Rather than storing calculated physical display sizes, calculate them when needed
      Cygwin/X: Remove an attempt at detecting if WM_DISPLAYCHANGE affects the X screen
      Cygwin/X: Move QueryMonitor() out of windprocarg.c
      Cygwin/X: Add -resize command line option
      Cygwin/X: Implement framebuffer resizing in RANDR extension
      Cygwin/X: Make WM_SIZE use RandR resizing when -resize=randr
      Cygwin/X: Generate RANDR change on WM_DISPLAYCHANGE for rootless modes
      Cygwin/X: Don't turn off -multiplemonitors when all monitors don't have the same pixel format
when using shadow GDI engine
      Cygwin/X: Fix a typo in command line argument validation code
      Cygwin/X: Remove WIN_DIB_MAXIMUM_SIZE check
      Cygwin/X: Use winUpdateFBPointer() in winshaddd.c rather than duplicating it inline
      Cygwin/X: Deal with RANDR depth changes correctly in ShadowGDI drawing engine
      Cygwin/X: Simplify and consolidate reporting of the bpp value we are going to use
      Cygwin/X: DirectDraw engines shouldn't try to blit if the surface wasn't allocated
      Fix compilation of xf86bigfont.c
      Cygwin/X: Generate X keycodes for multimedia keys
      Cygwin/X: Better keycode debugging output
      Cygwin/X: Update mapping for Canadian keyboard layouts
      Cygwin/X: Make the keyboard layout detection logging a bit clearer
      Cygwin/X: Add Turkish keyboard layouts to keyboard layout
Alex Deucher (3):
      drm/radeon/kms: leave certain CP int bits enabled
      drm/radeon/kms: make TV/DFP table info less verbose
      drm/radeon/kms: fix bad cast/shift in evergreen.c

Anders Larsen (1):
      ARM: 6436/1: AT91: Fix power-saving in idle-mode on 926T processors

Andi Kleen (4):
      HWPOISON: Copy si_addr_lsb to user
      HWPOISON: Report correct address granuality for AO huge page errors
      HWPOISON: Stop shrinking at right page count
      Define _addr_lsb in siginfo_t for mips

Andrei Emeltchenko (1):
      Bluetooth: fix MTU L2CAP configuration parameter

Andrew Morton (1):
      MAINTAINERS: Haavard has moved

Andy Walls (1):
      V4L/DVB: cx25840: Fix typo in volume control initialization: 65335 vs. 65535

Andy Whitcroft (1):
      intel_ips -- ensure we do not enable gpu turbo mode without driver linkage

Aneesh Kumar K.V (2):
      ceph: Fix return value of encode_fh function
      ceph: Update max_len with minimum required size

Aristeu Rozanski (1):
      Input: wacom - fix pressure in Cintiq 21UX2

Arnaud Lacombe (1):
      kconfig: delay symbol direct dependency initialization

Baruch Siach (1):
      V4L/DVB: mx2_camera: fix a race causing NULL dereference

Ben Hutchings (2):
      Revert "ipv4: Make INET_LRO a bool instead of tristate."
      netdev: Depend on INET before selecting INET_LRO

Boaz Harrosh (1):
      exofs: Fix double page_unlock BUG in write_begin/end

Borislav Petkov (1):
      x86, AMD, MCE thresholding: Fix the MCi_MISCj iteration order

Breno Leitao (1):
      ehea: Fix a checksum issue on the receive path

Brian Rogers (1):
      V4L/DVB: ir-core: Fix null dereferences in the protocols sysfs interface

Chris Wilson (1):
      drm/i915: Prevent module unload to avoid random memory corruption

Dan Carpenter (8):
      V4L/DVB: unlock on error path
      V4L/DVB: IR: ir-raw-event: null pointer dereference
      V4L/DVB: opera1: remove unneeded NULL check
      V4L/DVB: pvrusb2: remove unneeded NULL checks
      V4L/DVB: saa7164: move dereference under NULL check
      cls_u32: signedness bug
      isdn: strcpy() => strlcpy()
      OSS: soundcard: locking bug in sound_ioctl()

Dan Rosenberg (3):
      V4L/DVB: ivtvfb: prevent reading uninitialized stack memory
      sctp: prevent reading out-of-bounds memory
      sctp: Fix out-of-bounds reading in sctp_asoc_get_hmac()

Dan Williams (1):
      ioat2: fix performance regression

Dave Airlie (1):
      drm: don't drop handle reference on unload

David S. Miller (3):
      Merge branch 'master' of master.kernel.org:/.../torvalds/linux-2.6
      Merge branch 'master' of git://git.kernel.org/.../padovan/bluetooth-2.6
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-2.6

David Stevens (1):
      ipv4: correct IGMP behavior on v3 query during v2-compatibility mode

Deng-Cheng Zhu (1):
      perf, MIPS: Support cross compiling of tools/perf for MIPS

Dmitri Belimov (1):
      V4L/DVB: Fix regression for BeholdTV Columbus

Dmitry Torokhov (1):
      Input: wacom - fix runtime PM related deadlock

Eric BÃ©nard (2):
      cpuimx27: fix compile when ULPI is selected
      cpuimx27: fix i2c bus selection

Eric Dumazet (3):
      caif: fix two caif_connect() bugs
      sysctl: fix min/max handling in __do_proc_doulongvec_minmax()
      tg3: restore rx_dropped accounting

Eric Paris (1):
      fanotify: disable fanotify syscalls

Felix Fietkau (1):
      ath9k_hw: fix regression in ANI listen time calculation

Grant Likely (1):
      of/i2c: Fix module load order issue caused by of_i2c.c

Greg Farnum (1):
      ceph: send cap release message early on failed revoke.

Greg Ungerer (1):
      net: allow FEC driver to use fixed PHY support

Gustavo F. Padovan (5):
      Bluetooth: Simplify L2CAP Streaming mode sending
      Bluetooth: Fix inconsistent lock state with RFCOMM
      Revert "Bluetooth: Don't accept ConfigReq if we aren't in the BT_CONFIG state"
      Bluetooth: Fix deadlock in the ERTM logic
      Bluetooth: Disallow to change L2CAP_OPTIONS values when connected

Hans Verkuil (1):
      V4L/DVB: videobuf-dma-sg: set correct size in last sg element

Hari Kanigeri (1):
      omap: iommu-load cam register before flushing the entry

Henrik Rydberg (1):
      Input: uinput - setup MT usage during device creation

Henry C Chang (1):
      ceph: fix list_add usage on unsafe_writes list

Ionut Gabriel Popescu (1):
      V4L/DVB: mt9v022.c: Fixed compilation warning

J. Bruce Fields (1):
      nfsd: fix BUG at fs/nfsd/nfsfh.h:199 on unlink

Jarod Wilson (1):
      V4L/DVB: mceusb: add two new ASUS device IDs

Jason Wang (1):
      V4L/DVB: gspca - main: Fix a crash of some webcams on ARM arch

Jean Delvare (1):
      drm/radeon/kms: Silent spurious error message

Jean-FranÃ§ois Moine (1):
      V4L/DVB: gspca - sn9c20x: Bad transfer size of Bayer images

Jeff Kirsher (4):
      ixgbevf.txt: Update ixgbevf documentation
      e1000.txt: Update e1000 documentation
      e1000e.txt: Add e1000e documentation
      MAINTAINERS: update Intel LAN Ethernet info

Jens Axboe (1):
      elevator: fix oops on early call to elevator_change()

Jerome Glisse (1):
      drm/radeon/kms: avoid corner case issue with unmappable vram V2

Jesse Barnes (4):
      IPS driver: don't toggle CPU turbo on unsupported CPUs
      IPS driver: verify BIOS provided limits
      IPS driver: apply BIOS provided CPU limit if different from default
      IPS driver: disable CPU turbo

Jin Dongming (1):
      x86, mce, therm_throt.c: Fix missing curly braces in error handling logic

Jiri Slaby (4):
      ATM: solos-pci, remove use after free
      ATM: mpc, fix use after free
      ATM: iphase, remove sleep-inside-atomic
      NET: wimax, fix use after free

Johannes Berg (1):
      mac80211: delete AddBA response timer

Johannes Weiner (1):
      xfs: properly account for reclaimed inodes

John Blackwood (1):
      perf: Fix incorrect copy_from_user() usage

John W. Linville (1):
      Revert "mac80211: use netif_receive_skb in ieee80211_tx_status callpath"

Kees Cook (2):
      net: clear heap allocation for ETHTOOL_GRXCLSRLALL
      net: clear heap allocations for privileged ethtool actions

Kenneth Waters (1):
      Input: joydev - fix JSIOCSAXMAP ioctl

Kirill A. Shutemov (1):
      memcg: fix thresholds with use_hierarchy == 1

Kukjin Kim (1):
      ARM: SAMSUNG: Fix build warnings because of unused codes

Kyle McMartin (1):
      kbuild: fix oldnoconfig to do the right thing

Kyungmin Park (1):
      MAINTAINERS: add Samsung S5P series FIMC maintainers

Laurent Pinchart (2):
      V4L/DVB: uvcvideo: Fix support for Medion Akoya All-in-one PC integrated webcam
      V4L/DVB: uvcvideo: Restrict frame rates for Chicony CNF7129 webcam

Lee, Chun-Yi (1):
      ACPI: add DMI to disable AML Vista compatibility on MSI GX723 Notebook

Len Brown (3):
      intel_idle: enable Atom C6
      Merge branch 'pdc-regression' into release
      Merge branch 'msi-dmi' into release

Linus Torvalds (31):
      Merge branch 'i2c-for-linus' of git://git.kernel.org/.../jdelvare/staging
      Merge branch 'v4l_for_linus' of git://git.kernel.org/.../mchehab/linux-2.6
      Merge branch 'for-linus' of git://oss.sgi.com/xfs/xfs
      Merge branch 'for-linus' of git://git.kernel.org/.../dtor/input
      Merge branch 'drm-fixes' of git://git.kernel.org/.../airlied/drm-2.6
      Merge branch 'for-linus' of git://neil.brown.name/md
      Merge branch 'for-linus' of git://git.kernel.dk/linux-2.6-block
      Merge branch 'hwpoison-fixes' of git://git.kernel.org/.../ak/linux-mce-2.6
      Merge branch 's5p-fixes-for-linus' of git://git.kernel.org/.../kgene/linux-samsung
      Merge branch 'drm-intel-fixes' of git://git.kernel.org/.../ickle/drm-intel
      Merge branch 'for-linus' of git://git.open-osd.org/linux-open-osd
      Merge branch 'for-linus' of git://git.kernel.org/.../sage/ceph-client
      Merge branch 'release' of git://git.kernel.org/.../lenb/linux-acpi-2.6
      Merge branch 'idle-release' of git://git.kernel.org/.../lenb/linux-idle-2.6
      Merge git://git.kernel.org/.../davem/net-2.6
      Merge branch 'for-linus' of git://git.kernel.org/.../tiwai/sound-2.6
      Merge branch 'for-linus' of git://git.kernel.org/.../dtor/input
      Merge branch 'for_linus' of git://git.kernel.org/.../mjg59/platform-drivers-x86
      Merge branch 'rc-fixes' of git://git.kernel.org/.../mmarek/kbuild-2.6
      Merge branch 'kvm-updates/2.6.36' of git://git.kernel.org/pub/scm/virt/kvm/kvm
      Merge branch 'x86-fixes-for-linus' of git://git.kernel.org/.../tip/linux-2.6-tip
      Merge branch 'drm-fixes' of git://git.kernel.org/.../airlied/drm-2.6
      Merge branch 'omap-fixes-for-linus' of git://git.kernel.org/.../tmlind/linux-omap-2.6
      Merge master.kernel.org:/home/rmk/linux-2.6-arm
      Merge branch 'perf-fixes-for-linus' of git://git.kernel.org/.../tip/linux-2.6-tip
      Merge branch 'for-2.6.36' of git://linux-nfs.org/~bfields/linux
      Merge branch 'fixes' of git://git.kernel.org/.../djbw/async_tx
      Don't dump task struct in a.out core-dumps
      Merge git://git.kernel.org/.../davem/net-2.6
      Un-inline the core-dump helper functionsLinux2.6.36-rc8

Luke Yelavich (1):
      ALSA: hda - Add another HP DV6 quirk

Maciej Å»enczykowski (1):
      net: Fix IPv6 PMTU disc. w/ asymmetric routes

Marek Szyprowski (2):
      V4L/DVB: v4l: radio: si470x: fix unneeded free_irq() call
      ARM: SAMSUNG: Add a workaround for get_clock() for serial driver

Mark Brown (3):
      ASoC: Add Jassi Brar as Samsung maintainer
      ASoC: Add Dimitris Papastamos to Wolfson maintainers
      ASoC: Update links for Wolfson MAINTAINERS entry

Mat Martineau (1):
      Bluetooth: Only enable L2CAP FCS for ERTM or streaming

Matthew Garrett (1):
      IPS driver: Fix limit clamping when reducing CPU power

Mauro Carvalho Chehab (3):
      V4L/DVB: Don't identify PV SBTVD Hybrid as a DibCom device
      V4L/DVB: rc-core: increase repeat time
      V4L/DVB: cx231xx: Avoid an OOPS when card is unknown (card=0)

Maxim Levitsky (3):
      V4L/DVB: IR: fix duty cycle capability
      V4L/DVB: IR: fix keys beeing stuck down forever
      V4L/DVB: IR: extend MCE keymap

Michael Grzeschik (2):
      V4L/DVB: mt9m111: cropcap and s_crop check if type is VIDEO_CAPTURE
      V4L/DVB: mt9m111: added current colorspace at g_fmt

Michal Marek (1):
      kconfig: Temporarily disable dependency warnings

Mika Westerberg (1):
      ARM: 6440/1: ep93xx: DMA: fix channel_disable

Mike Snitzer (1):
      virtio-blk: fix request leak.

Nagendra Tomar (1):
      net: Fix the condition passed to sk_wait_event()

Naoya Horiguchi (1):
      page-types.c: fix name of unpoison interface

Neil Horman (1):
      bonding: fix WARN_ON when writing to bond_master sysfs file

NeilBrown (2):
      md/raid1:  avoid overflow in raid1 resync when bitmap is in use.
      md/raid1: minor bio initialisation improvements.

Olivier Grenie (2):
      V4L/DVB: dib7770: enable the current mirror
      V4L/DVB: dib7000p: add disable sample and hold, and diversity delay parameter

Oskar Schirmer (1):
      net/fec: carrier off initially to avoid root mount failure

Paul Fertser (1):
      b44: fix carrier detection on bind

Pawel Osciak (4):
      V4L/DVB: v4l: mem2mem_testdev: fix errorenous comparison
      V4L/DVB: v4l: mem2mem_testdev: add missing release for video_device
      V4L/DVB: v4l: s5p-fimc: Fix return value on probe() failure
      V4L/DVB: v4l: videobuf: prevent passing a NULL to dma_free_coherent()

Rajendra Nayak (1):
      i2c: Fix checks which cause legacy suspend to never get called

Randy Dunlap (1):
      V4L/DVB: tm6000: depends on IR_CORE

Richard Zidlicky (1):
      V4L/DVB: dvb: fix smscore_getbuffer() logic

Robin Holt (1):
      mm: alloc_large_system_hash() printk overflow on 16TB boot

Russell King (3):
      ARM: fix section mismatch warnings in Versatile Express
      Merge branch 'for-rmk' of git://git.pengutronix.de/git/imx/linux-2.6
      ARM: relax ioremap prohibition (309caa9) for -final and -stable

Sage Weil (2):
      ceph: avoid null deref in osd request error path
      ceph: update issue_seq on cap grant

Santosh Shilimkar (1):
      ARM: 6419/1: mmu: Fix MT_MEMORY and MT_MEMORY_NONCACHED pte flags

SeungChull Suh (1):
      ARM: S5P: Bug fix on errors of build with CONFIG_PREEMPT_NONE

Stanislaw Gruszka (3):
      skge: add quirk to limit DMA
      r8169: allocate with GFP_KERNEL flag when able to sleep
      r8169: use device model DMA API

Stefan Ringel (1):
      V4L/DVB: tm6000: bugfix data handling

Steven Rostedt (1):
      ring-buffer: Fix typo of time extends per page

Sylwester Nawrocki (1):
      V4L/DVB: v4l: s5p-fimc: Fix 3-planar formats handling and pixel offset error on S5PV210 SoCs

Takashi Iwai (1):
      Merge branch 'fix/asoc' into for-linus

Thomas Hellstrom (1):
      drm/ttm: Fix two race conditions + fix busy codepaths

Tim Gardner (1):
      intel_ips: Print MCP limit exceeded values.

Tony Lindgren (1):
      ARM: 6435/1: Fix HWCAP_TLS flag for ARM11MPCore/Cortex-A9

Vasiliy Kulikov (1):
      md: check return code of read_sb_page

Vishwanath BS (1):
      i2c: Fix for suspend/resume issue

Will Deacon (2):
      ARM: 6416/1: errata: faulty hazard checking in the Store Buffer may lead to data corruption
      ARM: 6412/1: kprobes-decode: add support for MOVW instruction

Wolfram Sang (1):
      i2c: Remove obsolete cleanup for clientdata

Yegor Yefremov (1):
      i2c-pca: Fix waitforcompletion() return value

Yinghai Lu (2):
      ACPI: Handle ACPI0007 Device in acpi_early_set_pdc
      x86, numa: For each node, register the memory blocks actually used

Zachary Amsden (2):
      KVM: x86: Fix SVM VMCB reset
      KVM: x86: Move TSC reset out of vmcb_init

lawrencerust(1):
      V4L/DVB: cx88: Kconfig: Remove EXPERIMENTAL dependency from VIDEO_CX88_ALSA

minskey guo (4):
      seqno mask of THM_ITV register is 16bit
      old_cpu_power is wrongly divided by 65535 in ips_monitor()
      Release symbol on error-handling path of ips_get_i915_syms()
      NULL pointer might be used in ips_monitor()
Linuxlast year, developed in order to test the core TRIM code. When do we get it on "real hardware"? This year? Next? 
 Being "wedged between stable interfaces" isn't a boon, in this case. 
Because it's wedged under an  inappropriate  stable interface, we are severely hampered in what we can do with it.

  "People that look at SSDs and see them just as disks and don't think about
the future will think it's best if the hardware does as much as possible.
But if you forget the classic disk model and look at what's really going
on it seems obvious that the classic disk model isn't that simple anyway
and doesn't fit flash or how the hardware looks like and could be used."  

Agreed. I think it's OK for the hardware to do the same kind of thing that disk hardware does for us — ECC, and some block remapping to hide bad blocks. But that's all; we don't want it implementing a whole file system of its own just so it can pretend to be spinningrust
rustplatters") at that spot.
  > This will obviously cause a write failure, and the previous contents
  > of the sector will be lost.  This is also considered a failure of the
  > ATOMIC-WRITE property, and no, ext3 doesn't handle this case
  > gracefully.  Very few file systems do.  (It is possible for an OS
  > that
 
Actually, ext2 should be able to survive that, no? Error writing ->
remount ro -> fsck on next boot -> drive relocates the sectors.

 > It's for this reason that I've never been completely sure how useful
  > Pavel's proposed treatise about file systems expectations really are
  > --- because all storage subsystems *usually* provide these guarantees,
  > but it is the very rare storage system that *always* provides these
  > guarantees.
 
Well... there's very big difference between harddrives and flash
memory. Harddrives usually work, and flash memory never does.

 > We could just as easily have several kilobytes of explanation in
  > Documentation/* explaining how we assume that DRAM always returns the
  > same value that was stored in it previously --- and yet most PC class
  > hardware still does not use ECC memory, and cosmic rays
rustand fool's gold which are both very high in iron aren't 
suitable for making a good bridge. On the other hand stone and wood are 
both quite low in iron ordinarily, and have made reliable, and sometimes 
very pretty bridges for hundreds of years.
 
So it's like irony, then? (Sorry.)
 
Also, its 2008 and Unicode has been available onLinux
rustand fool's gold which are both
very high in iron aren't suitable for making a good bridge. On the other hand stone and wood
are both quite low in iron ordinarily, and have made reliable, and sometimes very pretty
bridges for hundreds of years.

Also, its 2008 and Unicode has been available onLinux
The Registerlooks
atVMWare's IPO, which could be in trouble before it happens.
"Writing on his blog VentureCake,Linuxspecialist Mike MacCana
thinks he might have found a bit ofruston VMware's shining armor. He
claims that VMware's ESX server is derived fromLinux, and therefore is not
legally re-distributable as proprietary software."
linux-elitists] ShipIt Deus Ex: Ubuntu, good for Disorder?  
   Date : 
    	         Wed, 08 Dec 2004 09:31:34 -0500  
   
Well, I got some more CDs in the mail, unexpectedly... Only x86 and PPC
though.

I gave one of the x86 CDs to a person the has a moderate, livable and
quite able to take care of himself, Obsessive-Compulsive Disorder. Lets
call him Phil.

Phil was whining about that even FireFox v1 and other nice tools I gave
him... Windows is still, STILL making his Browse only 3.2GHz machine a
PITA. 7 minutes to boot into the desktop, 300+ pop-ups without even
starting the browser (errmmm I tried to explain that the browser is
always on... but comprehension, ehhh.). And that for him to complete his
task list of browsing X number of sites and reading the news and his
points of interest on schedule was just not happening.

This is terribly distressing to him.

I was so confident about the Install-ability of Ubuntu, that I gave him
a jacket with the Live-CD and Install-CD. Oh boy. He was under serious
stress level that I told him to install it. I gave Phil explicit
instruction
Arustedslackbarcode theme.
ALinuxnetwork configuration package.
A free Web server compatible withLinuxand Windows.
ArustedDebian background.
